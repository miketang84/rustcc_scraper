https://github.com/fragarriss/CurVis
-->>-->>
Repository files navigation README MPL-2.0 license CurVis A Raytracer on Curved Spacetimes. Author: Francesco Garrisi Description CurVis is a Rust Package that allows rendering images and videos on curved spacetimes, by simulating the propagation of light using equations from General Relativity. Out of the shelf, the CurVis binary can render images of wormholes such as the Ellis wormhole or the wormhole seen in the movie Interstellar. CurVis is based on the work of O. James et al., 2015, ( https://doi.org/10.1119/1.4916949 ) and was inspired by this YouTube video from Scott Manley. Installation If you are cloning the library from GitHub, you will need to compile the source code before you can run it. If you have cargo installed on your system, you can use a terminal to navigate to your local repository and run cargo build --release This will compile the source code and place the executable within ./target/release . Basic Usage Creating an image of a wormhole Creating your first image of a wormhole is very easy with a terminal. You need to provide two 360 degree images of your choice and then run curvis image <path_to_background_image_1> <path_to_background_image_2> <path_to_output_folder> This will create an image and put it in the output folder. By default, the output folder is the current working directory, and the corresponding argument can be omitted. Creating a video The command to create a video is similar: curvis video <path_to_background_image_1> <path_to_background_image_2> <path_to_output_folder> This will create a tmp folder within the output folder and will put there the frames for assemblying the video. The current version of curvis is not assemblying the frames in a video, yet. As before, the output folder can be omitted from the arguments; tmp will be created within the working directory. Command Line Interface Run curvis --help for more information on the general syntax of CurVis' command-line-interface. 360 degree images Currently CurVis only supports rectangular images (and not skyboxes). Try to find high resolution images for the best outcome. If you need inspiration for the choice of images, here are some suggestions: NASA's Deep Star Maps European Southern Observatory - 360 Panorama Some EVE online wallpapers also work very nicely! Settings CurVis rendering can be customized by providing various settings files. Settings files have to be .toml files. When these files are not passed, CurVis uses default settings that are found in the /settings/defaults folder within the CurVis package itself. You can use these files as reference for your curstom settings files to be used with CurVis. There are four different settings files that can be passed to CurVis: simulation settings camera settings image / video settings metric settings Simulation Settings Simulation settings specify parameters for the algorithm that calculates the ray propagation in space. Camera Settings Camera settings specify the resolution of the rendered images, the field of view of the camera. Image Settings Active with the curvis image subcommand. You can use these to specify the camera position and orientation in space. Video Settings Active with the curvis video subcommand. There you can specify the frame rate of the video and you can specify where to find a .csv file that describes the camera movement in space. More on this later on. Metric Settings With metric settings, you can decide which space-time is simulated and its parameters. Camera Paths When rendering a video, you need to specify how the camera moves in space-time.
You can do it by creating .csv files that contain this information and then provide them to CurVis through the video settings described above. In the /paths folder you can find two examples. The "path_through.csv" file specifies a path that moves the camera through the wormhole. The "path_orbit.csv" file specifies a camera that orbits the wormhole. Known Issues and Limitations CurVis currently supports only simulates metrics with spherical symmetry (preventing, for instance, the simulation of rotating black holes, that have cylindrical symmetry). The video algorithm does not produce a video but creates only png frames that are saved in a tmp folder. The background image of the negative-l space is flipped. Background images cannot be rotated. Sometimes the video rendering algorithm panics on the last frame. Artefacts are visibile at the boundary of wormholes, especially at lower resolutions. Documentation is very limited; no tutorials. Single-threaded. Wishlist Black holes! Multithreading. Using a single setting files to pass all the arguments.
======>
https://github.com/gschup/ggrs
-->>-->>
Repository files navigation README Code of conduct License Apache-2.0 license MIT license P2P Rollback Networking in Rust GGRS (good game rollback system) is a reimagination of the GGPO network SDK written in 100% safe Rust 🦀 . The callback-style API from the original library has been replaced with a much saner, simpler control flow. Instead of registering callback functions, GGRS returns a list of requests for the user to fulfill. If you are interested in integrating rollback networking into your game or just want to chat with other rollback developers (not limited to Rust), check out the GGPO Developers Discord ! Live Demonstrations GGRS has two demo apps you can try in the browser! One written with macroquad , the other written with bevy . Both use matchbox . Try it out with a friend! Just click the link and match with another player! (You can also open the link in two separate windows to play against yourself) 🚧 MATCHMAKING CURRENTLY OFFLINE! 🚧 Bevy Demo ( Repository ) Macroquad Demo ( Repository ) Projects using GGRS Jumpy Gamercade NES-bundler Girls with Swords ( gameplay footage ) NieR Automata: Online ( Youtube ) Getting Started To get started with GGRS, check out the following resources: Wiki Examples Documentation Development Status GGRS is in an early stage, but the main functionality for multiple players and spectators should be quite stable. See the Changelog for the latest changes, even those yet unreleased on crates.io! If you want to contribute, check out existing issues, as well as the contribution guide! Changelog Issues Contribution Guide Useful Links Bevy Plugin The authors of GGRS are also maintaining a bevy plugin. Check it out: Bevy GGRS WASM support through WebRTC sockets If you are interested to run a GGRS application in your browser, check the amazing Matchbox project!
The matchbox sockets are compatible with GGRS through a feature flag: Matchbox Godot Wrapper Godot is a popular open-source game engine. marcello505 is developing a wrapper for GGRS.
Find the repository here: Godot GGRS Wrapper Other Rollback Implementations in Rust Also take a look at the awesome backroll project, a completely async rollback library. Special thanks to james7132 for a lot of inspiration and fruitful discussion. backroll-rs Licensing GGRS is dual-licensed under either MIT License : Also available online Apache License, Version 2.0 : Also available online at your option.
======>
https://github.com/johanhelsing/matchbox
-->>-->>
Repository files navigation README Apache-2.0 license MIT license Painless peer-to-peer WebRTC networking for rust's native and wasm applications. The goal of the Matchbox project is to enable udp-like, unordered, unreliable p2p connections in web browsers or native to facilitate low-latency multiplayer games. Matchbox supports both unreliable and reliable data channels, with configurable ordering guarantees and variable packet retransmits. Tutorial for usage with Bevy and GGRS The Matchbox project contains: matchbox_socket : A socket abstraction for Wasm or Native, with: ggrs : A feature providing a ggrs compatible socket. matchbox_signaling : A signaling server library, with ready to use examples matchbox_server : A ready to use full-mesh signalling server bevy_matchbox : A matchbox_socket integration for the Bevy game engine bevy bevy_matchbox 0.14 0.10, main 0.13 0.9 0.12 0.8 0.11 0.7 0.10 0.6 < 0.9 Unsupported Examples simple : A simple communication loop using matchbox_socket bevy_ggrs : An example browser game, using bevy and bevy_ggrs Live 2-player demo: https://helsing.studio/box_game/ Live 4-player demo: https://helsing.studio/box_game/?players=4 How it works WebRTC allows direct connections between peers, but in order to establish those connections, some kind of signaling service is needed. matchbox_server is such a service. Once the connections are established, however, data will flow directly between peers, and no traffic will go through the signaling server. The signaling service needs to run somewhere all clients can reach it over http or https connections. In production, this usually means the public internet. When a client wants to join a p2p (mesh) network, it connects to the signaling service. The signaling server then notifies the peers that have already connected about the new peer (sends a NewPeer event). Peers then negotiate a connection through the signaling server. The initiator sends an "offer" and the recipient responds with an "answer." Once peers have enough information relayed, a RTCPeerConnection is established for each peer, which comes with one or more data channels. All of this, however, is hidden from rust application code. All you will need to do on the client side, is: Create a new socket, and give it a signaling server url .await the message loop future that processes new messages. If you are using Bevy , this is done automatically by bevy_matchbox (see the bevy_ggrs example). Otherwise, if you are using WASM, wasm-bindgen-futures can help (see the simple example). Alternatively, the future can be polled manually, i.e. once per frame. You can hook into the lifecycle of your socket through the socket's API, such as connection state changes. Similarly, you can send packets to peers using the socket through a simple, non-blocking method. Showcase Projects using Matchbox: NES Bundler - Transform your NES game into a single executable targeting your favorite OS! Cargo Space (in development) - A coop 2D space game about building and flying a ship together Extreme Bevy - Simple 2-player arcade shooter Matchbox demo A Janitors Nightmare - 2-player jam game Lavagna - collaborative blackboard for online meetings Contributing PRs welcome! If you have questions or suggestions, feel free to make an issue . There's also a Discord channel if you want to get in touch. Thanks A huge thanks to Ernest Wong for his Dango Tribute experiment ! matchbox_socket is heavily inspired its wasm-bindgen server_socket and Matchbox would probably not exist without it. License All code in this repository dual-licensed under either: MIT License or http://opensource.org/licenses/MIT Apache License, Version 2.0 or http://www.apache.org/licenses/LICENSE-2.0 Unless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.
======>
https://bugzmanov.github.io/nes_ebook/
-->>-->>
Light (default) Rust Coal Navy Ayu Writing NES Emulator in Rust document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    }); Why NES? The NES (Nintendo Entertainment System) was one of the most popular gaming platforms throughout the 80s and the 90s. The platform and the emergent ecosystem was and still is a huge cultural phenomenon. The device itself had relatively simple hardware (judging from the modern days), and it's incredible how much was made out of it. This series is about creating an emulator capable of running and playing first-gen NES games, such as: PacMan Donkey Kong Ice Climber Super Mario Bros etc. We would go with incremental updates, with potentially enjoyable milestones, gradually building a fully capable platform. One of the problems with writing an emulator is that you don't get any feedback until the very end when the whole thing is done, and that's no fun. I've tried to break the entire exercise into small pieces with visible and playable goals. After all, it's all about having a good time. Why Rust? Rust is a modern language with modern expression capabilities and impressive performance characteristics. For an overview of the language, I recommend watching "Consider Rust" presentation by Jon Gjengset. The Rust programming language allows us to go as low-level as needed in terms of hardware and memory management, which is a good fit for the problem of hardware simulation. For example, NES has a Central Processing Unit (CPU), and the majority of supported operations are dealing with unsigned 8-bit arithmetic and bit manipulation. Rust provides excellent capabilities for working with signed and unsigned numbers of different sizes without any overhead. In addition, the Rust ecosystem offers a plethora of libraries that make working on bit-level data as convenient as it gets. The goal is to play NES games on the hardware that we have, meaning we have to simulate NES hardware. The process of simulation alone means that we are introducing significant performance overhead in comparison to running native applications.
By choosing rust, we hope to get some additional performance budget for our needs. NES hardware specs are pretty modest by today's standards. For example, the NES CPU is about 3000 times slower than modern CPUs. Emulating that in any language should not be a problem. Some folks were able to get playable performance on an emulator written in Python. But it is still nice to have extra power for free. Prerequisites I expect the reader to have basic knowledge of the Rust language and understanding primary language constructs and platform capabilities. I'll introduce some features as we go, but others have to be learned elsewhere. It's also assumed that the reader has a basic understanding of bit arithmetic, boolean logic, and how binary and hexadecimal numbering systems work. Again, NES is a relatively simple platform, and the NES CPU instructions set is small and straightforward, but some basic understanding of computer systems is required. References Nesdev Wiki - nothing would be possible without it. The one-stop-shop. Nintendo Entertainment System Documentation - a short tutorial that covers pretty much everything about NES Nintendo Age Nerdy Nights - a series to help people write games for the NES I.Am.Error - a book full of histories of the Nintendo Entertainment System platform The Elements of Computing Systems - everything you need to know about computer systems, how to build Tetris starting from logic gates. Created by @bugzmanov , 2020 Special thanks to Spencer Burris and Kirill Gusakov for reviews, edits and helpfull suggestions!
======>
https://www.reddit.com/r/elixir/comments/1gp34om/language_philosophies_for_distant_hardware/
-->>-->>
Go to elixir r/elixir r/elixir Subreddit for the Elixir programming language, a dynamic, functional language designed for building scalable and maintainable applications. Learn more at https://elixir-lang.org. 33K Members 18 Online • 3 hr. ago dave_mays ADMIN MOD Language Philosophies for Distant Hardware? I'm curious if you were writing software for hardware you will not be able to access again physically once deployed, would Rust's philosophy of getting the program correct at the beginning and it should work forever be most reliable, or would it be best to subscribe to Elixir / BEAM VM language philosophy that there will be errors, but let it crash and provide a means to recover be most reliable? Something like a Mars rover or an ocean liner. Not sure if the Nerves Project is a better place to post this, but the reddit page seemed to recommend posting things here instead. Crosspost: https://www.reddit.com/r/rust/comments/1gp320c/language_philosophies_for_distant_hardware/ Read more Skip • Promoted Don’t get lost in the sauce. Sign up for Skip+ and get $0 delivery fee, bonus Points, exclusive offers and rewards from Canada’s favourite brands! Sign Up skipthedishes.com Add a Comment Sort by: Best Open comment sort options Best Top New Controversial Old Q&A No_Dot_4711 • 3h ago • Edited 2h ago • Well, you don't lose connection to Mars rovers like that, in fact the furthests debugging session has been at a distance of about 150 million miles thanks to Lisp's REPL https://thenewstack.io/nasa-programmer-remembers-debugging-lisp-in-deep-space/ But yes, assuming you are in a situation that you absolutely cannot patch the system, then rust's approach will let you sleep a lot more soundly, however, you can't just use standard rust type saftey, you need to actually make the runtime resilient against other forms of hardware degradation that can create errors that aren't part of the type system Reply reply dave_mays • 2h ago • Oh right, your hardware will most likely start physically failing as well. Reply reply More replies Top 4% Rank by size Public Anyone can view, post, and comment to this community More posts you may like r/elixir r/elixir Subreddit for the Elixir programming language, a dynamic, functional language designed for building scalable and maintainable applications. Learn more at https://elixir-lang.org. 33K Members 18 Online New Open-Source UI Kit for Phoenix LiveView: Introducing Mishka Chelekom with 80+ Components 116 upvotes · 26 comments r/learnprogramming r/learnprogramming A subreddit for all questions related to programming in any language. 4.1M Members 228 Online Travis Oliphant (founder of Anaconda) provides some tips on becoming a great programmer. Short and really useful 272 upvotes · 25 comments r/elixir r/elixir Subreddit for the Elixir programming language, a dynamic, functional language designed for building scalable and maintainable applications. Learn more at https://elixir-lang.org. 33K Members 18 Online Oban Web to be free and open source 103 upvotes · 13 comments Promoted r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Build a System Monitor TUI (Terminal UI) in Go , my learning journey with BubbleTea 119 upvotes · 3 comments r/htmx r/htmx High power tools for HTML 14K Members 13 Online We built our frontend with HTMX, here are some thoughts 100 upvotes · 51 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Would you use Golang for small projects ? 89 upvotes · 57 comments r/ProgrammerHumor r/ProgrammerHumor For anything funny related to programming and software development. 4M Members 909 Online Write in C youtube 432 upvotes · 46 comments r/ProgrammerHumor r/ProgrammerHumor For anything funny related to programming and software development. 4M Members 909 Online Saw this on twitter and figured it belonged here 442 upvotes · 40 comments Promoted r/lisp r/lisp A subreddit for the Lisp family of programming languages. 40K Members 20 Online Discussion of the new generation of Clojure-inspired Lisps. 80 upvotes · 38 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Go Constants: Beyond Basics 108 upvotes · 20 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online FAQ: What Is A Good Project To Learn Go With? 132 upvotes · 54 comments r/ProgrammingLanguages r/ProgrammingLanguages This subreddit is dedicated to the theory, design and implementation of programming languages. 103K Members 42 Online LAMBDA: The ultimate Excel worksheet function microsoft 120 upvotes · 37 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online goship.it is now open source 163 upvotes · 20 comments r/htmx r/htmx High power tools for HTML 14K Members 13 Online HTMX has complete changed how I approach frontend 102 upvotes · 33 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Go 1.23.3 is released 152 upvotes · 11 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online What is Context in GoLang ?? 164 upvotes · 33 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online What libraries are you missing from go? 96 upvotes · 189 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Golang Aha! Moments: Object Oriented Programming 197 upvotes · 59 comments r/elixir r/elixir Subreddit for the Elixir programming language, a dynamic, functional language designed for building scalable and maintainable applications. Learn more at https://elixir-lang.org. 33K Members 18 Online Jose Valim - What's new in Elixir 1.18 youtu 106 upvotes · 13 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online FAQ: What are the best books for Go? 127 upvotes · 26 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online 🔍 Analyzing 10 Million Domains with Go – 27.6% of the Internet is “Dead” 🌐 267 upvotes · 72 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Constraints in Go bitfieldconsulting 124 upvotes · 4 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Is there a path forward for Go's yaml situation? 114 upvotes · 68 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online Are you using feature flags? Have you tried GO Feature Flag? 150 upvotes · 39 comments r/golang r/golang Ask questions and post articles about the Go programming language and related tools, events etc. 282K Members 75 Online With what portfolio projects did you land your first Golang job? 99 upvotes · 40 comments Go to elixir r/elixir r/elixir Subreddit for the Elixir programming language, a dynamic, functional language designed for building scalable and maintainable applications. Learn more at https://elixir-lang.org. 33K Members 18 Online • 3 hr. ago dave_mays ADMIN MOD Language Philosophies for Distant Hardware? I'm curious if you were writing software for hardware you will not be able to access again physically once deployed, would Rust's philosophy of getting the program correct at the beginning and it should work forever be most reliable, or would it be best to subscribe to Elixir / BEAM VM language philosophy that there will be errors, but let it crash and provide a means to recover be most reliable? Something like a Mars rover or an ocean liner. Not sure if the Nerves Project is a better place to post this, but the reddit page seemed to recommend posting things here instead. Crosspost: https://www.reddit.com/r/rust/comments/1gp320c/language_philosophies_for_distant_hardware/ Read more Skip • Promoted Don’t get lost in the sauce. Sign up for Skip+ and get $0 delivery fee, bonus Points, exclusive offers and rewards from Canada’s favourite brands! Sign Up skipthedishes.com Add a Comment Sort by: Best Open comment sort options Best Top New Controversial Old Q&A No_Dot_4711 • 3h ago • Edited 2h ago • Well, you don't lose connection to Mars rovers like that, in fact the furthests debugging session has been at a distance of about 150 million miles thanks to Lisp's REPL https://thenewstack.io/nasa-programmer-remembers-debugging-lisp-in-deep-space/ But yes, assuming you are in a situation that you absolutely cannot patch the system, then rust's approach will let you sleep a lot more soundly, however, you can't just use standard rust type saftey, you need to actually make the runtime resilient against other forms of hardware degradation that can create errors that aren't part of the type system Reply reply dave_mays • 2h ago • Oh right, your hardware will most likely start physically failing as well. Reply reply More replies
======>
https://docs.google.com/forms/d/e/1FAIpQLSdamzdbUi3EIGBrmEw0-Na4myXP0088kvxVmVT4YU-1BEiyCg/viewform
-->>-->>
Event Sponsorship: If your company is interested in supporting this conference, please do not hesitate to connect us with the right contact. Your answer Event Sponsorship: If your company is interested in supporting this conference, please do not hesitate to connect us with the right contact.
======>
https://www.rustinparis.com/
-->>-->>
From Paris with Love Crafting Code with Rust Diversity We place a high emphasis on diversity, recognizing it as a vital component of innovation and community growth. We are committed to creating an inclusive environment where voices from various backgrounds are heard and valued. ‍ Join us as we celebrate diversity and work together to shape a diverse future for Rust programming. Leadership Our speakers are among the best in the field, they will provide thought-provoking insights and practical guidance on how to code with Rust. ‍ Those experts can only be an example to lead us all to more inspiration, innovation and hard work. friendship Networking and relationship building are at the heart of the conference mission. ‍ We will have ample opportunities to engage with fellow developers, share experiences, and exchange ideas during dedicated networking sessions and informal gatherings. By building friendships we can enhance our learning, discover new opportunities, and contribute to the vibrant Rust ecosystem. APPLY FOR A TALK Early crab
======>
https://www.graphics.rwth-aachen.de/software/openmesh/
-->>-->>
• OpenMesh 11.0 released (Update) This release adds some improvements and fixes some bugs. Note: We updated the artifacts on the server as they were defect. We added a simple hole filler algorithm (Migrated from OpenFlipper to OpenMesh) The OBJ reader/writer got some improvements to increase precision. add_vertex and new_vertex now take arguments by value to avoid crashes when the underlying vectors are resized while copying positions from the mesh itself. As usual the full change log is available on our website: Changelog May 14, 2024 • OpenMesh 10.0 released This release adds some improvements and fixes several bugs. We added edge-halfedge, edge-vertex, and edge-face circulators. The build system got some cleanup to improve speed. Several bugs have been fixed in the readers and writers. Furthermore the previous halfedges are now optional again. As usual the full change log is available on our website: Changelog Nov. 14, 2023 • OpenMesh Python Bindings Updated 1.2.1 We updated our OpenMesh Python Bindings to version 1.2.1. The release is available via PyPi . The new version is build with Python 3.9 and available for Linux, Mac(Arm64 and x86_64), and Windows. As we updated pybind, we require at least Python 3.6. March 8, 2022 • OpenMesh 9.0 released This release adds several improvements. We added predicates that can be used as smart range filters. The Smart handles now give read access to status fields. And we have CW/CCW ranges now. The build system got some updates and we can now build the example apps with qt6. There are some breaking changes. We dropped support for VS2015 and the tests on 32-bit architectures. OpenMesh might still compile but we don't test this anymore. We added test builds for the M1 based Apple computers. As usual the full change log is available on our website: Changelog Jan. 18, 2022 • OpenMesh 8.1 released This release introduces Smart Handles. Smart Handles know their corresponding mesh and can be used to simplify access to navigation methods ( e.g. mesh->next_halfedge_handle(HH) can be written as handle.next()). You can find further details in the smart handles section under tutorials in the Documentation. There are also new convenience functions to simplify calculations (e.g. summing up all neighbors,...) Double support in OM and PLY Reader/Writer has been improved. Some bugs were also fixed in this release along with improvements to the build system. As usual the full change log is available on our website: Changelog April 23, 2020 • OpenMesh 8.0 released This release now relies on compilers supporting C++11 or higher. Therefore Visual Studio 2013 is no longer supported. The major upgrade in this release is the integration of an Eigen3 wrapper providing a direct replacement of the integrated vector type (Vec3d/Vec4d). You can now use Eigen3 vectors 
as the basic data type inside OpenMesh. We also improved several readers and writers. Furthermore the new SmartTagger class has been added which can be used to tag primitives in the mesh while providing an O(1) reset of the tagging. Next to this, we removed the glut requirement from the apps. As usual the full change log is available on our website: Changelog Feb. 21, 2019
======>
https://github.com/ranjeethmahankali/alum/
-->>-->>
Repository files navigation README GPL-3.0 license Alum: A Halfedge based Polygon Mesh Library This library is inspired by OpenMesh , hence has an
API very similar to that of OpenMesh. I love using OpenMesh in C++, and wrote
this library because I couldn't find an equivalent in Rust. Huge thanks to
OpenMesh and it's maintainers for the inspiration! For now, the features of this library exist to serve my other projects. It has
near parity with the OpenMesh/Core module, and new features will be added as
required by my other projects. Installation This can be added to a Rust project as a dependency from crates.io with: cargo add alum Or by adding the following to your Cargo.toml : [ dependencies ] alum = " 0.1.1 " Usage and Features This library uses glam out of the box
for geometric types such as points, normals etc. These are enabled by the use_glam feature and can be disabled if you don't want to use glam . You can use this library with your own geometric types for points and normals
etc. by implementing an adaptor that tells this library how to work with your
geometric types. Read the documentation to
learn more about this. This library also comes with a property system just like the one in OpenMesh ,
with some small improvements and differences. The properties are always
synchronized with the mesh elements, through additions, deletions and garbage
collections which result in reordering of elements. Unlike properties in OpenMesh , the properties here use interior mutability with RefCell<T> and
enforce runtime borrow checking rules. Read the documentation to learn more.

======>
https://github.com/DioCrafts/flusso
-->>-->>
Repository files navigation README MIT license 🚀 Flusso - Secure, High-Performance Kubernetes Ingress Controller in Rust 🦀🔒 Flusso is a powerful, secure, and high-performance Ingress Controller for Kubernetes, written in Rust. Tailored for modern cloud-native environments, Flusso offers a lightweight alternative to popular ingress solutions. Table of Contents Features Installation Configuration Usage Kubernetes Setup Contributing License Contact & Support Features ✨ Lightweight and Fast ⚡: Built in Rust 🦀 for high performance and low memory and CPU consumption. Advanced Load Balancing 🔄: Supports custom load balancing algorithms for optimized traffic distribution. Secure by Design 🔒: Implements modern TLS protocols with Rustls for enhanced security. Dynamic Backends 🔄: Automatically updates routing based on Kubernetes service changes. Flexible Configuration 🛠️: Easily configurable via YAML files or environment variables. Minimal Dependencies 📦: Avoids unnecessary dependencies for lightweight container images. Installation To get started with Flusso, you can use Docker or Helm to deploy the Ingress Controller in your Kubernetes cluster. Docker Installation Pull the Docker image: docker pull diocrafts/flusso-ingress-controller:latest Run the Docker container: docker run -p 8080:8080 -p 8081:8081 -e SERVER_ADDR= " 0.0.0.0:8080 " -e TLS_ENABLED= " true " diocrafts/flusso-ingress-controller Kubernetes Installation with Helm Add your Helm repository (if not added yet): helm repo add flusso-repo https://your-helm-repo.com/charts Install Flusso Ingress Controller: helm install flusso-ingress flusso-repo/flusso-ingress For more configuration options, refer to the values.yaml . Configuration Flusso supports several configuration options, both via environment variables and Helm chart values. SERVER_ADDR : Define the address where the Ingress Controller will listen. Default is 0.0.0.0:8080 . TLS_ENABLED : Enable or disable TLS (default is true ). TLS_CERT_PATH / TLS_KEY_PATH : Paths to TLS certificate and key files. Usage Flusso automatically routes incoming traffic to Kubernetes services defined by Ingress resources. Monitoring Flusso exposes a web GUI at http://<controller-ip>:8081 with insights into backends and routing. Kubernetes Setup Flusso is designed for seamless integration in Kubernetes. Prerequisites Kubernetes version 1.19 or higher Helm version 3 or higher Contributing We welcome contributions to make Flusso even better! If you have suggestions for improvements, open a GitHub issue or submit a pull request. Please refer to our Contributing Guide for more details. License Flusso is licensed under the MIT License . Contact & Support GitHub : GitHub Repository Docker Hub : Docker Hub Repository For further support, reach out via GitHub issues or visit our community forums.
======>
https://github.com/ash2228/rust-portscanner
-->>-->>
Repository files navigation README Rust Port Scanner A simple and efficient multithreaded port scanner written in Rust. This tool allows you to scan a specified host for open and closed server ports. Features Multithreaded Scanning : Utilizes all available CPU cores to maximize performance and speed during the scanning process. Concurrency : Leveraging the tokio runtime for asynchronous networking operations. User-Friendly CLI : Built with clap for easy command-line argument parsing. Requirements Rust (with Cargo) Tokio (async runtime) Clap (command-line argument parser) Num CPUs (to utilize available CPU cores) Installation To build and run this project, ensure you have Rust installed, then clone this repository: git clone https://github.com/ash2228/rust-portscanner.git cd rust-portscanner
cargo build --release
./target/release/port_scanner < host >
======>
https://old.reddit.com/r/rust/comments/1go844r/a_rust_raytracer_on_curved_spacetimes/
-->>-->>
Hello Everyone!   

   I have created a raytracer in Rust for visualizing images of wormholes based on General Relativity.   

   It's based on the work of    O. James et al (2015)   , it's open source, available on GitHub (   here   ), and it takes a few minutes to render your first images/videos!   

   The video attached here was generated using my code and gorgeous 360 wallpaper images from EVE online.   

   I am currently refining the code and expanding the documentation. Then next steps will be to implement multitasking and add black holes and neutron stars.   

   I needed a project to start learning Rust, and this was my choice. Let's just say the impact with Rust has been interesting, but also quite rewarding. Of course, any advice on how to improve the code would be very welcome!   

   Hope you enjoy!   

   EDIT: The video does not show up (video uploads are forbidden?). I uploaded an image, instead.   

   https://preview.redd.it/lgbsfw2ti40e1.png?width=3840&format=png&auto=webp&s=4f3273df5e5bc7f4338db64e986ec2c7b26a06a5   
   

======>
https://old.reddit.com/r/rust/comments/1gp0fid/working_on_an_nes_emulator_what_are_some_ways_in/
-->>-->>
Hi! I am taking a college course on learning Rust by designing a complete project by the end of the term. I wanted to build an emulator for the NES using    this tutorial   , but to put my own spin on it, I decided to enable two player online multiplayer for it. I am currently at one of the final sections (on the joypads), which will be crucial for this.   

   Multiplayer probably involves p2p connections, sockets and servers which I have 0 experience with. I found some tools which could be really useful, like    Matchbox    and    GGRS   , but as a complete beginner I don't understand how to use them.   

   I'd love to know if there are  any resources I could turn to, which would help me come up with even a very basic implementation for this feature. Any advice or help is also appreciated.   
   

======>
https://rust-analyzer.github.io/thisweek/2024/11/11/changelog-259.html
-->>-->>
Internal Improvements #18493 (first contribution) update supported debug engines in configuration. #18486 change minimum VS Code version from 1.78 to 1.83.
======>
https://old.reddit.com/r/rust/comments/1gp320c/language_philosophies_for_distant_hardware/
-->>-->>
I'm curious if you were writing software for hardware you will not be able to access again physically once deployed, would Rust's philosophy of getting the program correct at the beginning and it should work forever be most reliable, or would it be best to subscribe to Elixir / BEAM VM language philosophy that there will be errors, but let it crash and provide a means to recover be most reliable?   

   Something like a Mars rover or an ocean liner.   

   Crosspost:   
   https://www.reddit.com/r/elixir/comments/1gp34om/language_philosophies_for_distant_hardware/   
   

======>
https://old.reddit.com/r/rust/comments/1goqpaj/rust_in_paris_conference_on_the_14_of_march_2025/
-->>-->>
The first edition of the Rust in Paris conference will be on the 14 of March 2025 (in Paris, but I think this part is obvious). More information on the website:    https://www.rustinparis.com/   

   If you're interested into giving a talk, the CfP link is here:    https://docs.google.com/forms/d/e/1FAIpQLSdamzdbUi3EIGBrmEw0-Na4myXP0088kvxVmVT4YU-1BEiyCg/viewform   
   

======>
https://github.com/rust-lang/rust/pull/132833
-->>-->>
rust-lang / rust Public Notifications You must be signed in to change notification settings Fork 12.7k Star 98.4k Code Issues 5k+ Pull requests 644 Actions Projects 7 Security 5 Insights Additional navigation options Code Issues Pull requests Actions Projects Security Insights New issue Have a question about this project? Sign up for a free GitHub account to open an issue and contact its maintainers and the community. Sign up for GitHub By clicking “Sign up for GitHub”, you agree to our terms of service and privacy statement . We’ll occasionally send you account related emails. Already on GitHub? Sign in to your account Jump to bottom Stabilize let chains in the 2024 edition #132833 Open est31 wants to merge 2 commits into rust-lang : master base: master Choose a base branch Branches Tags Could not load branches Branch not found: {{ refName }} Loading {{ refName }} default Could not load tags Nothing to show {{ refName }} default Loading Are you sure you want to change the base? Some commits from the old base branch may be removed from the timeline,
            and old review comments may become outdated. Loading Change base from est31 : stabilize_let_chains {"props":{"processingIndicatorUrl":"/rust-lang/rust/pull/132833/partials/processing_indicator","repositoryId":724712,"pullRequestId":2171618450}} {"resolvedServerColorMode":"day"} Open Stabilize let chains in the 2024 edition #132833 est31 wants to merge 2 commits into rust-lang : master from est31 : stabilize_let_chains +42 −20 Conversation 7 Commits 2 Checks 6 Files changed 10 Conversation This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters Show hidden characters Copy link Member est31 commented Nov 10, 2024 • edited Loading Stabilization report This proposes the stabilization of let_chains ( tracking issue , RFC 2497 ) in the 2024 edition of Rust. What is being stabilized The ability to && -chain let statements inside if and while is being stabilized, allowing intermixture with boolean expressions. The patterns inside the let sub-expressions can be irrefutable or refutable. struct FnCall < ' a > { fn_name : & ' a str , args : Vec < i32 > , } fn is_legal_ident ( s : & str ) -> bool { s . chars ( ) . all ( |c| ( 'a' ..= 'z' ) . contains ( & c ) || ( 'A' ..= 'Z' ) . contains ( & c ) ) } impl < ' a > FnCall < ' a > { fn parse ( s : & ' a str ) -> Option < Self > { if let Some ( ( fn_name , after_name ) ) = s . split_once ( "(" ) && !fn_name . is_empty ( ) && is_legal_ident ( fn_name ) && let Some ( ( args_str , "" ) ) = after_name . rsplit_once ( ")" ) { let args = args_str . split ( ',' ) . map ( |arg| arg . parse ( ) ) . collect :: < Result < Vec < _ > , _ > > ( ) ; args . ok ( ) . map ( |args| FnCall { fn_name , args } ) } else { None } } fn exec ( & self ) -> Option < i32 > { let iter = self . args . iter ( ) . copied ( ) ; match self . fn_name { "sum" => Some ( iter . sum ( ) ) , "max" => iter . max ( ) , "min" => iter . min ( ) , _ => None , } } } fn main ( ) { println ! ( "{:?}" , FnCall ::parse ( "sum(1,2,3)" ) .unwrap ( ) .exec ( ) ) ; println ! ( "{:?}" , FnCall ::parse ( "max(4,5)" ) .unwrap ( ) .exec ( ) ) ; } The feature will only be stabilized for the 2024 edition and future editions. Users of past editions will get an error with a hint to update the edition. Why 2024 edition? Rust generally tries to ship new features to all editions. So even the oldest editions receive the newest features. However, sometimes a feature requires a breaking change so much that offering the feature without the breaking change makes no sense. This occurs rarely, but has happened in the 2018 edition already with async and await syntax. It required an edition boundary in order for async / await to become keywords, and the entire feature foots on those keywords. In the instance of let chains, the issue is the drop order of if let chains. If we want if let chains to be compatible with if let , drop order makes it hard for us to generate correct MIR . It would be strange to have different behaviour for if let ... {} and if true && let ... {} . So it's better to stay consistent with if let . In edition 2024, drop order changes have been introduced to make if let temporaries be lived more shortly. These changes also affected if let chains. These changes make sense even if you don't take the if let chains MIR generation problem into account. But if we want to use them as the solution to the MIR generation problem, we need to restrict let chains to edition 2024 and beyond: for let chains, it's not just a change towards more sensible behaviour, but one required for correct function. Introduction considerations As edition 2024 is very new, and the compiler doesn't use it yet, most usages in the compiler need to still use #![feature(let_chains)] : this stabilization PR only makes it possible to use let chains on 2024 without that feature gate, it doesn't mark that feature gate as stable/removed. I would propose to continue offering the let_chains feature (behind a feature gate) for a limited time (maybe 3 months after stabilization?) on older editions to allow nightly users to adopt edition 2024 at their own pace. After that, the feature gate shall be marked as stabilized , not removed, and replaced by an error on editions 2021 and below. Implementation history History from before March 14, 2022 can be found in the original stabilization PR that was reverted. Stabilize let_chains in Rust 1.64 #94927 Extend the irrefutable_let_patterns lint to let chains #94951 Ensure that let_else does not interact with let_chains #94974 [ let_chains ] Forbid let inside parentheses #95008 [rustc_parse] Forbid let s in certain places #97295 Fix last let_chains blocker #98633 Remove let-chain close brace check. #99731 Fix unwind drop glue for if-then scopes #102394 Add tests for the drop behavior of some control flow constructs #100526 Revert let_chains stabilization #100538 Drop temporaries created in a condition, even if it's a let chain #102998 Detect incorrect chaining of if and if let conditions and recover #103405 Remove drop order twist of && and || and make them associative #103293 Rescope temp lifetime in if-let into IfElse with migration lint #107251 docs(style): add let-chain style rules #110568 Improve invalid let expression handling #115677 Suggest removing ; for ; within let-chains #117743 Catch stray { in let-chains #117770 Suggest let or == on typo'd let-chain #118191 Fix scoping for let chains in match guards #119554 Don't lint irrefutable_let_patterns on leading patterns if else if let-chains #129394 Additional tests to ensure let is rejected during parsing #132828 Add let_chains references reference#1179 Revert let chains reference docs reference#1251 Support let-chains rustfmt#5910 Adoption history In the compiler History before March 14, 2024 can be found in the original stabilization PR . fix confusing let chain indentation in rustc_resolve #115983 Simplify some mir passes by using let chains #116549 Format all the let-chains in compiler crates #116688 Outside of the compiler Replace if_chain with let chains rust-clippy#11750 rspack risingwave dylint convex-backend tikv Daft greptimedb Tests Intentional restrictions partially-macro-expanded.rs , macro-expanded.rs : it is possible to use macros to expand to both the pattern and the expression inside a let chain, but not to the entire let pat = expr operand. parens.rs : if (let pat = expr) is not allowed in chains ensure-that-let-else-does-not-interact-with-let-chains.rs : let...else doesn't support chaining. Overlap with match guards move-guard-if-let-chain.rs : test for the use moved value error working well in match guards. could maybe be extended with let chains that have more than one let shadowing.rs : shadowing in if let guards works as expected ast-validate-guards.rs : let chains in match guards require the match guards feature gate Simple cases from the early days PR #88642 has added some tests with very simple usages of let else , mostly as regression tests to early bugs. then-else-blocks.rs ast-lowering-does-not-wrap-let-chains.rs issue-90722.rs issue-92145.rs Drop order/MIR scoping tests issue-100276.rs : let expressions on RHS aren't terminating scopes drop_order.rs : exhaustive temporary drop order test for various Rust constructs, including let chains scope.rs : match guard scoping test drop-scope.rs : another match guard scoping test, ensuring that temporaries in if-let guards live for the arm drop_order_if_let_rescope.rs : if let rescoping on edition 2024, including chains mir_let_chains_drop_order.rs : comprehensive drop order test for let chains, distinguishes editions 2021 and 2024. issue-99938.rs , issue-99852.rs both bad MIR ICEs fixed by #102394 Linting irrefutable-lets.rs : trailing and leading irrefutable let patterns get linted for, others don't. The lint is turned off for else if . issue-121070-let-range.rs : regression test for false positive of the unused parens lint, precedence requires the () s here Parser: intentional restrictions disallowed-positions.rs : let in expression context is rejected everywhere except at the top level invalid-let-in-a-valid-let-context.rs : nested let is not allowed (let's are no legal expressions just because they are allowed in if and while ). Parser: recovery issue-103381.rs : Graceful recovery of incorrect chaining of if and if let semi-in-let-chain.rs : Ensure that stray ; s in let chains give nice errors ( if_chain! users might be accustomed to ; s) deli-ident-issue-1.rs , brace-in-let-chain.rs : Ensure that stray unclosed { s in let chains give nice errors and hints Misc conflicting_bindings.rs : the conflicting bindings check also works in let chains. Personally, I'd extend it to chains with multiple let's as well. let-chains-attr.rs : attributes work on let chains Tangential tests with #![feature(let_chains)] if-let.rs : MC/DC coverage tests for let chains logical_or_in_conditional.rs : not really about let chains, more about dropping/scoping behaviour of || stringify.rs : exhaustive test of the stringify macro expanded-interpolation.rs , expanded-exhaustive.rs : Exhaustive test of -Zunpretty diverges-not.rs : Never type, mostly tangential to let chains Possible future work There is proposals to allow if let Pat(bindings) = expr {} to be written as if expr is Pat(bindings) {} ( RFC 3573 ). if let chains are a natural extension of the already existing if let syntax, and I'd argue orthogonal towards is syntax. Consensus check: let -chains and is are not mutually exclusive lang-team#297 One could have similar chaining inside let ... else statements. There is no proposed RFC for this however, nor is it implemented on nightly. Match guards have the if keyword as well, but on stable Rust, they don't support let . The functionality is available via an unstable feature ( if_let_guard tracking issue ). Stabilization of let chains affects this feature in so far as match guards containing let chains now only need the if_let_guard feature gate be present instead of also the let_chains feature. Open questions / blockers bad recovery if you don't put a let (I don't think this is a blocker): #117977 An instance where a temporary lives shorter than with nested ifs, breaking compilation: #103476 . Personally I don't think this is a blocker either, as it's an edge case. One should probably extend the tests for move-guard-if-let-chain.rs and conflicting_bindings.rs to have chains with multiple let's. Parsing rejection tests: addressed by Additional tests to ensure let is rejected during parsing #132828 Formatting : nightly rustfmt can format let chains already more than a year ago. However, the PR to add the respective policy document has not been merged. Non-terminals, e.g. expr, have diverged between parser and macro matcher #86730 explicitly mentions let_else . I think we can live with let pat = expr not evaluating as expr for macro_rules macros, especially given that let pat = expr is not a legal expression anywhere except inside if and while . Documentation in the reference. There has been an original reference PR during the first attempt to stabilize let chains, but it got reverted. One would need to revive it. Add chapter to the Rust 2024 edition guide . Sorry, something went wrong. 55 compiler-errors, jhpratt, MolotovCherry, MrCroxx, jieyouxu, dmyTRUEk, Kobzol, trevyn, cyrgani, Conaclos, and 45 more reacted with thumbs up emoji 90 thaliaarchi, jhpratt, rami3l, ChayimFriedman2, FineFindus, MrCroxx, kxxt, pickx, slanterns, dmyTRUEk, and 80 more reacted with hooray emoji 60 Expurple, kxxt, rodrimati1992, jmviz, bjoernager, dmyTRUEk, Kobzol, trevyn, marziply, graemer957, and 50 more reacted with heart emoji All reactions 55 reactions 90 reactions 60 reactions est31 added
  the F-let_chains `#![feature(let_chains)]` label Nov 10, 2024 rustbot added
  the needs-triage This issue may need triage. Remove it if it has been sufficiently triaged. label Nov 10, 2024 est31 mentioned this pull request Nov 10, 2024 Tracking issue for eRFC 2497, "if- and while-let-chains, take 2" #53667 Open 15 tasks jieyouxu added T-lang Relevant to the language team, which will review and decide on the PR/issue. C-tracking-issue Category: A tracking issue for an RFC or an unstable feature. A-edition-2024 Area: The 2024 edition and removed needs-triage This issue may need triage. Remove it if it has been sufficiently triaged. labels Nov 10, 2024 Copy link Contributor traviscross commented Nov 10, 2024 • edited Loading Process-wise, we normally do the FCP on the stabilization PR, and I think that'd make the most sense here.  Let us know if you need us on lang to weigh in on anything specifically, e.g. any of the open questions, to make such a stabilization PR possible. cc @rust-lang/lang for visibility. And cc @rust-lang/style given the open item on the style guide. @rustbot labels +I-style-nominated Putting on the edition hat, since this would be an edition item in some sense, we should talk about this in our next edition call. @rustbot labels +I-edition-nominated All reactions Sorry, something went wrong. rustbot added I-style-nominated Nominated for discussion during a style team meeting. I-edition-nominated Nominated for discussion during an edition team meeting. labels Nov 10, 2024 rustbot assigned fee1-dead Nov 10, 2024 Copy link Collaborator rustbot commented Nov 10, 2024 r? @fee1-dead rustbot has assigned @fee1-dead . They will have a look at your PR within the next two weeks and either review your PR or reassign to another reviewer. Use r? to explicitly pick a reviewer All reactions Sorry, something went wrong. rustbot added
  the S-waiting-on-review Status: Awaiting review from the assignee but also interested parties. label Nov 10, 2024 est31 removed
  the C-tracking-issue Category: A tracking issue for an RFC or an unstable feature. label Nov 10, 2024 Copy link Member Author est31 commented Nov 10, 2024 Process-wise, we normally do the FCP on the stabilization PR, and I think that'd make the most sense here. @traviscross understood, I've converted it to a pull request using the gh cli. Thanks for cc'ing the relevant teams. 2 Kobzol and jieyouxu reacted with eyes emoji All reactions 2 reactions Sorry, something went wrong. Copy link Contributor traviscross commented Nov 10, 2024 Beautiful, thanks.  Let's nominate this for lang discussion too then. @rustbot labels +I-lang-nominated All reactions Sorry, something went wrong. rustbot added
  the I-lang-nominated Nominated for discussion during a lang team meeting. label Nov 10, 2024 This comment has been minimized. Sign in to view est31 added 2 commits November 11, 2024 02:01 Stabilize let chains on edition 2024 83b9ce5 Remove let_chains feature gate from some places in the testsuite Loading Loading status checks… ee7488a est31 force-pushed the stabilize_let_chains branch
    from 79e1519 to ee7488a Compare November 11, 2024 01:02 compiler-errors assigned compiler-errors and unassigned fee1-dead Nov 11, 2024 fee1-dead requested changes Nov 11, 2024 View reviewed changes compiler/rustc_parse/src/parser/expr.rs Comment on lines +2611 to +2613 if !expr . span . at_least_rust_2024 ( ) { return ; } Copy link Member fee1-dead Nov 11, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment I'd like to see some tests on this behavior where a nested expression does not get ungated, perhaps from a macro in edition 2024 where arguments are in edition 2021: macro_rules! test { ( $ ( $tt : tt ) * ) => { if $ ( $tt ) * { println! ( "meow" ) } } ; } fn main ( ) { test ! ( let None = None ::< ( ) > && let None = None ::< ( ) > ) ; } Sorry, something went wrong. All reactions compiler/rustc_parse/src/parser/expr.rs @@ -2595,7 +2596,7 @@ impl<'a> Parser<'a> { } /// Parses the condition of a `if` or `while` expression. fn parse_expr_cond ( & mut self ) -> PResult < ' a , P < Expr > > { fn parse_expr_cond ( & mut self , edition : Edition ) -> PResult < ' a , P < Expr > > { Copy link Member fee1-dead Nov 11, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Should document which span this edition parameter is attached to. Sorry, something went wrong. All reactions fee1-dead self-assigned this Nov 11, 2024 compiler-errors added
  the S-waiting-on-fcp Status: PR is in FCP and is awaiting for FCP to complete. label Nov 11, 2024 compiler-errors removed their assignment Nov 11, 2024 Sign up for free to join this conversation on GitHub .
    Already have an account? Sign in to comment Reviewers fee1-dead fee1-dead requested changes Assignees fee1-dead Labels A-edition-2024 Area: The 2024 edition F-let_chains `#![feature(let_chains)]` I-edition-nominated Nominated for discussion during an edition team meeting. I-lang-nominated Nominated for discussion during a lang team meeting. I-style-nominated Nominated for discussion during a style team meeting. S-waiting-on-fcp Status: PR is in FCP and is awaiting for FCP to complete. S-waiting-on-review Status: Awaiting review from the assignee but also interested parties. T-lang Relevant to the language team, which will review and decide on the PR/issue. Projects None yet Milestone No milestone Development Successfully merging this pull request may close these issues. 7 participants Add this suggestion to a batch that can be applied as a single commit. This suggestion is invalid because no changes were made to the code. Suggestions cannot be applied while the pull request is closed. Suggestions cannot be applied while viewing a subset of changes. Only one suggestion per line can be applied in a batch. Add this suggestion to a batch that can be applied as a single commit. Applying suggestions on deleted lines is not supported. You must change the existing code in this line in order to create a valid suggestion. Outdated suggestions cannot be applied. This suggestion has been applied or marked resolved. Suggestions cannot be applied from pending reviews. Suggestions cannot be applied on multi-line comments. Suggestions cannot be applied while the pull request is queued to merge. Suggestion cannot be applied right now. Please check back later.
======>
https://old.reddit.com/r/rust/comments/1gp5ccx/alum_new_halfedge_polygon_mesh_library/
-->>-->>
https://preview.redd.it/vj2zwh5vpc0e1.png?width=700&format=png&auto=webp&s=fec322887073503e9f18b73a9f426ccbfdc8c4ad   

   Crate:    https://crates.io/crates/alum   

   Git:    https://github.com/ranjeethmahankali/alum/   

   Docs:    https://docs.rs/alum/latest/alum/   

   I am a heavy user of    OpenMesh    in C++. I've been trying to write some mesh stuff in Rust but couldn't find something like OpenMesh in Rust. I did find    hedge    and a port of    OpenMesh    but they both appeared to be incomplete and abandoned. So I finally gave in and wrote one myself. This is still kind of a work in progress, and I am only adding features as I need them for my other mesh related projects. But I felt like the library reached a point of being generally useful. It has near full parity with the    OpenMesh/Core    module. So I decided to publish it and share it here.   
   

======>
https://old.reddit.com/r/rust/comments/1gp5fwd/best_creative_coding_crates/
-->>-->>
See title. I love Nannou, but it hasn’t had an update in years. I also love Bevy, but when learning math and physics concepts, the ability to    quickly    throw together a simulation with dynamic plots and visuals (think 2Blue1Brown) is paramount. Bevy’s ECS provides a level of abstraction that ever so slightly slows down my creative flow. What are your favorite crates for creative coding?   
   

======>
https://davjcosby.github.io/all-published/miscellaneous-tech/Introducing%20Sled,%20a%20Rust%20Library%20for%20Creating%20Spatial%20LED%20Strip%20Lighting%20Effects.html
-->>-->>
Set Colors By Distance To set all LEDs 2 Units away from the center to red: sled . set_at_dist ( 2.0 , Rgb :: new ( 1.0 , 0.0 , 0.0 ) ) ; // or relative to any other point using: sled . set_at_dist_from ( DISTANCE , POSITION , COLOR ) Under the hood, the Sled is just performing an intersection test between each line segment and a circle formed by the radius. It then colors the LEDs at each point of intersection. Similar method like set_at_angle(angle, color) or set_at_dir(direction, color) , work by running a simple intersection test between line segments and a ray.
======>
https://old.reddit.com/r/rust/comments/1gouxoc/buffi_generate_ergonomic_c_apis_for_your_rust_code/
-->>-->>
Hey everyone! We have just released the first version of BuFFI, a tool to generate ergonomic (and safe!) C++ APIs to call your Rust code from C++.   

   https://crates.io/crates/buffi   

   The name is a combination of "buffer" and "FFI", because one of the core concepts is to replace every type in the C-API with byte buffers. This allows us to simplify the "extern C" functions on the Rust side as well as the functions on the C++ side. I recently gave presentations at EuroRust and RustLab explaining our work and I've included some slides here:   

   https://github.com/GiGainfosystems/BuFFI/blob/main/knowledge/RustLab2024.pdf   

   At my workplace this has allowed us to remove hundreds of lines of boilerplate and has eliminated many sources of possible memory leaks or erroneous pointer handling. You can simply add a macro to your pure Rust API and after calling the BuFFI function to generate the necessary code, you are already good to go. A basic example is included as well.   

   Since this is the first release of BuFFI, some things are still a WIP. Make sure to check out the README file to learn more about these points. We are also working on more examples, e.g. for async functions (check the slides to see how async functions are handled!).   

   The current release supports the 1.82.0 toolchain (check the README for an explanation why this is the current situation) and going forward, every time a new stable version of Rust is released, we will try to release a new version of BuFFI to stay compatible. Make sure to grab the right version for you!   

   We do expect some incompatibilities eventually as other projects give this a go, but we are optimistic that most cases can be quickly figured out together, so make sure to open an issue if you run into any problems.   
   

======>
https://old.reddit.com/r/rust/comments/1gp10sh/i_have_launched_an_opensource_k8s_ingress/
-->>-->>
Hi team   

   i was working this last months building a ingress controller from scratch built in Rust. I’m seeking feedback from the community to make it the most reliable, secure, and efficient ingress solution possible, and I’d be incredibly grateful if you could give it a try and let me know your thoughts.   

   Why do it?   
I built this ingress to address some of the limitations I’ve encountered in other popular ingress controllers (named flusso):   

   
   Enhanced Security   : Rust’s memory safety eliminates common vulnerabilities (like buffer overflows), making flusso a robust choice for security-focused deployments.   
   Resource Efficiency   : Rust’s performance allows flusso to maintain high throughput without excessive CPU or memory consumption, especially under heavy loads.   
   Improved TLS Management   : Automates certificate handling and provides easy setup for multi-domain configurations, minimizing downtime risks.   
   Simplified Configuration   : flusso’s configuration is designed to be straightforward, with a GUI that displays backend services, status indicators, TLS info, host names, and ports at a glance.   
   Flexible Observability   : Built-in support for detailed metrics and structured logs compatible with Prometheus and Grafana, making monitoring and debugging easier.   
   

   What I’d love feedback on   :   

   
   Dashboard   : Is the GUI intuitive? Are the service details (status, TLS info, host, ports) helpful?   
   Performance   : How does flusso perform in your environment compared to other ingress controllers? Any bottlenecks?   
   Configuration & Setup   : Was the setup process straightforward? Are there configurations that could be clearer or easier?   
   Suggestions for Features   : Are there additional features you’d like to see or any compatibility issues with your tech stack?   
   

   How to Get Started   :   
flusso is available on GitHub    https://github.com/DioCrafts/flusso   . The current version is 0.0.1, so your feedback will help shape its roadmap and future improvements. I am just starting with the project, and i am working on it as hobbie in my free time.   

   If you’re interested in testing or have any thoughts on how to improve flusso, please leave a comment or DM me! All feedback, both positive and constructive, is welcome as it’ll help me refine flusso to meet real-world needs.   

   Thanks in advance, and I can’t wait to hear what the devops community thinks!   
   

======>
https://youtu.be/8-KLX1PGg8Q?si=rqkSm2fHVafnF-cO
-->>-->>
Through the Fire and the Flames - Jon Gjengset | EuroRust 2024 341 Likes 6,631 Views Nov 1 2024 Why does my thing need to be Send, and why isn’t it? 
Why does this function have ten lines of where clauses; what are they all for? 
What do you mean foo doesn’t live long enough? 
Why is this async code just using a single CPU core? 
These are questions most of us have muttered under our breath after too much time staring at a screen of Rust code that we just can’t quite get right. Maybe we do some searching or blindly move things around and manage to find our way around our particular issue, but lo’ and behold another very similar one crops up a short time later. These kinds of recurring stumbling blocks make us doubt ourselves, hate the language, and ultimately limit our ability to actually getting things done!

The reality is that Rust is a language with some inherent complexity (and associated features) that isn’t present in many other common languages. And these questions, and others like them, tend to stem from a lack knowledge of the underlying principles and mechanisms. Often, even a surface-level understanding of these deeper concepts will allow you to self-diagnose or entirely avoid 80% of the challenging cases. About Jon Gjengset 🦀
Jon is a Principal Engineer at Helsing and the author of Rust for Rustaceans. Before that, he owned the internal Rust build infrastructure at AWS. He is passionate about teaching (Rust and otherwise) and has published Rust live-coding and educational videos since 2018. He also co-hosts the podcast Rustacean Station. Jon started with Rust in 2015 when he built what eventually became his PhD thesis at MIT — a fast SQL database built from scratch in Rust. Outside of the world of programming, Jon is a Storyteller for the social deception game Blood on the Clocktower, and otherwise mostly sits around waiting for the next Rust conference.

-------------------- EuroRust 2024 – the yearly 2 day conference for the European Rust community ➡️ https://eurorust.eu EuroRust is organized by Mainmatter, experts in Rust and distributed systems ➡️ https://mainmatter.com/rust/ Show less ...more Why does my thing need to be Send, and why isn’t it? 
Why does this function have ten lines of where clauses; what are they all for? 
What do you mean foo doesn’t live long enough? 
Why is this async code just using a single CPU core? 
These are questions most of us have muttered under our breath after too much time staring at a screen of Rust code that we just can’t quite get right. Maybe we do some searching or blindly move things around and manage to find our way around our particular issue, but lo’ and behold another very similar one crops up a short time later. These kinds of recurring stumbling blocks make us doubt ourselves, hate the language, and ultimately limit our ability to actually getting things done!

The reality is that Rust is a language with some inherent complexity (and associated features) that isn’t present in many other common languages. And these questions, and others like them, tend to stem from a lack knowledge of the underlying principles and mechanisms. Often, even a surface-level understanding of these deeper concepts will allow you to self-diagnose or entirely avoid 80% of the challenging cases. About Jon Gjengset 🦀
Jon is a Principal Engineer at Helsing and the author of Rust for Rustaceans. Before that, he owned the internal Rust build infrastructure at AWS. He is passionate about teaching (Rust and otherwise) and has published Rust live-coding and educational videos since 2018. He also co-hosts the podcast Rustacean Station. Jon started with Rust in 2015 when he built what eventually became his PhD thesis at MIT — a fast SQL database built from scratch in Rust. Outside of the world of programming, Jon is a Storyteller for the social deception game Blood on the Clocktower, and otherwise mostly sits around waiting for the next Rust conference.

-------------------- EuroRust 2024 – the yearly 2 day conference for the European Rust community ➡️ https://eurorust.eu EuroRust is organized by Mainmatter, experts in Rust and distributed systems ➡️ https://mainmatter.com/rust/ … ...more ...more Show less Chapters View all Music 1 songs Music Transcript Follow along using the transcript. Show transcript EuroRust 2.01K subscribers Videos About Videos About Twitter
