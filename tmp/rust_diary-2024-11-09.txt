https://medium.com/cimb-niaga-engineering/delivering-superior-banking-experiences-bc7ca491eae5
-->>-->>
Delivering Superior Banking Experiences How our customer-centric approach led us to Rust Gilang Kusuma Jati · Follow Published in CIMB Niaga Engineering · 7 min read · Oct 29, 2024 264 6 Listen Share The Digital Tribe engineering team at CIMB Niaga In today’s digital age, customer expectations in the banking sector have never been higher. Every tap, swipe, or click must deliver a seamless, fast, and secure experience. At CIMB Niaga, we understand that our users’ trust is paramount — and that trust is built on technology that works flawlessly. The values of customer-centricity that we hold drive everything we do, especially when it comes to optimizing the systems behind our mobile and internet banking services, OCTO Mobile and OCTO Clicks. Recently, our digital team undertook a significant initiative to migrate our critical microservices from Java to Rust, which is already paying dividends in speed, security, and scalability. This wasn’t just a technical upgrade — it was a step towards ensuring our customers enjoy the best possible experience. Putting Customers First in Every Decision For us, customer-centricity means ensuring that every interaction with our digital services is smooth, secure, and reliable. As our user base grew and banking demands evolved, we saw performance limitations in some of our Java microservices. Latency issues and increased memory usage were beginning to affect user experience during payday periods, and we knew we needed a solution that would scale with our customers’ needs. We had a clear goal: Improve system performance while maintaining the trust and security our customers expect. After careful evaluation, we determined that migrating our core microservices to Rust would give us the best opportunity to deliver on these objectives. Why we chose Rust When it comes to modern backend languages, both Rust and Go are well-regarded. However, for the high-performance requirements of our banking services, Rust emerged as the clear winner. Here’s our reasoning: Memory safety without compromise Rust’s standout and well-known feature is its memory safety model, which ensures that common bugs like NullPointerException and memory leaks are eliminated at compile time. This gives us confidence that our microservices are running error-free in production without the unpredictability of runtime issues. In comparison, Go uses garbage collection to manage memory, which can introduce periodic pauses during service execution. Even the slightest delay in transaction processing can lead to a poor user experience in banking. Rust’s model allows for smoother, uninterrupted performance, directly translating to faster customer response times. Performance that scales with our customers’ needs Rust’s low-level control over system resources allows us to optimize our microservices for performance. This is particularly important for mobile and internet banking, where users expect instant access to their OCTO’s MyAccount page & details, free & fast online transfers, e-wallet & e-money top-ups, and real-time notifications. Rust’s ability to handle concurrent operations with minimal overhead ensures that our system can handle increased transaction volumes without slowing down. Go is known for its ease of use and effective concurrency model through goroutines, but Rust gave us more control over fine-tuning the performance of our microservice. For an application where milliseconds matter like ours, we chose the precision of Rust to ensure our services remain fast, no matter the scale. Security that puts customers first Being part of a highly regulated organization, security is non-negotiable. Every feature we build is designed with customer safety in mind, and Rust’s strict safety guarantees align perfectly with this ethos. Rust minimizes the risk of exploitable bugs in production by catching potential security vulnerabilities — like race conditions and buffer overflows — before the code even runs. ❤️ While Go also offers safety, Rust’s more profound focus on compile-time guarantees gave us the peace of mind we needed to build secure, reliable microservices that protect sensitive customer data. For our team, Rust’s safety-first approach was a natural extension of our commitment to delivering secure banking services. Our Migration Journey: A Seamless Transition for Customers Migrating our core microservice is no small feat, especially when customer impact is a top priority. We knew that any downtime or disruption could affect the trust our users place in us. Therefore, we planned the migration meticulously to ensure zero disruption to customer services. Phased rollout for zero downtime Rather than a sudden switch, we adopted a phased rollout strategy, deploying the Rust microservice in parallel with its existing Java counterpart. This approach allowed us to monitor performance under real-world conditions closely, ensuring that the new service was not only faster but also more resilient under high loads. Customer-focused testing As we prepared for the full migration, our engineering team ran extensive tests designed to replicate actual customer behaviors — such as transferring funds during peak hours on payday periods or checking balances simultaneously across multiple accounts. The new Rust service passed every test with flying colors, delivering the improvements we aimed for without sacrificing the reliability and trust our users depend on. Learning and growing together as a team Migrating from Java to Rust also meant learning new tools and techniques. While many of our engineers were familiar with Java, Rust was a newer language for some. However, our commitment to customer-centricity makes learning part of our team culture — we provided knowledge sharing, hands-on training, and peer mentoring to ensure that every engineer was empowered to contribute to the migration’s success and speed up the learning process. Yes, we acknowledge that Rust has a steep learning curve. The Results: A Faster, More Secure Banking Experience Since migrating the microservice from Java to Rust, the performance improvements have been immediate and measurable: Faster start-up time : The Rust service has significantly reduced start-up time. Our internal authentication service’ startup time decreased from ~31.9 seconds in our Java service to less than 1 second in Rust service, which is 31 times faster , enabling us to scale up services quickly and handle unexpected surges in user demand more efficiently. Reduced CPU and Memory usage : Rust’s efficient use of system resources has led to lower CPU and memory usage. Utilization in our internal authentication service was reduced from 3 cores and 3.8 GB in Java service to 0.25 cores and 8 MB in Rust service, which is 12 times less CPU and 486 times more memory efficient . This optimization means our services run leaner, helping us support a more extensive user base while keeping operating costs low. Enhanced security : Rust’s safety guarantees have reduced the risk of potential vulnerabilities in our system, reinforcing our customers’ trust in us for managing their financial data. CPU usage: Java service vs Rust service, 12 times less CPU Memory usage comparison, 486 times more memory efficient A Tech-Savvy Team Dedicated to Customer-Centric Solutions At the heart of this migration is our digital team — a group of talented engineers and delivery managers who are passionate about delivering the best possible banking experience. Our regular knowledge sharing session at CIMB Niaga Dear team, keep innovating with the customer in mind , always looking for ways to improve service performance, reliability, and security. Keep committed to building a platform that’s as responsive to our customers as it is to the evolving world of technology. Looking Forward: Building for the Future This migration is just the beginning. As we continue to scale and enhance our mobile and internet banking platforms, we’re confident that Rust will play a key role in helping us meet future challenges. With a customer-centric mindset, we’ll keep pushing the boundaries of what’s possible, ensuring that our users always enjoy the best that modern banking has to offer. At CIMB Niaga, we’re committed to putting customers at the center of everything we do. By migrating our services to Rust, we’re building faster, more secure digital banking experiences that our users can rely on every day. Join Us: Internships with Mentorship from Industry Leaders Are you a student passionate about technology and interested in working on projects that make a real difference? CIMB Niaga is now looking for driven, enthusiastic students for our 1-year internship program. As an intern, you’ll gain hands-on experience, and you’ll be mentored by Solution Architects who are experts in creating reliable, scalable, and maintainable ecosystems. This is a unique opportunity to learn and grow within a forward-looking digital team, working on impactful projects that help shape the future of banking. Our internship program is a chance to be part of a team that values innovation, creativity, and collaboration. Apply now to start your journey with CIMB Niaga and develop the skills that will set you apart in the tech industry. Secure your internship opportunity and working closely with our Solution Architects at CIMB Niaga Thank you Thanks a lot, Pak Jeff, Pak Bob, and Bu Lusi, for your continuous support in everything we do to grow our OCTO Mobile and OCTO Clicks. Your leadership is reflected in every line of code we write and every solution we deliver to our customers.

======>
https://www.reddit.com/r/rust/comments/1g7wu5b/good_optimization_libraries/?utm_source=share&utm_medium=web3x&utm_name=web3xcss&utm_term=1&utm_content=share_button
-->>-->>
Go to rust r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online • 21 days ago __leopardus__ ADMIN MOD Good optimization libraries? Hello, Rustaceans! I have developed a machine-learning library named miniboosts , which uses an optimization library internally. So far, I've been using Gurobi for free since I was a student. Now, I graduated from university, so I no longer use it for free. The question is, are there any libraries that can solve constrained linear/quadratic programs? Read more AudibleCA • Promoted Buckle up for one helluva roadtrip Learn More audible.ca Add a Comment Sort by: Best Open comment sort options Best Top New Controversial Old Q&A map_or • 20d ago • https://crates.io/crates/clarabel Reply reply __leopardus__ • 20d ago • Thank you for suggesting a nice library to me! It seems like what I was looking for. I'll try it while I wait for other suggestions. Reply reply More replies _jbu • 20d ago • OSQP is great for QPs and has (unofficial) Rust bindings. If you're looking for a solver natively written in Rust, Clarabel is a great option as mentioned by @map_or. For linear (and integer) programs, there is HiGHS , which is the best open source MILP solver currently available as per the Mittelman benchmarks. (EDIT: HiGHS apparently supports solving QPs as well.) Reply reply simplyh • 20d ago • Can you talk a little about what kinds of problems you are solving (i.e. MILP/MIP, QP, SDPs, etc.)? That might help us understand what you need. There's some work at https://github.com/rust-or , including safe Rust bindings to HiGHs, a relatively new and high quality solver we use successfully. I do not know if it is competitive yet with Gurobi on your problems, but it might be. Most of the tools you'll find will be Rust bindings to a library written in C/C++. Reply reply __leopardus__ • 20d ago • I want to solve linear programming and quadratic programming with linear constraints. The crate you suggested to me seems excellent for the LP; thank you! I hope to handle LP and QP in the same crate. Reply reply 2 more replies 2 more replies More replies More replies dandxy89 • 20d ago • Take a look at good_lp and its associated crates Reply reply stefano25 • 20d ago • If you are familiar with genetic algorithms, you could try https://crates.io/crates/optirustic Reply reply Top 1% Rank by size Public Anyone can view, post, and comment to this community More posts you may like r/2007scape r/2007scape The community for Old School RuneScape discussion on Reddit.

Join us for game discussions, tips and tricks, and all things OSRS!
OSRS is the official legacy version of RuneScape, the largest free-to-play MMORPG. 1.1M Members 905 Online NPC True Tile ID Lookup: Huey Wave Attack 1 upvote · 3 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Are there any open source projects that need someone with a math background? 57 upvotes · 21 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Convex Optimizations in Rust 19 upvotes · 13 comments Promoted r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Help wanted for diff.rs (and new design) 99 upvotes · 7 comments r/residentevil r/residentevil A community for fans of the Capcom series, Resident Evil, (aka Biohazard in Japan). 719K Members 169 Online Well, i guess they really do track everything... 112 upvotes · 51 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Announcing Clarabel : interior point solver for convex optimization 32 upvotes · 16 comments r/elderscrollsonline r/elderscrollsonline A Reddit community dedicated to The Elder Scrolls Online, an MMO developed by Zenimax Online. 453K Members 127 Online When the Crown Store Bugs and You Get to Control Pets 0:10 722 upvotes · 23 comments r/silenthill r/silenthill Official Silent Hill Subreddit: Discussions, Memes, News, Art and more! Enter at your own risk… best to stay clear of the fog. 206K Members 157 Online SPOILER Sh2 remake observation (spoiler) 1 upvote · 1 comment Promoted r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online How do you remember built-in functions ? 92 upvotes · 128 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Announcing Statement 113 upvotes · 23 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Gosub - An open source browser engine written in Rust 296 upvotes · 27 comments r/runescape r/runescape A subreddit dedicated to the MMORPG RuneScape. Join us! 359K Members 316 Online Menaphos, City of Puns imgur 235 upvotes · 34 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Mathematical functions in the standard library are non-deterministic? 248 upvotes · 155 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Rust Search Extension v2.0 has been released 131 upvotes · 9 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online 4x speed-up by switching from regex to Nom for parsing 114 upvotes · 23 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online jeprofl: A low-overhead allocation profiler using eBPF 166 upvotes · 7 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Rust to .NET compiler update - f128, f16, and beginnings of SIMD and async 344 upvotes · 7 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Announcing Typst 0.12 | A new markup-based typesetting system 592 upvotes · 42 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Managing libs for C++ is just painful... should I switch to rust? 162 upvotes · 150 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Should I stick to Rust? 142 upvotes · 82 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online When does Rust fail to track alignment? 104 upvotes · 19 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Looking for a maintainer for memmap2-rs 195 upvotes · 21 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Rust support in KDE 170 upvotes · 31 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online Announcing mlua v0.10 138 upvotes · 15 comments r/rust r/rust A place for all things related to the Rust programming language—an open-source systems language that emphasizes performance, reliability, and productivity. 319K Members 195 Online UPDATE: Use Type-State pattern without the ugly code (state-shift) 172 upvotes · 23 comments Related discussions Best Optimization Mod Minecraft Best Image Optimization Plugin WordPress

======>
https://github.com/rmitsuboshi/miniboosts
-->>-->>
Repository files navigation README MIT license Documentation MiniBoosts is a library for boosting algorithm researchers. What is Boosting ? Boosting is a repeated game between a Booster and a Weak Learner . For each round of the game, The Booster chooses a distribution over training examples, Then the Weak Learner chooses a hypothesis (function)
whose accuracy w.r.t. the distribution is
slightly better than random guessing. After sufficient rounds, the Booster outputs a hypothesis
that performs significantly better on training examples. How to use this library Write the following in your cargo.toml. [ dependencies ] minibosts = { version = " 0.3.5 " } All boosting algorithms are implemented without Gurobi .
but, if you have a Gurobi license,
you can use the Gurobi version of the algorithms by setting: [ dependencies ] minibosts = { version = " 0.3.5 " , features = [ " gurobi " ] } Caution Since I am no longer a student, I cannot check whether the compilation succeeded with the "gurobi" flag. Currently, following boosting algorithms are available: BOOSTER FEATURE FLAG AdaBoost by Freund and Schapire, 1997 MadaBoost by Domingo and Watanabe, 2000 GBM (Gradient Boosting Machine) by Jerome H. Friedman, 2001 LPBoost by Demiriz, Bennett, and Shawe-Taylor, 2002 gurobi SmoothBoost by Servedio, 2003 AdaBoostV by Rätsch and Warmuth, 2005 TotalBoost by Warmuth, Liao, and Rätsch, 2006 gurobi SoftBoost by Warmuth, Glocer, and Rätsch, 2007 gurobi ERLPBoost by Warmuth and Glocer, and Vishwanathan, 2008 gurobi CERLPBoost (Corrective ERLPBoost) by Shalev-Shwartz and Singer, 2010 gurobi MLPBoost by Mitsuboshi, Hatano, and Takimoto, 2022 gurobi GraphSepBoost (Graph Separation Boosting) by Alon, Gonen, Hazan, and Moran, 2023 If you invent a new boosting algorithm,
you can introduce it by implementing Booster trait.
See cargo doc -F gurobi --open for details. WEAK LEARNER Decision Tree Regression Tree A worst-case weak learner for LPBoost Gaussian Naive Bayes Neural Network (Experimental) Why MiniBoosts ? If you write a paper about boosting algorithms,
you need to compare your algorithm against others.
At this point, some issues arise. Some boosting algorithms,
such as LightGBM or XGBoost ,
are implemented and available for free.
These are very easy to use in Python3 but hard to compare to other algorithms
since they are implemented in C++ internally.
Implementing your algorithm in Python3
makes the running time comparison unfair
(Python3 is significantly slow compared to C++).
However, implementing it in C++ is extremely hard (based on my experience). Most boosting algorithms are designed
for a decision-tree weak learner
even though the boosting protocol does not demand. There is no implementation for margin optimization boosting algorithms.
Margin optimization is a better goal than empirical risk minimization
in binary classification. MiniBoosts is a crate to address the above issues. This crate provides the followings. Two main traits, named Booster and WeakLearner. If you invent a new Boosting algorithm,
all you need is to implement Booster. If you invent a new Weak Learning algorithm,
all you need is to implement WeakLearner. Some famous boosting algorithms,
including AdaBoost , LPBoost , ERLPBoost , etc. Some weak learners, including Decision-Tree, Regression-Tree, etc. MiniBoosts for reasearch Sometimes, one wants to log each step of boosting procedure.
You can use Logger struct to output log to .csv file,
while printing the status like this: See Research feature section for detail. Examples Documentation Write the following to Cargo.toml . miniboosts = { version = " 0.3.5 " } If you want to use gurobi features, enable the flag: miniboosts = { version = " 0.3.5 " , features = [ " gurobi " ] } Here is a sample code: use miniboosts :: prelude :: * ; fn main ( ) { // Set file name let file = "/path/to/input/data.csv" ; // Read the CSV file // The column named `class` corresponds to the labels (targets). let sample = SampleReader :: new ( ) . file ( file ) . has_header ( true ) . target_feature ( "class" ) . read ( ) . unwrap ( ) ; // Set tolerance parameter as `0.01`. let tol : f64 = 0.01 ; // Initialize Booster let mut booster = AdaBoost :: init ( & sample ) . tolerance ( tol ) ; // Set the tolerance parameter. // Construct `DecisionTree` Weak Learner from `DecisionTreeBuilder`. let weak_learner = DecisionTreeBuilder :: new ( & sample ) . max_depth ( 3 ) // Specify the max depth (default is 2) . criterion ( Criterion :: Twoing ) // Choose the split rule. . build ( ) ; // Build `DecisionTree`. // Run the boosting algorithm // Each booster returns a combined hypothesis. let f = booster . run ( & weak_learner ) ; // Get the batch prediction for all examples in `data`. let predictions = f . predict_all ( & sample ) ; // You can predict the `i`th instance. let i = 0_usize ; let prediction = f . predict ( & sample , i ) ; // You can convert the hypothesis `f` to `String`. let s = serde_json :: to_string ( & f ) ; } If you use boosting for soft margin optimization,
initialize booster like this: let n_sample = sample . shape ( ) . 0 ; // Get the number of training examples let nu = n_sample as f64 * 0.2 ; // Set the upper-bound of the number of outliers. let lpboost = LPBoost :: init ( & sample ) . tolerance ( tol ) . nu ( nu ) ; // Set a capping parameter. Note that the capping parameter must satisfies 1 <= nu && nu <= n_sample . Research feature This crate can output a CSV file for such values in each step. Here is an example: use miniboosts :: prelude :: * ; use miniboosts :: { Logger , LoggerBuilder , SoftMarginObjective , } ; // Define a loss function fn zero_one_loss < H > ( sample : & Sample , f : & H ) -> f64 where H : Classifier { let n_sample = sample . shape ( ) . 0 as f64 ; let target = sample . target ( ) ; f . predict_all ( sample ) . into_iter ( ) . zip ( target . into_iter ( ) ) . map ( | ( fx , & y ) | if fx != y as i64 { 1.0 } else { 0.0 } ) . sum :: < f64 > ( ) / n_sample } fn main ( ) { // Read the training data let path = "/path/to/train/data.csv" ; let train = SampleReader :: new ( ) . file ( path ) . has_header ( true ) . target_feature ( "class" ) . read ( ) . unwrap ( ) ; // Set some parameters used later. let n_sample = train . shape ( ) . 0 as f64 ; let nu = 0.01 * n_sample ; // Read the test data let path = "/path/to/test/data.csv" ; let test = SampleReader :: new ( ) . file ( path ) . has_header ( true ) . target_feature ( "class" ) . read ( ) . unwrap ( ) ; let booster = LPBoost :: init ( & train ) . tolerance ( 0.01 ) . nu ( nu ) ; let weak_learner = DecisionTreeBuilder :: new ( & train ) . max_depth ( 2 ) . criterion ( Criterion :: Entropy ) . build ( ) ; // Set the objective function. // One can use your own function by implementing ObjectiveFunction trait. let objective = SoftMarginObjective :: new ( nu ) ; let mut logger = LoggerBuilder :: new ( ) . booster ( booster ) . weak_learner ( tree ) . train_sample ( & train ) . test_sample ( & test ) . objective_function ( objective ) . loss_function ( zero_one_loss ) . time_limit_as_secs ( 120 ) // Terminate after 120 seconds . print_every ( 10 ) // Print log every 10 rounds. . build ( ) ; // Each line of `lpboost.csv` contains the following four information: // Objective value, Train loss, Test loss, Time per iteration // The returned value `f` is the combined hypothesis. let f = logger . run ( "logfile.csv" ) . expect ( "Failed to logging" ) ; } Others Currently, this crate mainly supports
boosting algorithms for binary classification. Some boosting algorithms use Gurobi optimizer ,
so you must acquire a license to use this library.
If you have the license, you can use these boosting algorithms (boosters)
by specifying features = ["gurobi"] in Cargo.toml .
The compilation fails
if you try to use the gurobi feature without a Gurobi license. One can log your algorithm by implementing Research trait. Run cargo doc -F gurobi --open to see more information. GraphSepBoost only supports the aggregation rule
shown in Lemma 4.2 of their paper. Future work Boosters AnyBoost SparsiBoost LogitBoost AdaBoost.L Branching Program Weak Learners Bag of words TF-IDF RBF-Net
======>
https://github.com/evgenyigumnov/cblt
-->>-->>
Repository files navigation README MIT license СBLT Safe and fast minimalistic web server, written in Rust, that serves files from a directory and proxies requests to another server. Project Name Explanation The name Cblt appears to be a good shortened version of Cobalt . It retains the association with the element and strength, while also looking modern and minimalist. Features KDL Document Language configuration (Cbltfile) Proxy requests to another server Serve files from a directory TLS support Quick Start You can run Cblt with Cargo or Docker. Cargo cargo run --release Docker docker run -d -p 80:80 -p 443:443 --restart unless-stopped --name ievkz/cblt cblt Test curl -H "Host: example.com"  http://127.0.0.1/
curl --insecure https:/127.0.0.1/
curl -X POST http://127.0.0.1/api/entry \
-H "User-Agent: curl/7.68.0" \
-H "Accept: */*" \
-H "Content-Type: application/json" \
-d '{"key":"value"}' "Cbltfile" configuration examples File server "*:80" {
    root "*" "/path/to/folder"
    file_server
} File server & Proxy "127.0.0.1:8080" {
    reverse_proxy "/test-api/*" "http://10.8.0.3:80"
    root "*" "/path/to/folder"
    file_server
} TLS support ( docs ) "example.com" {
    root "*" "/path/to/folder"
    file_server
    tls "/path/to/your/domain.crt" "/path/to/your/domain.key"
} Benchmark Do test with Apache Benchmark (ab) for 300 requests with 100 concurrent connections. Download 5mb image from example.com/logo_huge.png ab -c 100 -n 300 http://example.com/logo_huge.png Percent Cblt Nginx Caddy 50% 1956 1941 1768 75% 2101 2065 1849 100% 2711 2360 2270 Cblt igumn@lenovo MINGW64 ~ /cblt (main)
$ docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS                 PORTS                                                       NAMES
0589d8f26d91   cblt:0.0.1 " ./cblt " 2 minutes ago   Up 2 minutes           0.0.0.0:80- > 80/tcp                                          cblt

igumn@lenovo MINGW64 ~ /cblt (main)
$ ab -c 100 -n 300 http://example.com/logo_huge.png
This is ApacheBench, Version 2.3 < $Revision : 1913912 $ > Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking example.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Finished 300 requests


Server Software:
Server Hostname:        example.com
Server Port:            80

Document Path:          /logo_huge.png
Document Length:        5122441 bytes

Concurrency Level:      100
Time taken for tests:   6.020 seconds
Complete requests:      300
Failed requests:        0
Total transferred:      1536745500 bytes
HTML transferred:       1536732300 bytes
Requests per second:    49.83 [ # /sec] (mean) Time per request:       2006.721 [ms] (mean)
Time per request:       20.067 [ms] (mean, across all concurrent requests)
Transfer rate:          249283.62 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       2
Processing:  1293 1926 262.3   1956    2711
Waiting:        1  118 139.1     63     645
Total:       1293 1926 262.3   1956    2711

Percentage of the requests served within a certain time (ms)
  50%   1956
  66%   2027
  75%   2101
  80%   2127
  90%   2213
  95%   2394
  98%   2544
  99%   2597
 100%   2711 (longest request) Nginx igumn@lenovo MINGW64 ~ /cblt/benchmark/nginx (main)
$ docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS                  PORTS                                                       NAMES
37fbf1dac42b   nginx_srv " /docker-entrypoint.… " 2 minutes ago   Up 2 minutes            0.0.0.0:80- > 80/tcp                                          nginx_srv

igumn@lenovo MINGW64 ~ /cblt/benchmark/nginx (main)
$ ab -c 100 -n 300 http://example.com/logo_huge.png
This is ApacheBench, Version 2.3 < $Revision : 1913912 $ > Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking example.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Finished 300 requests


Server Software:        nginx/1.27.2
Server Hostname:        example.com
Server Port:            80

Document Path:          /logo_huge.png
Document Length:        5122441 bytes

Concurrency Level:      100
Time taken for tests:   6.043 seconds
Complete requests:      300
Failed requests:        0
Total transferred:      1536804300 bytes
HTML transferred:       1536732300 bytes
Requests per second:    49.65 [ # /sec] (mean) Time per request:       2014.267 [ms] (mean)
Time per request:       20.143 [ms] (mean, across all concurrent requests)
Transfer rate:          248359.28 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       2
Processing:  1387 1940 168.4   1941    2360
Waiting:        1  115  84.5     98     301
Total:       1387 1940 168.4   1941    2360

Percentage of the requests served within a certain time (ms)
  50%   1941
  66%   2024
  75%   2065
  80%   2088
  90%   2152
  95%   2201
  98%   2263
  99%   2317
 100%   2360 (longest request) Caddy igumn@lenovo MINGW64 ~ /cblt (main)
$ ab -c 100 -n 300 http://example.com/logo_huge.png
This is ApacheBench, Version 2.3 < $Revision : 1913912 $ > Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/
Licensed to The Apache Software Foundation, http://www.apache.org/

Benchmarking example.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Finished 300 requests


Server Software:        Caddy
Server Hostname:        example.com
Server Port:            80

Document Path:          /logo_huge.png
Document Length:        5122441 bytes

Concurrency Level:      100
Time taken for tests:   5.440 seconds
Complete requests:      300
Failed requests:        0
Total transferred:      1536804000 bytes
HTML transferred:       1536732300 bytes
Requests per second:    55.14 [ # /sec] (mean) Time per request:       1813.469 [ms] (mean)
Time per request:       18.135 [ms] (mean, across all concurrent requests)
Transfer rate:          275858.99 [Kbytes/sec] received

Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       2
Processing:  1264 1749 191.1   1767    2270
Waiting:        1   96 104.7     67     467
Total:       1265 1749 191.1   1768    2270

Percentage of the requests served within a certain time (ms)
  50%   1768
  66%   1821
  75%   1849
  80%   1877
  90%   1955
  95%   2152
  98%   2226
  99%   2241
 100%   2270 (longest request)
======>
http://www.zeustech.net/
-->>-->>
שינויים פוליטיים ב2024 Posted on מאי 21, 2024 יוני 2, 2024 by זינה פנייה של מדינת ישראל השתנו החל משבעה באוקטובר, אז אירעה מתקפת טרור רצחנית של מחבלי חמאס שרצחו, חטפו ואנסו בתושבי הדרום ובבאי מסיבת ה"נובה". לאור כל אלו בחלק רחב מהציבור הופנתה ביקורת לא קטנה באשר לתפקודה של הממשלה לפני תחילת מלחמת חרבות ברזל וגם לאחר שנפתחה המלחמה. כך או כך ממשלת ישראל תצטרך לעבוד קשה גם מבחינה אלקטוראלית וגם מבחינה מעשית, על מנת שאמון הציבור יחזור אליהם. ימין ממלכתי והלאה השינויים הפוליטיים בשנת 2024 במדינת ישראל, כוללים לא מעט תזוזות לא רק משמאל אלא גם מימין. בפינה הממלכתית נמצאים בני גנץ, איזנקוט ועד לא מזמן גם חבר הכנסת גדעון סער https://newhope.org.il/ , כאשר השלושה חברו אל ממשלת הימין שמונה נכון לימים אלו 64 מנדטים. השלושה חברו על מנת להעניק מנדט רחב יותר לממשלה בזמן המלחמה, אך הדבר הוביל להיפרדות של גדעון סער שהוביל את תקווה חדשה מהסיעה של בני גנץ "כחול לבן". ההיפרדות של השניים הובילה ליציאה של גדעון סער מהקבינט המצומצם, אך גם לערעור של מה שנקרא בפי רבים, הימין הממלכתי. כמעט מאותו הצד בדיוק עומדת לה ממשלת ימין, המורכבת מעוצמה יהודית, הליכוד והסיעות החרדיות. למרות ההבטחות של רבים מהם להובילה בטוח של ממשלת ימין, מצטברות עוד ועוד ביקורות בנוגע לתפקוד של הממשלה אשר נחשבת לימין ביותר מזה שנים. אחת הביקורות שהושמעו הייתה על שתיקה רועמת של מפלגת הציונות הדתית בכל הקשור למתווה הגיוס, כאשר המפלגה מייצגת ציבור רחב אשר נלחם בעזה ואף רושם מספר גדול של חללים. המפה השמאלית בישראל לאחר הקמת ממשלת הימין בגודל של 64 מנדטים, מפלגות המרכז והשמאל ספגו מקשה לא קטנה, עם זאת מאז פרוץ המלחמה נדמה שקיימת רוח חדשה שמרוממת לא רק את המצביעים הוותיקים אלא גם את המתמודדים החדשים ישנים. אחת הידיעות היא על שני מועמדים חדשים למפלגת "העבודה", הראשון הוא יאיר גולן ואבי שקד. יאיר גולן מגיע ממפלגת מרץ, אבל אחרי שפתיחת מלחמת חרבות ברזל היה נוכח בשטח ואף לקח חלק בפינו פצועים, נדמה כי קרנו עלתה בחלק מהציבור הרחב ולא רק זה המשתייך לשמאל. לעומתו אבי שקד שמגיע מעולם העסקים, משתייך למשפחת שקד שלקחה חלק עצום בבנייה של מדינת ישראל. עם זאת שקד מבקש להביא בשורה רעננה, כזו שמאחדת לא רק את מפלגות השמאל אלא גם מבקשות להביא את קולו של הבוחר הערבי במדינת ישראל שהוא על פיו שווה לכ-30 מנדטים. Posted in בב טיולים מאורגנים כשרים Posted on אוקטובר 19, 2023 אוקטובר 22, 2023 by זינה בחירת טיול מאורגן כשר מושלם בחירה נכונה של טיול מאורגן כשר היא בחירה אשר מצדיקה שיקול דעת מדוקדק. המסע לטיול שכזה מתחיל בבחירתו של מפעיל טיולים בעל מוניטין שישמש כמדריך לעולם המרגש של טיולים כשרים. כדי להתחיל, מומלץ לחקור את המוניטין והאמינות של מפעיל הטיולים, לוודא שיש להם היסטוריה של אספקת חוויות איכותיות. לצד זאת גם ביקורות ועדויות יכולות להציע תובנות חשובות לגבי הרקורד של מפעיל הטיולים כמו https://geshertours.co.il/ . סוגי כשרות ויעדים לאחר מכן בירור המוניטין של מפעיל הטיול, חשוב לוודא שמפעיל הטיולים מזוהה עם רשות אישורי כשרות מוכרת ומתאימות לסוג הכשרות שלנו. שיוך זה מהווה ערובה לכך שכל הארוחות הניתנות במהלך הטיול עומדות בתקני כשרות אשר מתאימים למטיילים. היעד ומסלול הטיול צריכים להתאים לתחומי העניין וההעדפות של הקבוצה. בשל כך מומלץ לשקול אם נרצה לחקור אתרים יהודיים היסטוריים, לטבול עצמנו בחוויות תרבותיות, או פשוט לספוג את היופי של נופים ציוריים. מסלול מובנה היטב יוכל להבטיח הפקה מרבית של המסע שלנו. גודל הקבוצה ומשך הנסיעה גודל קבוצת הנסיעות הוא גורם נוסף שמשפיע באופן משמעותי על חוויה של טיולים מאורגני םכשרים. קבוצות קטנות יותר מציעות לרוב תשומת לב אישית וגמישות יותר במסלול ובאופי הכשרות.  בעוד שקבוצות גדולות יותר יכולות ליצור סביבה דינמית וחברתית יותר, אבל עם דרישות מרובות יותר כמו סוג הכשרות, אופי הטיול וכו'. כמו כן גם משך הנסיעה והקצב הם גורמים חשובים להערכה בעת תכנון של טיול מאורגן כשר. נסיעות ארוכות יותר מאפשרות חקירה מעמיקה וטעימה של מקומות רבים, בעוד נסיעות קצרות וממוקדות יותר הן אידיאליות לביקורים ממוקדים וטעימה גבוה מכל מקום. לכן חשוב לזכור כי מציאת האיזון הנכון בין סיור וזמן הנופש הוא לעיתים קריטי. לינה מקומות הלינה ממלאים תפקיד חיוני בהבטחת הנוחות של הקבוצה במהלך טיולים מאורגנים כשרים. האיכות והסגנון של הלינה צריכים להתאים להעדפותיהם של המטיילים, ולספק סביבה מסבירת פנים. חשוב לא פחות הוא להבטיח שמקומות הלינה יכולים לספק את צרכי הכשרות, בין אם מדובר רק בארוחות בוקר קלות או אפילו ביכולת לשתות כוס קפה ללא חשש. בחירה של מקומות לינה מתאימים, תוכל לאפשר טיול כשר, מהנה ומותאם לכלל המטיילים. Posted in בב התנהלות נכונה בזמן ריב במשפחה Posted on מאי 4, 2023 by זינה התנהלות נכונה בזמן ריב במשפחה. התנהלות במשפחה והתנהלות בכלל בחיים, הכל קשור לחיבור. אבא, אמא, ילד, ילדה, משפחה. כל אחד יחיד ומיוחד. לכל אחד עולם שלם משלו. אפילו שמדובר במשפחה, כל אחד עם הדיעות שלו, רצונות שלו, חלומות שלו, טריטוריה שלו. אבל חיים ביחד, באותו בית, צריכים להתחשב בשני, ולא תמיד זה קל. כל אחד חושב על עצמו, כל אחד חושב שהוא זה שצודק. לא תמיד יש סבלנות לאחר, לא תמיד מקשיבים לאחר. הבעל חוזר עייף מהעבודה, אחרי יום עמוס, הילדים אחרי יום לימודים, האישה אחרי יום עבודה עמוס, ובבית אי סדר, כלים בכיור, אשפה לרוקן ועוד ועוד שלל מטלות הבית. כל אחד מצפה שהשני יעשה, כי עבר יום עמוס והוא עייף. מתחיל ויכוח, כל אחד טוען שהוא עושה יותר מהאחר בבית, לא מקשיבים לאחר, כל אחד רואה רק את זווית הראיה שלו. כל אחד הולך לחדרו, כעוס. אפשר גם אחרת. המשפחה יושבת במעגל, כל אחד אומר בקצרה את עמדתו, כל אחד מבני המשפחה מקשיב בקשב רב לדברי האחר, כל אחד מנסה להבין את האחר, ביחד מנסים למצוא פתרון. כולנו שונים אך שווים.  בבית נשאר רק תפוז אחד. שתי אחיות רבו על התפוז, רבו מי תקבל את התפוז האחרון שנשאר. כל אחת אמרה כי היא זו שרוצה את התפוז, האחיות רבו, כעסו זו על זו ואף אחת לא ויתרה לאחותה. האבא הגיע, ישב עם הבנות, ושאל כל אחת מה היא רוצה לעשות עם התפוז. האחות האחת אמרה כי היא רוצה רק את הפלחים של התפוז על מנת לעשות מיץ.  האחות השניה אמרה כי היא רוצה רק את הקליפה של התפוז על מנת להכין ריבה. הנה, אם רק כל אחת היתה מקשיבה לשניה, היו מבינות האחיות כי הן יכולות לחלוק את התפוז ביניהן ללא כל בעיה. אם רק נקשיב לאחר, ננסה להבין מה הוא רוצה, נהיה שם בשבילו, ולא נחשוב רק על עצמנו, ריב במשפחה יהפוך לריבה מתוקה. ואהבת לרעך כמוך. לקריאה נוספת – https://laitman.co.il / Posted in בב איך לבחור חברת ייעוץ פיננסי? Posted on ינואר 9, 2023 ינואר 10, 2023 by זינה לא מעט בעלי עסקים ואף משקי בית זקוקים לייעוץ פיננסי, בין אם מדובר בזמנים קריטיים כמו אובר דראפט חונק ועד אל נקודות זמן בהן החיסכון שצברנו הופך למשמעותי. עם זאת כאשר רובנו מגיעים אל צומת דרכים שכזו, ככל הנראה כי הידע שיש ברשותנו מצומצם ולעיתים אף לא קיים ובשל כך הסיכוי לבצע פעולות פיננסיות שגויות, עלול לגדול משמעותית. על כן קבלת ייעץ פיננסי דרך חברה או יועץ פיננסי, יאפשרו לכל בעל עסק ומשק בית לנתב בצורה מיטבית את הפעולות הפיננסיות שלהם, בין אם מדובר ברווחים ועד אל הפסדים וכמובן גם להשתכר בתוכנית מתאימה לעסק או לבית. מה כולל ייעוץ פיננסי? בין אם אנו בעלים של עסק חדש ובין אם אנו בעלים של עסק וותיק, ייעוץ פיננסי יוכל להיות מועיל עבורנו שכן לא רק שניתן יהיה להתאים תוכנית עסקית כלכלית מותאמת למידותיו של העסק שלנו אלא גם נוכל להילחץ ממצב פיננסי סבוך או לייעל את העסק בעשרות מונים. כך התכנון הפיננסי יכלול בתוכו הכנה של תוכנית הבראה או גדילה, שתיקח בחשבון את התנהלות הפיננסית אל מול רשויות המס, פיתוח ארגז כליים ייחודי לניהול שוטף של העסק, ניתוח וניהול תזרים מזומנים וכמובן התמודדות אל מול חובות והלוואות של העסק. כל אלו ועוד כלים נוספים יאפשרו לבעלי העסקים לנתב את הספינה הכלכלית שבבעלותם, בצורה נבונה אחראית ורווחית. איך לבחור חברת ייעוץ פיננסי? לצד שלל הכלים, התוכנית והניתוחים שיעזרו להפוך את העסק או משק הבית שלנו להרבה יותר רווחי, חשוב לדעת כיצד לבחור חברת ייעוץ פיננסי המתאימה לנו ולעסק שלנו. ראשית כל חשוב להכיר את ההמלצות וסיפורי ההצלחה של החברה, שכן חברה המצליחה להעניק שירותים מעולים תבקש לחשוף אותנו אל לקוחות קודמים שלה. שנית כל מומלץ לקחת בחשבון את הוותק והניסיון של החברה, שכן בעידן האינטרנטי ניתן לבדוק את זמן פעילות החברה ואת הרזומה המקצועי שלה במהירות רבה. כך נוכל לבצע התאמה בין ההתמחות של חברת הייעוץ והרזומה שלה, לבין צורכי העסק שלנו. לקריאה נוספת מוזמן לפנות לאתר מינוף עסקי . Posted in בב עד כמה כואבת השתלת עצם בחניכיים? Posted on אוקטובר 20, 2022 אוקטובר 25, 2022 by זינה לא מעט טיפולים שונים עלולים לעצור את תחושת הכאב ולהחליף אותה בתחושה נעימה יותר, אך כאשר טיפולים אלו מצטיירים עבורנו ככאובים במיוחד ייתן ורובנו הגדול ישתדל להימנע או לכל היותר להירתע מטיפול שכזה. אבל בנינו, מי לא היה נרתע מהשתלת עצם בחניכיים? ככל הנראה שרובנו הגדול לכן חשוב להכיר את אופי הטיפול, את הרציונל שעומד אחריו ומתי טיפול שכזה הוא בלתי נמנע. לצד ההכרה והמידע שכרוך בכל אלו, חשוב גם למצוא רופא שיניים המתמחה בשיקום פה והשתלות שיניים ובכך להבטיח לא רק טיפול קריטי וחשוב אלא גם יעיל עם כמה שפחות תופעות לוואי. מתי השתלת עצם בחניכיים היא הכרחית? איבוד עצם בשן עלול להתקיים תחת מספר מקרים, כאשר הראשון בהם עלול להיות נסיגה/ספיגה של עצם השן. מקרים כאלו מתקיימים החל מאיבוד שן על ידי מכה קריטית או עקירה של השן ללא טיפול נכון בזמן, אשר עלול להוביל לספיגה של עצם השן. מקרים נוספים מתקיימים כאשר ישנה מחלת חניכיים או עששת מתקדמות במיוחד, אשר עלולות להוביל לאובדן עצם השן בצורה חמורה במיוחד ולתופעות לוואי אחרות כמו נסיגת חניכיים ועוד. מקרים שכאלו יובילו במרביתם אל השתלת עצם בחניכיים, כל זאת בכדי לשקם את השן שנהרסה ולהשתיל במקומה שתל שיתפקד כשן בריאה. אך בכדי שהשתל אכן יוכל להפוך לשמיש, נדרשת עצם בכדי להחזיק אותו. עד כמה כואבת השתלת עצם בחניכיים ולמה? השיטות להשתלת עצם כיום מתחלקות לכמה סוגים, כאשר כל אחת מהן מנסה להבטיח בסיס קבע חזק מספיק לשתל החדש והשיטה הראשונה היא בעזרת שימוש בעצם מירכו של המטופל. שיטה זו מאפשרת דיוק גבוה יחסית בהשתלה עם סיכויים נמוכים מאוד של דחיית העצם, כאשר שיטות אחרות עושות שילובים בין חומרים סינטטיים לעצמות בעלי חיים. תהליך ההחלמה מהשתלה שכזו נע בין שישה שבועות לעד שניים עשר שבועות, כשלאחר ההליך יורגשו כאבים, נפיחות ובמהלכן יירשמו תרופות מתאימות בכדי להתמודד עם הכאבים. חשוב לזכור כי מרבית הכאבים יתלוו אל הימים הראשונים שלאחר ההשתלה, כאשר בהמשך תורגש הקלה משמעותית. עם זאת חשוב לשמור על המגבלות כמו לא לעשן, לא להיות בקרבת קרינה רפואית ועוד. Posted in בב פטור מהיתר בנייה Posted on אוגוסט 14, 2022 אוגוסט 20, 2022 by זינה כאשר מדובר בבנייה של בתים בישראל ובעולם המערבי בכלל, אי אשפר שלא להתעלם מתוכניות בניין עיר הדורשות מגוון רחב של אישורים, הן מהרשות המקומית ובחלק גדול מהמקרים גם מוועדת התכנון המקומית או המחוזית. פטור זה נדרש במגוון רחב של מקרי בנייה, בין אם בעלי הנכס מבקשים להוסיף קיר, פרגולה ואפילו חריגה מגודלה של המרפסת. אל מקרים אלו מצטרפים עוד מגוון רחב של סוגי בנייה ושימושי קרקע כאלו ואחרים אך בראש ובראשונה, קבלת הפטור תאשר את אופי הבנייה, את התכנון הצפוי ובעיקר הימצאות של כל האישורים הרלוונטיים שבנייה עירונית. על כן מומלץ לקבל פטור מהיתר בנייה עוד בשלבי התכנון ובכך למנוע עיכובים, צווי הריסה ועוד. מתי לא צריך פטור מהיתר בנייה? כאשר מדובר בעבודות שיפוצים אותן ניתן לבצע ללא עמידה בדרישות תוכנית תב"ע או דרישות עירייה שונות, יש לענות על מספר הגדרות והראשון שבהם היא מידת המורכבות של המבנה. כך למשל מבנים קלים יכולים להיבנות גם באזורי קרקע שאינם מיועדים לכך, עם זאת יתקיימו מספר הגבלות שונות בין אם מדובר בחיבור תשתיות, במספר הנוכחים ועוד. התנאי הבא הוא כאשר לא נשקפת סכנה או הפרעה, לא רק ליושבי הבית או לדיירים נוספים ולרבות שכנים של אותו המבנה או הבנייה. אל תנאים אלו כמובן מצטרפים עוד מספר סיבות בגינן ניתן לקבל פטור מהיתר בנייה, כאשר המרכזי בניהם הוא שמירה על שלד הבניין והיציבות שלו ובכך לוודא כי לא יתקיימו שינויים מהותיים המסוגלים מבחינה הנדסית לאיים על חיי התושבים. עבודות הדורשות היתר בניה מאידך כאשר מדובר בעבודות בהן לא ניתן לקבל פטור מהיתר בנייה, ככל הנראה עבודות אלו יחשבו למורכבות יותר ויכולות לכלול כמו שכבר ציננו בנייה של מרפסת ועד לשינוי מבנה הקרקע. קבלת היתר במקרים שכאלו נשענת בדיוק כמו בבנייה הפטורה מהיתר בנייה, רק להפך. כך למשל בנייה אשר אמורה לשנות את חזית הבנייה או לכלול סכנה בבנייה כמו הוספת קומה, תדרוש מבעלי הנכס הכנת תוכנת סדורה ומתוכננת היטב אשר תעמוד בדרישות הוועדה לתכנון מקומי. Posted in בב היתרונות של פירות יער Posted on יוני 27, 2022 by זינה בעשורים האחרונים נוסף אל עולם הבישול, הקונדיטוריה ואפילו התזונה רובד נוסף של טעמים אשר מצליח להשתלב בין כל העולמות הללו לא כל בעיה ואף לעשות זאת בצורה הכי טבעית וטעימה, והוא כמובן טעמם של פירות יער . סוגי פירות אלו היו שם מאז ומתמיד, אך עם גילוי היתרונות הרפואיים הרבים שיש בהם, הפכו אפשר לומר בעל כורחם לתוסף המרענן הבא בצלחת שלנו. לכן לפני שנוציא את פירות היער הקפואים מהמקפיא שלנו, מומלץ שנכיר את היתרונות הרבים הקיימים בפירות היער אשר מסוגלים לשנות אורך החיים שלנו בצורה מופלאה וכל זאת דרך מגוון של טעמים ושילובים שונים. היתרונות של פירות היער – עיכול בריאות העור כאשר מדובר בפירות כדוגמת פירות היער, חשוב להבין כי בפירות אלו כמו אוכמניות קיימים לא מעט סיביים תזונתיים אשר מסייעים בצורה ניכרת למערכת העיכול לפעול בצורה תקינה ואף לשפר את ביצועיה. עם זאת לפירות היער קיים גם ערך גליקמי נמוך המאפשר גם לחולי סכרת להנות מטעמם, וללא כל סיכון של עלייה במדדי הסוכר העדינים. וכמובן שלצד כל אלו בפירות היער קיימים גם לא מעט נוגדי חמצון הידועים כיעילים עבור מגוון מערכות הגוף כאשר אחת מהן היא בשמירה על העור הגוף תוך כדי "לחימה" ברדיקלים חופשיים ומניעה של קמטים עם היחשפות ממושכת לשמש. יתרונות נוספים – דיאטות ודלקות פירות היער מכילים לא מעט חומרים מעולים להגנה על הגוף שלנו, כאשר לכל פירות אלו ישנם תכונות אנטי דלקתיות המצליחות להילחם החל מדלקות מעיים ועד לדלקות פרקים שונות ולסלק את החומצה האורית הקיימת באזורים "מודלקים". יתרון נוסף נמצא גם במערכת כלי הדם והלב, כאשר אוכמניות ידועות כפירות המחזקות את כלי הדם ואת המערכת הלבבית ואפילו על בריאות המוח. אך היתרונות של פירות היער אינם נעלמים רק באלו, אלא אובחנו גם ביכולת להוריד את רמת הכולסטרול הרע כאשר פטל ותות שחור הוכיחו במחקרים שונים את היעילות שלהם בהורדה ניכרת של אחוזי כולסטרול רע. כל היתרונות הנפלאים הללו מתאפשרים גם בצריכה של פירות יער קפואים וגם בטריים. Posted in בב היתרונות של מגורים באילת Posted on מאי 15, 2022 by זינה ישנן לא מעט ערים שונות בישראל בהן נוכל לגור, להנות מאופי המקום, מהמיקום הגיאוגרפי, מרמת ביקוש של סקטור כזה או אחר. כל עיר והאופי המייחד אותה ואת האוכלוסייה שלה, כמו שהעיר תל אביב נהנית זה שנים מאירוח של מגון אירועי תרבות בכל ערב, כך גם ערים אחרות מביאות את האופי והיתרון שבמגורים אצלהן. אחת מהן היא ללא ספק העיר אילת הנחשבת לפנינת הדרום ומובילה זה שנים כאחת מערי התיירות המבבוקשות בישראל, כיום היא גם מציעה מנעד של תמריצים כלכלים אך גם התחדשות וקצב בנייה כמו כל פרויקט מוצלח של אברהמי באילת , שעוד ימשוך אליו רבים מאזור המרכז. לעובדים מרחוק ולאנשי החינוך אילת מציאה מגוון רחב של תפנוקים שונים, אחד מהם והברור בשוק הנדל"ן הישראלי הוא כמובן מחירים די נמוכים אבל גם עלויות שכירות מהנמוכות בארץ. אך לצד זאת עיריית אילת מגדילה ואף מעניקה הטבות מס עד עשרה אחוזים, פטור ממע"מ וקהילת עסקים מתפתחת. אל כל אלו מתווספים גם חידוש תשתיות והתחדשות עירונית, תוך כדי תשומת לב לצרכים עתידיים כמו עמדות עבודה בחינם. כך מייצרת עיריית אילת אזור נוח גם לאנשים העובדים מרחוק, כך שלא רק יוכלו להרוויח יותר אלא גם לחמוק מהצפיפות של המרכז. והבשורה השנייה היא כמובן בקרב אנשי החינוך, שכן עיריית אילת ומשרד החינוך מזמינים מורים ללמד במגוון מסגרות חינוכיות בעיר, עם הטבות כספיות למתמידים של עד מאה אלף שקלים! היתרונות של מגורים באילת זה לא רק כסף כי העיר הזו היא לב פועם באמצע המדבר, בין אם ניתן להנות ממגוון רחב של מסעדות, ברים, אזורי בילוי ואטרקציות שלא נסיים גם בתקופה של חודש. כל אלו מתחברים אל הנוף המדברי המדהים, אל החופים המרהיבים והשקטים שנוכל למצוא וכמובן למגוון אירועי התרבות הנחגגים בעיר מדי שנה. לכן התמריצים הכלכליים לעבור לעיר באילת, אמנם מהווים נדבך די גדול בין היתרונות של מגורים באילת אך הם אינם משתווים לכל היופי הטבעי והאטרקציות הבלתי נגמרות מהן ניתן להנות בעיר. אז בפעם הבאה שנבקש להחליף אווירה, העיר אילת תהיה בהחלטה הבחירה המתאימה. Posted in בב איך מחשבים שווי הוגן? Posted on אפריל 11, 2022 אפריל 20, 2022 by זינה חברות לא פעם נדרשות לבצע הערכות שווי הוגן , עם מעמדים משתנים החל מעסקאות מיזוגק משמחות ועד להנפקות בורסאיות או סכסוכים משפטיים שונים. הערכות אלו מתבצעות על מנת לקבל הערכה לכל המשאבים השונים, התזרים הכספי, נכסים מוחשיים ועוד רבדים שונים ואחרים המשוטטים כחלק מבסיס כלכלי של חברות שונות. חישוב של כל אלו יכול לעזור במידה רבה במעמדים משפטיים או במכירות כמו שציינו, שכן הערכה שכזו תעזור לאמוד את מחירה האמיתי של החברה ולהכיר בנכסיה השונים. הערכות אלו לא פעם נעשות בכמה שיטות שונות, עם זאת מרביתן נחשבות לאמינות ולעיתים מתאימות לסוגים שונים של הערכות שווי. מאפיינים לחישוב שווי הוגן כמו שציינו מעל ישנם כמה דרכים לבצע הערכת שווי הוגן לחברות, חלק מהשיטות מתאימות להערכה על פי סקטור החברה, חלק מהשיטות מתאימות לגודל החברה ואילו חלק לשלבי החברה ומוצריה. כך למשל חברת הייטק בהרצה תקבל הערכת שווי שונה, כזו המלווה בערכת סיכונים אחרת. להבדיל חברת בנייה המבקשת להנפיק עצמה בבורסה, תבצע הערכת שווי חברה אחרת משל חברת ההייטק בהרצה. על כן התחשיבים להערכת שווי יכולים להתבסס על דוחות כספיים בלבד או תוך כדי התעמקות ונבירה לאופי החברה, לפעילות הפיננסית והחברתית שלה במדינה בה היא פועלת ועוד מאפיינים כאלו ואחרים. בשביל ומה ואיך שווי הגון באשר לחברות המצויות בשלבים "חיים" ופועלות לא מיומם הראשון, ניתן לעשות שווי הערכה בשיטת הDCF אשר יוצאת מנקודת הנחה כי בעל העסק מנסה "למקסם" את הפעילות והרווחים ממנו. ניתוח זה מתעסק לא רק בהכנסות ופעילות עכשוויות אלא גם בהשקעות עתידיות מטעם הבעלים, אשר אמורים להבטיח את עתידה הכלכלי של החברה גם בהמשך. שיטה נוספת היא שיטה המתאימה יותר לחברות נדל"ן, והיא מתבססת על מספר הנכסים שבמאזנה של החברה. שכן במקרים שונים התחייבויות החברה עלולות לעלות על כמות הנכסים שברשותה ולהפך, על כן שיטה זו יכולה לייצר תמונה ברורה יותר ביכולת החברה לעמוד בהתחייבויות. מקרים בהם נתבקש לבצע הערכת שווי הוכן עלולות להיות קריטיות לעתיד העסק שלנו, לכן מומלץ לעשות זאת בצורה מקצועית וקפדנית. Posted in בב שבר בכף היד Posted on מרץ 17, 2022 מרץ 21, 2022 by זינה בעיות אורטופדיות עלולות לא פעם לחזור פעם אחר פעם, לעיתים בגלל תחזוקה לקויה לאחר החלמה ולעיתים בגלל מחלות נלוות כמו אוסטיאופורוזיס. אך פציעות כמו שבר בכף היד עלולות לקרות עכב נפילה וניסיון של הנפצע להגן על פניו בעזרת ידו, מעין אינסטינקט טבעי ומובן לחלוטין המתקיים לרבות בפעילויות ספורטיביות כמו חבלות סקי, משחקי כדור ולעיתים אף בתאונות דרכים. טיפול נכון בשבר בכף היד דורש הערכה ואבחנה מהירה ככל הניתן, על כן מומלץ להכיר את התסמינים השונים בעת שבר בכף היד ולטפל במהירות האפשרית על מנתת לטפל בשבר בצורה נכונה ומדויקת לו. תסמינים ודרכים לזיהוי שבר בכף היד מביא עימו מנעד של תסמינים שונים, הם יכולים להתגלם ככאב עז בעת הנעה של אצבעות היד או שורש כף היד, לרגישות מוגברת באזור השבר, סימני חבלה קשים, עיוותים, הגבלה של תנועה, תחושת נימול ובמקרים מסוימים אפילו תחושת קור. במרבית המקרים פגיעות אלו מטופלות לראשונה על ידי מוקד חירום ואיתו תתקבע היד או האזור הפגוע ותתבצע הדמיית רנטגן בכדי למקם את השבר.  עם זאת קיבוע זה איננו מספיק ולאחר טיפול זה יש להגיע אל רופא כירורג כף יד, אשר יוכל להבין את מנגנון הפגיעה, את אופי השימוש שלה(בין אם היד השולטת או לפגיעה במשך עבודה סבירה). לצד בדיקה זו מומלץ לבצע גם בדיקת CT על מנת לראות בצורה ברורה יותר את עומק השבר, ובמידת הצורך גם ביצוע MRI שיעניק אינפורמציה קריטית בנוגע לחבלות של גידים ושרירים. דרכים לטיפול בשבר בכף היד קיבוע במוקד חירום הינו חשוב וקריטי להמשך הטיפול, עם זאת לאחר פגישה עם כירורג יתבצע קיבוע לעיתים מחודש על ידי רופא מומחה. פעולה זו עלולה להכאיב, שכן קיבוע על ידי רופא מומחה תעשה על מנת לאחות את השבר על ידי קיבוע הגפה בגבס למשך של שישה חודשים. עם זאת במקרים מסוימים הגבס יתקשה לשמור על קבוע מדויק, ובמקרים כאלו יזדקק המטופל לעבור ניתוח לקיבוע קבוע של השבר. קיבוע זה ייעשה לעיתים בעזרת מסמרים, פלטה לקיבוע האזור בעזרת ברגים, אך מעל לכל הטיפול ייעשה בהתאם לסוג השבר. Posted in בב ניווט פוסטים ישנים
======>
https://github.com/JaLnYn/websocket-ide
-->>-->>
Repository files navigation README MIT license WIDE (websocket ide) A lightweight code server that lets you build custom websocket-based IDEs. Built with Rust for speed and reliability. Perfect for web-based coding environments, self-hosted solutions, or custom IDE implementations. An example browser IDE is right here: 🍌 JaLnYn/browser-ide Features ✨ File operations (read/write/watch) 🚀 Language Server Protocol support (completion, hover, go-to-def) (only rust for now) 🔄 Real-time WebSocket communication ⚡ Event batching for performance Quick Start # Run the server cargo run -- --workspace /your/code/path WebSocket API Client Messages Type Content Description OpenFile { path: string } Opens a file and returns its content. Validates file existence and readability. Notifies LSP servers. CloseFile { path: string } Closes an open file, cleans up resources, and notifies LSP servers. GetDirectory { path: string } Retrieves directory contents at the specified path. RefreshDirectory { path: string } Force refreshes directory contents, clearing cache. ChangeFile { document: { uri: string, version: number }, changes: Change[] } Applies changes to file content. Validates document version. SaveFile { document: { uri: string, version: number } } Saves current file content to disk. Completion { path: string, position: Position } Requests code completions at position. Hover { path: string, position: Position } Requests hover information at position. Definition { path: string, position: Position } Requests go-to-definition locations. Server Messages Type Content Description DirectoryContent { path: string, content: FileNode[] } Directory listing DocumentContent { path: string, content: string, metadata: DocumentMetadata, version: number } File content FileSystemEvents { events: FileEvent[] } Real-time file system changes CompletionResponse { completions: CompletionList } LSP completion items HoverResponse { hover: Hover } LSP hover information DefinitionResponse { locations: Location[] } LSP definition locations ChangeSuccess { document: { version: number } } Confirms file changes SaveSuccess { document: { version: number } } Confirms file save Error { message: string } Error details Success {} Generic success Todo Debugger support Search More LSP features Testing Documentation improvements Better error handling Multi-root workspace support Contributing I'm actively working on this project and welcome any contributions! Feel free to: Implementing new features Making things faster Adding tests Improving docs Making the code prettier Adding cool stuff we haven't thought of Built with 🦀 by someone who love coding on gpu servers.
======>
https://github.com/bedrock-crustaceans/violin_rs
-->>-->>
Skip to content {"props":{"docsUrl":"https://docs.github.com/get-started/accessibility/keyboard-shortcuts"}} {"resolvedServerColorMode":"day"} Navigation Menu Toggle navigation Sign in Product GitHub Copilot Write better code with AI Security Find and fix vulnerabilities Actions Automate any workflow Codespaces Instant dev environments Issues Plan and track work Code Review Manage code changes Discussions Collaborate outside of code Code Search Find more, search less Explore All features Documentation GitHub Skills Blog Solutions By company size Enterprises Small and medium teams Startups By use case DevSecOps DevOps CI/CD View all use cases By industry Healthcare Financial services Manufacturing Government View all industries View all solutions Resources Topics AI DevOps Security Software Development View all Explore Learning Pathways White papers, Ebooks, Webinars Customer Stories Partners Open Source GitHub Sponsors Fund open source developers The ReadME Project GitHub community articles Repositories Topics Trending Collections Enterprise Enterprise platform AI-powered developer platform Available add-ons Advanced Security Enterprise-grade security features GitHub Copilot Enterprise-grade AI features Premium Support Enterprise-grade 24/7 support Pricing Search or jump to... Search code, repositories, users, issues, pull requests... Search Clear Search syntax tips Provide feedback We read every piece of feedback, and take your input very seriously. Include my email address so I can be contacted Cancel Submit feedback Saved searches Use saved searches to filter your results more quickly Name Query To see all available qualifiers, see our documentation . Cancel Create saved search Sign in Sign up Reseting focus You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session. You switched accounts on another tab or window. Reload to refresh your session. Dismiss alert {{ message }} bedrock-crustaceans / violin_rs Public Notifications You must be signed in to change notification settings Fork 0 Star 7 Rust framework for Rust-powered Minecraft addon development 7 stars 0 forks Branches Tags Activity Star Notifications You must be signed in to change notification settings Code Issues 0 Pull requests 0 Actions Projects 0 Security Insights Additional navigation options Code Issues Pull requests Actions Projects Security Insights bedrock-crustaceans/violin_rs {"props":{"initialPayload":{"allShortcutsEnabled":false,"path":"/","repo":{"id":749845646,"defaultBranch":"master","name":"violin_rs","ownerLogin":"bedrock-crustaceans","currentUserCanPush":false,"isFork":false,"isEmpty":false,"createdAt":"2024-01-29T14:11:58.000Z","ownerAvatar":"https://avatars.githubusercontent.com/u/177853159?v=4","public":true,"private":false,"isOrgOwned":true},"currentUser":null,"refInfo":{"name":"master","listCacheKey":"v0:1706537522.0","canEdit":false,"refType":"branch","currentOid":"6bdaddc3c2874fe9bb92b956475e344c2d6ea36e"},"tree":{"items":[{"name":".AddCompLib","path":".AddCompLib","contentType":"directory"},{"name":".idea","path":".idea","contentType":"directory"},{"name":".vscode","path":".vscode","contentType":"directory"},{"name":"public","path":"public","contentType":"directory"},{"name":"src-scripts","path":"src-scripts","contentType":"directory"},{"name":"src","path":"src","contentType":"directory"},{"name":"templates","path":"templates","contentType":"directory"},{"name":".gitignore","path":".gitignore","contentType":"file"},{"name":"Cargo.lock","path":"Cargo.lock","contentType":"file"},{"name":"Cargo.toml","path":"Cargo.toml","contentType":"file"},{"name":"README.md","path":"README.md","contentType":"file"}],"templateDirectorySuggestionUrl":null,"readme":null,"totalCount":11,"showBranchInfobar":false},"fileTree":null,"fileTreeProcessingTime":null,"foldersToFetch":[],"treeExpanded":false,"symbolsExpanded":false,"isOverview":true,"overview":{"banners":{"shouldRecommendReadme":false,"isPersonalRepo":false,"showUseActionBanner":false,"actionSlug":null,"actionId":null,"showProtectBranchBanner":false,"publishBannersInfo":{"dismissActionNoticePath":"/settings/dismiss-notice/publish_action_from_repo","releasePath":"/bedrock-crustaceans/violin_rs/releases/new?marketplace=true","showPublishActionBanner":false},"interactionLimitBanner":null,"showInvitationBanner":false,"inviterName":null,"actionsMigrationBannerInfo":{"releaseTags":[],"showImmutableActionsMigrationBanner":false,"initialMigrationStatus":null}},"codeButton":{"contactPath":"/contact","isEnterprise":false,"local":{"protocolInfo":{"httpAvailable":true,"sshAvailable":null,"httpUrl":"https://github.com/bedrock-crustaceans/violin_rs.git","showCloneWarning":null,"sshUrl":null,"sshCertificatesRequired":null,"sshCertificatesAvailable":null,"ghCliUrl":"gh repo clone bedrock-crustaceans/violin_rs","defaultProtocol":"http","newSshKeyUrl":"/settings/ssh/new","setProtocolPath":"/users/set_protocol"},"platformInfo":{"cloneUrl":"https://desktop.github.com","showVisualStudioCloneButton":false,"visualStudioCloneUrl":"https://windows.github.com","showXcodeCloneButton":false,"xcodeCloneUrl":"xcode://clone?repo=https%3A%2F%2Fgithub.com%2Fbedrock-crustaceans%2Fviolin_rs","zipballUrl":"/bedrock-crustaceans/violin_rs/archive/refs/heads/master.zip"}},"newCodespacePath":"/codespaces/new?hide_repo_select=true\u0026repo=749845646"},"popovers":{"rename":null,"renamedParentRepo":null},"commitCount":"49","overviewFiles":[{"displayName":"README.md","repoName":"violin_rs","refName":"master","path":"README.md","preferredFileType":"readme","tabName":"README","richText":"\u003carticle class=\"markdown-body entry-content container-lg\" itemprop=\"text\"\u003e\u003cp dir=\"auto\"\u003e\u003ca target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://github.com/NaKeRNarolino/violin_rs/blob/master/public/Violin%20Cover.png?raw=true\"\u003e\u003cimg src=\"https://github.com/NaKeRNarolino/violin_rs/raw/master/public/Violin%20Cover.png?raw=true\" alt=\"Logo: Violin.rs\" style=\"max-width: 100%;\"\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"markdown-heading\" dir=\"auto\"\u003e\u003ch1 tabindex=\"-1\" class=\"heading-element\" dir=\"auto\"\u003eViolin.rs is a Rust framework for rust-powered MCBE addon development (Previously known as Violet Crystal)\u003c/h1\u003e\u003ca id=\"user-content-violinrs-is-a-rust-framework-for-rust-powered-mcbe-addon-development-previously-known-as-violet-crystal\" class=\"anchor\" aria-label=\"Permalink: Violin.rs is a Rust framework for rust-powered MCBE addon development (Previously known as Violet Crystal)\" href=\"#violinrs-is-a-rust-framework-for-rust-powered-mcbe-addon-development-previously-known-as-violet-crystal\"\u003e\u003csvg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"\u003e\u003cpath d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/div\u003e\n\u003cp dir=\"auto\"\u003e\u003cem\u003eViolin.rs is currently in refactoring process.\u003c/em\u003e\u003c/p\u003e\n\u003cdiv class=\"markdown-heading\" dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" class=\"heading-element\" dir=\"auto\"\u003eAvailable features:\u003c/h3\u003e\u003ca id=\"user-content-available-features\" class=\"anchor\" aria-label=\"Permalink: Available features:\" href=\"#available-features\"\u003e\u003csvg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"\u003e\u003cpath d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/div\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003ePack generation\u003c/li\u003e\n\u003cli\u003eItems (all the components are there!)\u003c/li\u003e\n\u003cli\u003eScript support (pairing a folder with .js scripts with the pack)\u003c/li\u003e\n\u003cli\u003eRecipes\u003c/li\u003e\n\u003cli\u003eBlocks*\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp dir=\"auto\"\u003e* - Block APIs are still not refactored\u003c/p\u003e\n\u003cdiv class=\"markdown-heading\" dir=\"auto\"\u003e\u003ch3 tabindex=\"-1\" class=\"heading-element\" dir=\"auto\"\u003ePlans:\u003c/h3\u003e\u003ca id=\"user-content-plans\" class=\"anchor\" aria-label=\"Permalink: Plans:\" href=\"#plans\"\u003e\u003csvg class=\"octicon octicon-link\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\" aria-hidden=\"true\"\u003e\u003cpath d=\"m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z\"\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/a\u003e\u003c/div\u003e\n\u003cul dir=\"auto\"\u003e\n\u003cli\u003eEntities;\u003c/li\u003e\n\u003cli\u003eAnimation / Render controllers;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/article\u003e","loaded":true,"timedOut":false,"errorMessage":null,"headerInfo":{"toc":[{"level":1,"text":"Violin.rs is a Rust framework for rust-powered MCBE addon development (Previously known as Violet Crystal)","anchor":"violinrs-is-a-rust-framework-for-rust-powered-mcbe-addon-development-previously-known-as-violet-crystal","htmlText":"Violin.rs is a Rust framework for rust-powered MCBE addon development (Previously known as Violet Crystal)"},{"level":3,"text":"Available features:","anchor":"available-features","htmlText":"Available features:"},{"level":3,"text":"Plans:","anchor":"plans","htmlText":"Plans:"}],"siteNavLoginPath":"/login?return_to=https%3A%2F%2Fgithub.com%2Fbedrock-crustaceans%2Fviolin_rs"}}],"overviewFilesProcessingTime":0}},"appPayload":{"helpUrl":"https://docs.github.com","findFileWorkerPath":"/assets-cdn/worker/find-file-worker-1583894afd38.js","findInFileWorkerPath":"/assets-cdn/worker/find-in-file-worker-67668e8c2caa.js","githubDevUrl":null,"enabled_features":{"code_nav_ui_events":false,"overview_shared_code_dropdown_button":false,"react_blob_overlay":false,"copilot_conversational_ux_embedding_update":false,"copilot_smell_icebreaker_ux":true,"copilot_workspace":false,"blob_edit_unsaved_changes_storage":false,"accessible_code_button":true}}}} master 1 Branch 0 Tags Go to file Code Folders and files Name Name Last commit message Last commit date Latest commit NaKeRNarolino Update README.md Nov 9, 2024 6bdaddc · Nov 9, 2024 History 49 Commits .AddCompLib .AddCompLib The First Commit Jan 29, 2024 .idea .idea Blocks are semi-working now! Apr 24, 2024 .vscode .vscode Adding blocks; Added [S] Vec3 Apr 22, 2024 public public Add files via upload Nov 5, 2024 src-scripts src-scripts $Script pairing Nov 9, 2024 src src $Script pairing Nov 9, 2024 templates templates *refactored some Pack APIs Nov 8, 2024 .gitignore .gitignore $Script pairing Nov 9, 2024 Cargo.lock Cargo.lock *refactored some Pack APIs Nov 8, 2024 Cargo.toml Cargo.toml *refactored some Pack APIs Nov 8, 2024 README.md README.md Update README.md Nov 9, 2024 View all files Repository files navigation README Violin.rs is a Rust framework for rust-powered MCBE addon development (Previously known as Violet Crystal) Violin.rs is currently in refactoring process. Available features: Pack generation Items (all the components are there!) Script support (pairing a folder with .js scripts with the pack) Recipes Blocks* * - Block APIs are still not refactored Plans: Entities; Animation / Render controllers; {"resolvedServerColorMode":"day"} About Rust framework for Rust-powered Minecraft addon development Topics rust-lang minecraft-bedrock-addon Resources Readme Activity Custom properties Stars 7 stars Watchers 1 watching Forks 0 forks Report repository Releases No releases published Languages Rust 90.7% Jinja 6.9% JavaScript 2.4% Footer © 2024 GitHub, Inc. Footer navigation Terms Privacy Security Status Docs Contact Manage cookies Do not share my personal information You can’t perform that action at this time.
======>
https://old.reddit.com/u/plugwash
-->>-->>
> It is probably better to ask, what exactly is 'static in terms of lines of code? Is it something that extends beyond the scope of fn main? 'static on a reference means that the target will exist for the remaining life of the process (running program). It will never be dropped and the memory in which it is stored will remain valid until the process ceases to exist. This isn't something defined in terms of "lines of code", it's a lower level concept than that. As far as the compiler is concerned main is mostly treated as a normal function and all the same lifetime rules that apply to normal functions apply. Stuff can happen after main returns, for example On unix-like systems "atexit" can be used to register exit handlers which run after main returns (or when exit is called). In rust "main" can return any type that implements the trait "Termination", this trait has a method which will be called after main returns. Other threads may still be running when main returns. The OS will kill them when the program exits but there is still a (usually small) window of time between when main returns and when the program actually exits.

======>
https://old.reddit.com/r/rust/comments/1gmgyuf/major_indonesian_bank_cimb_niaga_transition_from/
-->>-->>
https://preview.redd.it/uy20rtbh4ozd1.png?width=720&format=png&auto=webp&s=0796477c0ef179f9ae87def23cdbd7ab0e5b66e8   

   Read more at:   

   https://medium.com/cimb-niaga-engineering/delivering-superior-banking-experiences-bc7ca491eae5   
   

======>
https://old.reddit.com/r/rust/comments/1gn7i6m/miniboosts_v035/
-->>-->>
Hello, rusteaceans 🦀.   

   Thanks to everyone in this community, I finally released a small machine-learning library,    MiniBoosts    (crates.io is    here   ).   

   (I asked for help in the    previous post   , and it was helpful. I love you all, rusteaceans!)   

   This is just a hobby project, but any comments are welcome.   
   

======>
https://old.reddit.com/r/rust/comments/1gn5x4q/is_it_bad_to_use_multi_word_lifetime_names_in/
-->>-->>
E.g.   

   ‘’’   

   struct MyStruct<‘descriptive_name> {   

   thing1: &’descriptive_name mut Thing1,

thing2: &’descriptive_name mut Thing2
   

   }   

   ‘’’   

   Sometimes there’s only 1 field in there, sometimes multiple. Anyone ever seen descriptive names in big projects? I try to keep it to one word but sometimes I feel 2 words/shortened words is nice. What’s your opinion on non-single character lifetime names?   
   

======>
https://old.reddit.com/r/rust/comments/1gndvkb/why_great_cli_tools_do_not_have_beautiful_ui/
-->>-->>
Hi everyone,   

   Currently, I am building a CLI tool in Rust and almost completed it.    

   Now, I am planning to design TUI for it so that user find it easy to use and logs error, warning and messages in better pleasing way.   

   Then I realised that most famous CLI tools do not have beautiful, colourful UI, only text prompts.   

   Is there any design decision or developer laziness to write more lines of code?   

   Thanks, everyone.   
   

======>
https://github.com/drogus/jaws
-->>-->>
Repository files navigation README Apache-2.0 license Jaws Jaws is a JavaScript to WebAssembly compiler written in Rust. It is similar to porffor in a way it also results in a standalone WASM binary that can be executed without an interpreter, but it takes a different implementation approach. It's an experimental tool and it's not ready for production. A lot of the language
features and builtin types are missing or incomplete. That said, my goal is to eventually support 100% of the language. Why Jaws? I started this project while working on a stress testing tool called Crows that runs WebAssembly scenarios. At the moment it only supports code compiled from Rust to WASM. As much as I love writing Rust, I also know it's not a widely popular language and besides, small tests are often easier to write in interpreted languages. The problem is, running scripting languages on top of WASM is not ideal at the moment. You have to either include an interpreter, which automatically makes the binary at least a few MBs in size and the memory usage even bigger, or use a variation of the language you're targetting (like TinyGo instead of Go, or AssemblyScript instead of TypeScript/JavaScript). I believe that with modern WASM proposals it is possible to implement 100% of JavaScript features without the need to use a compiled interpreter, as WASM runtimes are already interpreters. If you want to see it happen, please consider sponsoring my work What works As I eventually want to implment 100% of the language, I'm purposefully focused on implementing the semantics first, rather than go for 100% of builtins and grammar as I want to be 100% sure it's doable. I have a list of 4 things that I think are hard to implement and after I implement all of them I will focus on more grammar and builtins. These are: Scopes/closures try/catch async/await generators The last two are kind of similar as by getting generators working, one essentially has tools to make async await work, but I still wanted to make the distinction. At the moment Jaws can compile code using closures with (mostly) proper scopes support, it allows try/catch and it implements (limited) Promise API and async (but not await yet). For example the following script will print error: foo : let value = "foo" ; async function foo ( ) { throw value ; } foo ( ) . then ( function ( ) { } , function ( v ) { console . log ( "error" , v ) ; } , ) ; A non exhaustive list of other stuff that should work: declaring and assigning: var , let , const while string lierals, adding string literals numbers and basic operators ( + , - , * , / ) booleans and basic boolean operators array literals object literals new keyword Host requirements As Jaws is built with a few relatively recent WASM proposals, the generated binaries are not really portable between runtimes yet. I'm aiming to implement it with WASIp2 in mind, but the only runtime capable of running components and WASIp2, ie. Wasmtime, does not support some other things I use, like parts of the WASM GC proposal or exception handling. In order to make it easier to develop before the runtimes catch up with standardized proposals, I decided to use V8 (through Chromium or Node) with a Javascript polyfill for WASIp2 features that I need. There is a script run.js in the repo that allows to run binaries generated by Jaws. Eventually it should be possible to run them on any runtime implementing WASM GC, exception handling and WASIp2 API. How to use it? Unless you want to contribute you probably shouldn't, but after cloning the repo
you can use an execute.sh script like: ./execute.sh --cargo-run path/to/script.js It will generate a WAT file, compile it to a binary and then run using Node.js. It requires Rust's cargo , relatively new version of wasm-tools and Node.js v23.0.0 or newer. Passing --cargo-run will make the script use cargo run command to first compile and then run the project, otherwise it will try to run the release build (so you have to run cargo build --release prior to running ./execute.sh without --cargo-run option) What's next? My plan is to finish implementing all of the "hard to implement" features first, so next in line are generators and await keyword support. Ideally I would use the stack-switching proposal for both await and generators, but alas it's only in Phase 2 and it has minimal runtime support (I could find some mentions in Chromium development groups, but I couldn't get it to work). In the absence of stack-switching I'm working on using CPS transforms in order to simulate continuations. After that's done, I will be slowly implementing all of the missing pieces, starting with grammar (for loops, switch etc) and then builtin types and APIs. How does it work? The project is essentially translating JavaScript syntax into WASM instructions, leveraging instructions added by WASM GC, exception handling and tail call optimizations proposals. On top of the Rust code that is translating JavaScript code, there is about 3k lines of WAT code with all the plumbing needed to translate JavaScript semantics into WASM. To give an example let's consider scopes and closures. WASM has support for passing function references and for structs and arrays, but it doesn't have the scopes semantics that JavaScript has. Thus, we need to simulate how scopes work, by adding some extra WASM code. Imagine the following JavaScript code: let a = "foo" ; function bar ( ) { console . log ( a ) ; } bar ( ) ; In JavaScript, because a function definition inherits the scope in which it's defined, the bar() function has access to the a variable. Thus, this script should print out the string "foo" . We could translate it to roughly the following pseudo code: // first we create a global scope, that has no parents
let scope = newScope(null);

// then we set the variable `a` on the scope
declareVariable(scope, "a", "foo");

// now we define the  bar function saving a reference to the function
let func = function(parentScope: Scope, arguments: JSArguments, this: Any) -> Any {
  // inside a function declaration we start a new scope, but keeping
  // a reference to the parentScope
  let scope = newScope(parentScope);

  // now we translate console.log call retreiving the variable from the scope
  // this will search for the `a` variable on the current scope and all of the
  // parent scopes
  console.log(retrieve(scope, "a"));
}
// when running a function we have to consider the scope
// in which it was defined
let fObject = createFunctionObject(func, scope);
// and now we also set `bar` on the current scope
declareVariable(scope, "bar", fObject)

// now we need to fetch the `bar` function from the scop
// and run it
let f = retrieve(scope, "bar");
call(f); All of the helpers needed to make it work are hand written in WAT format. I have some ideas on how to make it more efficient, but before I can validate all the major features I didn't want to invest too much time into side quests. Writing WAT by hand is not that hard, too, especially when you consider WASM GC. License The code is licensed under Apache 2.0 license
======>
https://old.reddit.com/r/rust/comments/1gncdq4/cblt_a_safe_fast_and_minimalistic_web_server_in/
-->>-->>
To learn a new programming language, I use the following approach. First, I read a tutorial for that programming language, which explains the syntax, idioms, philosophy, and principles of how the language works. After that, I write a small pet project in that programming language. In the pet project, I practice a bit with the new language, its standard libraries, and popular frameworks.   

   To immerse myself deeper into the language, instead of a pet project, I start writing my own libraries for working with databases (ORM), JSON, actors, MVC web frameworks, logging, etc. These libraries are unlikely to be needed by anyone, but they help me better understand the programming language. Surprisingly, with Rust, I managed to write my own web server. I hadn't done this before. I think it's because Rust is a systems programming language, and it's not a sin to try optimizing performance with it.   

   In the end, I encountered that Rust does not have equivalents to Nginx, Lighttpd, Caddy, HAProxy, Apache, Tomcat, Jetty, etc. All these web servers are written in C, Go, Java, etc. There are only web frameworks: Actix, Axum, Rocket, Hyper, etc.   

   Overall, I figured out that I usually use Nginx for the following purposes:   

   
   TLS for domains   
   Proxying requests to the backend   
   Serving static files   
   

   As a result, I decided to write my own implementation of a web server in Rust.   

   The server supports a configuration file in the KDL (KDL Document Language) format. Here are examples of the "Cbltfile" configuration file for the Cblt web server:   

   Server File   
   kdl
"*:80" {
    root "*" "/path/to/folder"
    file_server
}
   

   File Server & Proxying   
   kdl
"127.0.0.1:8080" {
    reverse_proxy "/test-api/*" "http://10.8.0.3:80"
    root "*" "/path/to/folder"
    file_server
}
   

   TLS Support   
   kdl
"example.com" {
    root "*" "/path/to/folder"
    file_server
    tls "/path/to/your/domain.crt" "/path/to/your/domain.key"
}
   

   Currently, the Cblt web server can be launched in two ways: via Cargo or Docker.   

   Cargo   
   bash
cargo run --release
   

   Docker   
   bash
docker build -t cblt:0.0.3 .
docker run -d -p 80:80 --restart unless-stopped --name cblt cblt:0.0.3
   

   At the moment, I have achieved an acceptable speed for proxying static files.   

   I conducted a test with Apache Benchmark (ab) for 300 requests with 100 concurrent connections. Loading an image sized 5 MB from example.com/logo_huge.png.
   bash
ab -c 100 -n 300 http://example.com/logo_huge.png
   

   
   
   Percent   
   Cblt   
   Nginx   
   Caddy   
   
   
   
   50%   
   1956   
   1941   
   1768   
   
   
   75%   
   2101   
   2065   
   1849   
   
   
   100%   
   2711   
   2360   
   2270   
   
   

   Cblt   

   ```bash
igumn@lenovo MINGW64 ~/cblt (main)
$ docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS                 PORTS                                                       NAMES
0589d8f26d91   cblt:0.0.1            "./cblt"                 2 minutes ago   Up 2 minutes           0.0.0.0:80->80/tcp                                          cblt   

   igumn@lenovo MINGW64 ~/cblt (main)
$ ab -c 100 -n 300    http://example.com/logo_huge.png   
This is ApacheBench, Version 2.3 <$Revision: 1913912 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd,    http://www.zeustech.net/   
Licensed to The Apache Software Foundation,    http://www.apache.org/   

   Benchmarking example.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Finished 300 requests   

   Server Software:
Server Hostname:        example.com
Server Port:            80   

   Document Path:          /logo_huge.png
Document Length:        5122441 bytes   

   Concurrency Level:      100
Time taken for tests:   6.020 seconds
Complete requests:      300
Failed requests:        0
Total transferred:      1536745500 bytes
HTML transferred:       1536732300 bytes
Requests per second:    49.83 [#/sec] (mean)
Time per request:       2006.721 [ms] (mean)
Time per request:       20.067 [ms] (mean, across all concurrent requests)
Transfer rate:          249283.62 [Kbytes/sec] received   

   Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       2
Processing:  1293 1926 262.3   1956    2711
Waiting:        1  118 139.1     63     645
Total:       1293 1926 262.3   1956    2711   

   Percentage of the requests served within a certain time (ms)
  50%   1956
  66%   2027
  75%   2101
  80%   2127
  90%   2213
  95%   2394
  98%   2544
  99%   2597
 100%   2711 (longest request)
 ```   

   Nginx   

   ```bash
igumn@lenovo MINGW64 ~/cblt/benchmark/nginx (main)
$ docker ps
CONTAINER ID   IMAGE                 COMMAND                  CREATED         STATUS                  PORTS                                                       NAMES
37fbf1dac42b   nginx_srv             "/docker-entrypoint.…"   2 minutes ago   Up 2 minutes            0.0.0.0:80->80/tcp                                          nginx_srv   

   igumn@lenovo MINGW64 ~/cblt/benchmark/nginx (main)
$ ab -c 100 -n 300    http://example.com/logo_huge.png   
This is ApacheBench, Version 2.3 <$Revision: 1913912 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd,    http://www.zeustech.net/   
Licensed to The Apache Software Foundation,    http://www.apache.org/   

   Benchmarking example.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Finished 300 requests   

   Server Software:        nginx/1.27.2
Server Hostname:        example.com
Server Port:            80   

   Document Path:          /logo_huge.png
Document Length:        5122441 bytes   

   Concurrency Level:      100
Time taken for tests:   6.043 seconds
Complete requests:      300
Failed requests:        0
Total transferred:      1536804300 bytes
HTML transferred:       1536732300 bytes
Requests per second:    49.65 [#/sec] (mean)
Time per request:       2014.267 [ms] (mean)
Time per request:       20.143 [ms] (mean, across all concurrent requests)
Transfer rate:          248359.28 [Kbytes/sec] received   

   Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       2
Processing:  1387 1940 168.4   1941    2360
Waiting:        1  115  84.5     98     301
Total:       1387 1940 168.4   1941    2360   

   Percentage of the requests served within a certain time (ms)
  50%   1941
  66%   2024
  75%   2065
  80%   2088
  90%   2152
  95%   2201
  98%   2263
  99%   2317
 100%   2360 (longest request)
```   

   Caddy   

   ```bash
igumn@lenovo MINGW64 ~/cblt (main)
$ ab -c 100 -n 300    http://example.com/logo_huge.png   
This is ApacheBench, Version 2.3 <$Revision: 1913912 $>
Copyright 1996 Adam Twiss, Zeus Technology Ltd,    http://www.zeustech.net/   
Licensed to The Apache Software Foundation,    http://www.apache.org/   

   Benchmarking example.com (be patient)
Completed 100 requests
Completed 200 requests
Completed 300 requests
Finished 300 requests   

   Server Software:        Caddy
Server Hostname:        example.com
Server Port:            80   

   Document Path:          /logo_huge.png
Document Length:        5122441 bytes   

   Concurrency Level:      100
Time taken for tests:   5.440 seconds
Complete requests:      300
Failed requests:        0
Total transferred:      1536804000 bytes
HTML transferred:       1536732300 bytes
Requests per second:    55.14 [#/sec] (mean)
Time per request:       1813.469 [ms] (mean)
Time per request:       18.135 [ms] (mean, across all concurrent requests)
Transfer rate:          275858.99 [Kbytes/sec] received   

   Connection Times (ms)
              min  mean[+/-sd] median   max
Connect:        0    0   0.3      0       2
Processing:  1264 1749 191.1   1767    2270
Waiting:        1   96 104.7     67     467
Total:       1265 1749 191.1   1768    2270   

   Percentage of the requests served within a certain time (ms)
  50%   1768
  66%   1821
  75%   1849
  80%   1877
  90%   1955
  95%   2152
  98%   2226
  99%   2241
 100%   2270 (longest request)
```   

   I also plan to conduct tests for backend proxying; in general, I haven't yet tested the reverse proxy for performance.   

   Maybe this time my mini-project will interest someone? And this hobby will grow into something bigger?   

   If you're interested in looking at the code or contributing, here's the link to the repository:    https://github.com/evgenyigumnov/cblt   
   

======>
https://github.com/theiskaa/mdp
-->>-->>
Repository files navigation README MIT license mdp mdp is a versatile command-line tool and library designed to convert Markdown content into pre-styled PDF documents. It supports reading Markdown from a file or directly from a string, offering flexibility for both users and developers. This project includes both a binary and a library: Binary (cli) : A command-line interface that uses the core library to provide an easy way to convert Markdown to PDF. Library (lib) : Can be integrated into your Rust projects for parsing Markdown or generating PDF documents programmatically. Note: This project is currently under active development, with ongoing improvements and new features being added. Installation Currently, there isn't a simplified official method to install the command-line tool across platforms. To use it, you can clone the repository and build the project yourself using Cargo: git clone https://github.com/theiskaa/mdp.git cd mdp
cargo build --release Configuration The mdp tool supports customization through a TOML configuration file. You can configure various styling options for the generated PDFs by creating a mdprc.toml file in your home directory. To get started with configuration: Create the config file: touch ~ /mdprc.toml Copy the example configuration: View the example config at mdprc.example.toml Copy the contents to your ~/mdprc.toml file Modify the values according to your preferences The configuration file allows you to customize the appearance of your generated PDFs by defining styling options for different Markdown elements. Usage To use the mdp tool, you can either specify a Markdown file path, provide Markdown content directly, or set the output PDF path. Options -p , --path : Specify the path to the Markdown file to convert. -s , --string : Provide Markdown content directly as a string. -o , --output : Specify the output file path for the generated PDF. Examples Convert a Markdown file to a PDF: mdp -p " docs/resume.md " -o " resume.pdf " This will convert the resume.md file located in the docs folder to a PDF file named resume.pdf . Convert Markdown content provided as a string: mdp -s " # My Markdown Title\n\nThis is content. " -o " output.pdf " This will convert the provided Markdown string to a PDF file named output.pdf . Convert a Markdown file to a PDF with default output: mdp -p " file.md " This will convert the file.md to a PDF and save it as output.pdf . Notes If both -p and -s options are provided, the --path option will take precedence. If no output file is specified using the -o option, the default output file will be named output.pdf .
======>
https://github.com/actuate-rs/actuate
-->>-->>
Repository files navigation README Apache-2.0 license MIT license Actuate Examples A high-performance reactive user-interface framework for Rust.
This crate provides a generic library that lets you define UI using declarative, borrow-checker friendly syntax. use actuate :: { use_mut , Compose , Data , Memo , Mut , Scope } ; # [ derive ( Hash , Data ) ] struct Button < ' a > { count : Mut < ' a , i32 > , } impl Compose for Button < ' _ > { fn compose ( cx : Scope < Self > ) -> impl Compose { cx . me ( ) . count . update ( |x| * x += 1 ) } } # [ derive ( Data ) ] struct Counter { initial : i32 , } impl Compose for Counter { fn compose ( cx : Scope < Self > ) -> impl Compose { let count = use_mut ( & cx , || cx . me ( ) . initial ) ; dbg ! ( *count ) ; ( Memo :: new ( Button { count } ) , Button { count } ) } } # [ tokio :: main ] async fn main ( ) { actuate :: run ( Counter { initial : 0 } ) . await ; } Inspiration This crate is inspired by Xilem and uses a similar approach to type-safe reactivity. The main difference with this crate is the concept of scopes, components store their state in their own scope and updates to that scope re-render the component. State management is inspired by React and Dioxus .
======>
https://www.circle-lang.org/interop.html
-->>-->>
Building Bridges to C++ Document #: Date: 2024-11-8 Project: Programming Language C++ Audience: Reply-to: Sean Baxter < seanbax.circle@gmail.com > Contents 1 Motivation 2 C
interoperability 3 C++
interoperability 4 Three categories for
interop 5 Wide coverage for Rust
interop 5.1 Using Rust from
C++ 5.2 Using C++ from
Rust 5.3 The std::string
tragedy 5.4 Swift’s coverage
tradeoffs 6 Exception handling 6.1 How C++
unwinds 6.2 How Rust
unwinds 6.3 RTTI 7 Delivering
safety 1 Motivation Companies ship software that contains security vulnerabilites to
millions of customers. For C++ products, 70% of those vulnerabilities
would be stopped by a memory-safe language. There’s growing pressure to
move off memory-unsafe languages and onto safe languages like Rust,
Swift, Java and C#. The US Government is calling for safety
roadmaps from big vendors outlining how they’ll migrate to
memory-safe languages for new code. The deadline for these roadmaps is
coming up: January 1 2026. What can be done to hasten the migration to safe
coding ? I proposed the Safe C++ extension. This overhauls Standard C++ with memory safety capabilities.
It implements the same borrow-checking technology as featured in Rust.
This is one path for C++ projects to start writing memory-safe code. A second viable path to safety is through improved Rust interop. The
recent study Eliminating
Memory Safety Vulnerabilities at the Source demonstrates that old
production code contains fewer vulnerabilities than new code. Time has
debugged it. Consequently, the best way to reduce vulnerabilities is to
put existing code in maintenance mode and write new code in a
memory-safe language. This document explores an idea for dramatically
reducing interop friction between C++ and Rust. If it’s easy to use C++
code from Rust, developers will be more open to making the
transition. This strategy adds a lot of features to C++. It would require some
extensions to Rust as well. While any new feature is in tension with a
language’s desire to remain compact and teachable, there’s a powerful
commercial incentive pushing the other way: making it easy to
incorporate Rust into C++ projects will draw new users and resources to
Rust, help developers meet government mandates and improve software
quality for everybody. 2 C interoperability Operating systems expose functionality through C APIs. Standard
libraries, for any language, are built atop these system APIs.
Interoperability with C is very easy for language developers. There’s no
overloading of declarations. There are no templates or generics. Structs
have straight-forward layout rules that are no challenge to
implement. For the purpose of compilers, C’s ABI is just the parameter-passing
convention of the platform your program targets. Unix-like systems
follow the ELF object file conventions. Each CPU architecture has an ELF
or System V supplement that specifies struct layouts, parameter passing
and object file definitions. x86-64 x86-32 IA64 ARM MIPS Compilers implement these processor-specific conventions. With
x86-64, for example, this entails recursively categorizing the fields of
structs that appear as function parameters into POINTER , INTEGER and SSE classes and mapping those
classes to available general-purpose and SSE2 registers. It’s fairly
involved and in the weeds, but C abstracts these concerns from the user.
If you code against the C language, your software should compile for
many operating systems and hardware architectures. Languages provide a way to define C-layout structs. Compilers
implement the parameter-passing conventions for each target. Voilà. C
interoperability. 3 C++ interoperability To call C functions, you don’t need much. To call C++ functions you
need all the intelligence of a C++ frontend. There are a lot of factors
that contribute to making C++ interoperability a colossal challenge. C++ functions can overload . Which function candidate does a
call expression select? That requires overload resolution , an
extremely complicated process for finding the best viable
candidate . How are function templates considered? That requires argument
deduction , specialization and substitution . Very
complicated subsystems. Function parameters bind arguments using implicit conversion
sequences . Conversion sequences may invoke user-defined conversions
or copy constructors, and those may require argument deduction , specialization and substitution . It’s not feasible to express C++ function declarations in other
languages, because C++ function declarations may involve almost every
feature in the language. Dependent expressions appear in array bounds, requires-clauses and noexcept-specifiers . Expressions
also appear in unevaluated contexts , such as decltype-specifiers , sizeof-operator , alignof-operator and noexcept-operator . These
expressions may require overload require resolution, argument deduction
and substitution to evaluate. How do you distinguish overloaded declarations? You need name
mangling , which stringifies many parts of a function declaration to
prevent different overloads from colliding in the binary. C++ is a big knot that can’t be untangled. If each language feature
is hitch or bend, tugging at one concern just tightens the others. 4 Three categories for interop Let’s examine and three facets of a solution to the interop
challenge: Discovery - Declarations from language A are shared
with language B and vice versa. This includes structs with their
layouts, function declarations, type aliases and global objects. ABI
concerns like mangled names are also part of data discovery. Intelligence - Language A needs access to the
semantics of language B. If you want to call a C++ function, you need argument-dependent lookup , overload resolution , argument deduction , substitution and so on. Rather
than language A implementing this complex logic, it gets provided across
toolchains by language B. Coverage - Interoperability requires some overlap
in language support. To facilitate C interop, the other language must
support structs, C-style enums and pointers to data and functions.
Extending coverage increases the surface area of interoperability. A C++
frontend with support for Rust-style enums
( choice types in Safe C++ parlance)
has access to more Rust APIs than a frontend without that support. Expose compiler functionality through an API. Using the API, point
the compiler at a module or header file to parse it and return a
metadata tree of declarations. That’s discovery . Submit a
query, such as request for the primary, partial or explicit
specialization of a class template and retrieve a result. That’s
intelligence . This compiler-as-library is a language
server . Rust and C++ compilers can share data and intelligence by
utilizing one another as language servers. Extend Rust with lvalue- and rvalue-references. Permit non-trivial
moves by calling a relocation function rather than memcpying the data.
If Rust has the capability to form lvalue and xvalue expressions
(i.e. expressions with lvalue- and rvalue-reference types) and to call
move constructors, it can start utilizing C++ code. Extend C++ with
first-class borrow types, lifetime parameters, choice types, Rust traits and a safe-specifier . This extends the amount of Rust functionality
that can be used from C++. That’s coverage . Discovery and intelligence is
served across toolchains using language servers. Coverage widens capabilities within a toolchain with
language extensions. 5 Wide coverage for Rust interop In the Safe C++ proposal
I introduced a new std2 standard
library. The containers are designed with borrows, lifetime parameters
and relocation semantics to provide rigorous memory safety. But the
excellent Eliminating
Memory Safety Vulnerabilities at the Source study out of Google made
me reconsider this design choice. The study makes a strong case that
rather than worrying about rewriting C++ code, the best strategy for
improving software quality is to focus on a quick transition to
memory-safe languages. If the goal is safety within C++, you’ll need a new std2 safe standard library. If the goal is reduced C++/Rust interop friction, build the
infrastructure on the C++ side to use Rust’s standard library
directly. Extending C++ to natively use Rust’s standard library
directly improves interoperability. 5.1 Using Rust from C++ Consider using the discovery, intelligence and coverage facets to
model a toolchain where Rust declarations can be used from directly C++
without bridge code: Discovery: A C++ file imports a Rust module into a C++ namespace.
The Rust language server parses the module code and returns metadata of
all parsed declarations. Rust has a different layout scheme than C++,
and only structs marked with # [repr(C)] are guaranteed compatible with C layout. Therefore, struct layout is
part of the discovery data. Coverage: The C++ frontend injects these declarations into the
requested namespace, making them available for qualified lookup. Name
lookup is natively supported by C++ and doesn’t require use of a
language server. Coverage: C++ code can define functions originally declared on the
Rust side. Safe C++ already has a safe-specifier , borrow types
and lifetime parameters with outlives-constraints . Intelligence: Lowering C++ functions generates AST which lowers to
MIR. The MIR is vetted for safety by the borrow checker. MIR lowers to
LLVM bitcode, which generates object code. Declarations in Rust which
are ODR-used by the C++ side are transmitted back to the Rust compiler
through its language server. Rust must provide definitions for these
declarations to satisfy the linker. Prioritize a list of features to improve C++’s coverage with Rust
entities: Borrows
types and operators ^ and ^ const to form borrow-valued expressions. Lifetime parameters and outlives-constraints . safe-specifier .
This is the default in Rust, but it’s opt-in in C++. The absence of safe-specifier is equivalent to unsafe-specifier in
Rust. Safe C++ also includes an unsafe-block to escape the safe context. self function parameters or
non-static member functions marked with a rel-qualifier to
enable self-consuming functions. choice types have the same capabilites as Rust enum .
They’re compatible types: the result object in C++ when calling a Rust
function that returns an enum is a choice type. For niche
optimizations, discovery tells the C++ side about the layout of enum and
tells the Rust side about the layout of choice . C++ needs pattern matching
to use choice types. Zero-sized
types (ZSTs). They’re common in Rust, and the absence of support in
C++ has resulted in perplexing abuses of tail padding optimizations.
Coverage is necessary for language interop. Rust-compatible first-class tuples. Circle already has first-class
tuples , but they should be adapted to conform to Rust’s struct
layout for interoperability. Rust-compatible slices
and arrays . These are already implemented in Safe C++ with the
syntax [ T; dyn ] and [ T; N ] . There must be C++ coverage for Rust’s trait and impl . It may be necessary to use
qualified names to call trait functions in C++, eg obj . TraitName :: funcName () . These are profound extensions to C++. Existing compilers need all-new
mid-level IR subsystems to perform non-lexical initialization analysis
and borrow checking. Additionally, ingesting Rust standard library and
all Rust code is a big shift for C++ projects. 5.2 Using C++ from Rust Let’s go in the other direction and use C++ entities from Rust: Discovery: A Rust module imports a C++ header. The C++ language
server parses the header’s text and returns metadata of all parsed
declarations. Coverage: The Rust frontend injects the supported declarations into
the requested namespace, making them available for qualified
lookup. Intelligence: Rust code can use C++ types and functions. If it wants
to specialize a class template or call a member function on a C++
object, it uses the C++ language server to perform specialization or
overload resolution. While it’s possible to build C++ semantics directly
into a Rust frontend, that is a big lift. A language server provides the
same result for your function call without the immense cost in tooling
development. Intelligence: Lowering a Rust function generates MIR which lowers to
LLVM bitcode. C++ declarations that are ODR-used are transmitted back to
the C++ side through the language server. The C++ compiler generates
those definitions in LLVM bitcode or object code. The linker
incorporates both the C++ and Rust definitions in the same crate. Prioritize a list of features to improve C++’s coverage with Rust
entities. This is more modest than the C++ extensions, because there’s a
desire maintain the relative simplicity of Rust. The C++ coverage can be
considered an interop extension rather than “core language.” Lvalue- and rvalue-reference types and operators to form
reference-valued expressions. These are non-null unsafe pointer types.
They may be implemented as primitives or as library types with compiler
magic to hook into interop support. These types are necessary for
overload resolution. For example, std :: vector has two push_back overloads. One
takes a const T & value and the other takes T && value .
The former overload copies the parameter and the latter overload moves
it. Efficient usage of C++ requires differentiation between
lvalue-reference accepting functions and rvalue-reference accepting
functions. The addition of lvalue- and rvalue-references don’t imply any
change to Rust’s object model. Non-trivial relocation functions. For C++ classes with non-trivial
move constructors, the relocation function move-constructs into the
target and runs the destructor on the source. This corresponds to operator rel relocation
constructor in Safe C++. noexcept-specifier on function types and declarations. This
is to accurately match functions declared with a noexcept-specifier on the C++ side. Without this capability,
we’d fail to support Rust definitions of non-throwing functions. noexcept-specifier is something Rust would benefit from
generally, especially in builds where panics abort, because it increases
the distance between potential throws which promotes the ability to relocate
out of references . And it generates smaller code. Function overloading in the C++ namespace. We won’t be able to define in Rust all functions previously declared
in C++, since some function prototypes involve language entities that
extended Rust doesn’t have coverage for. Overloading is supported, but
templates aren’t. But that should be okay. You can still use C++ types and functions directly from Rust. The C++ language server is
responsible for evaluating the semantics around function calls and
template specializations. 5.3 The std::string tragedy Almost all C++ container types are trivially relocatable without
knowing it. Important types like unique_ptr , shared_ptr and vector are trivially relocatable.
Their declarations could be marked with a [[ trivially_relocatable ]] attribute for compatibility with Rust’s relocation semantics. Unfortunately, the libstdc++ version of std :: string is not trivially relocatable. It implements a small-string optimization
that maintains a pointer back into its own storage. Move construction
and move assignment reset the small-string pointer back to local
storage. Trivial relocation would leave a dangling pointer. The idea was
to get rid of a branch when calling the std :: string :: data () member function. But this optimization makes for a pretty wasteful
implementation. std :: string weighs 32 bytes
( std :: vector is 24 bytes) but only has a local capacity for strings of 15 characters
or fewer. This is not the first troublesome string. There was a previous
libstdc++ std :: string that used copy-on-write to deliver cheap string copies. This was no good, because using the
non-const operator [] function would technically invalidate the string, spawning a copy of the
data if the string didn’t have exclusive ownership. (A pity. Why are you
even allowed to modify strings like that?) The move away from the copy-on-write string was one of the few ABI
breaks in C++ history. Rust’s avoidance of a stable ABI makes it easier
to change library implementations to satisfy new requirements. But C++
has a stable ABI, for better or worse, and you have to play it as it
lays. Thanks to std :: string and the transitive property of containment, non-trivial relocation is a
necessary buy-in for Rust to support move semantics for many C++
types. 5.4 Swift’s coverage tradeoffs The Swift team has been working for several years improving C++
interop. Their effort also embeds a C++ compiler (which is Clang) into the Swift toolchain.
There’s no way to interop with C++ without embedding a C++ frontend. The question of how much C++ coverage to incorporate in Swift is one
that the engineers are wrestling with. Functions and constructors that use r-value reference types are not
yet available in Swift. Swift supports calling some C++ function templates. Any function or function template that uses a dependent type in its
signature, or a universal reference (T &&) is not available in
Swift. Any function template with non-type template parameters is not
available in Swift. Variadic function templates are not available in Swift. – Supported
C++ APIs The Swift language remains slightly smaller at the cost of not being
able to use a large amount of C++. Without access to move semantics,
it’s really not able to use any of it efficiently. Is this tradeoff
worth it? I don’t think so. I don’t advocate a maximalist approach to
extending Rust with C++ capabilities (although I do favor maximalism in
the other direction), but I am convinced that a few strategic extensions
to Rust will have enormous payoff for a quality interop experience. Enumerations that have an enumeration case with more than one
associated value [are not yet supported] – Swift
Enumerations Supported by C++ Swift didn’t extend its embedded C++ compiler with first-class enum
types. Therefore, the C++ side can’t use Swift enums with more than one
associated value. Enums are a flagship feature for both Rust and Swift.
I think it’s worth it to extend the C++ side to fully support them. Safe
C++ has first-class choice types with pattern matching. While maintaining these extensions is a
burden for C++ tooling engineers, the goal of interop isn’t to make
their life easier, it’s to make everyone else’s life easier. 6 Exception handling C++ exception handling is a major source of friction when dealing
with Rust interop. But it doesn’t have to be. Rust is 99% of the way to
supporting C++ exceptions. When compiled with - C panic = unwind ,
which is the default, Rust functions are all potentially
throwing . When lowered to MIR and then to LLVM, function calls have
a normal edge leading to the next statement and a cleanup
edge that catches the exception, calls the destructor for all
in-scope objects with non-trivial drops, and resumes unwinding.
This is exactly what C++ does. 6.1 How C++ unwinds (Compiler Explorer) struct HasDtor { int i; ~ HasDtor () { } } ; // Potentially throwing. (i.e. not noexcept) void may_throw () { } int func () { HasDtor a { } ; // On the cleanup edge out of may_throw, run a's dtor. may_throw () ; return 1 ; } define dso_local noundef i32 @func ()() # 0 personality ptr @__gxx_personality_v0 !dbg ! 15 { %1 = alloca %struct.HasDtor , align 4 %2 = alloca ptr, align 8 %3 = alloca i32 , align 4 call void @llvm.dbg.declare ( metadata ptr %1 , metadata ! 20 , metadata !DIExpression()), !dbg ! 28 %4 = getelementptr inbounds %struct.HasDtor , ptr %1 , i32 0 , i32 0 , !dbg ! 29 store i32 1 , ptr %4 , align 4 , !dbg ! 29 invoke void @may_throw ()() to label %5 unwind label %6 , !dbg ! 30 5 : call void @HasDtor ::~HasDtor()(ptr noundef nonnull align 4 dereferenceable( 4 ) %1 ) # 4 , !dbg ! 31 ret i32 1 , !dbg ! 31 6 : %7 = landingpad { ptr, i32 } cleanup, !dbg ! 31 %8 = extractvalue { ptr, i32 } %7 , 0 , !dbg ! 31 store ptr %8 , ptr %2 , align 8 , !dbg ! 31 %9 = extractvalue { ptr, i32 } %7 , 1 , !dbg ! 31 store i32 %9 , ptr %3 , align 4 , !dbg ! 31 call void @HasDtor ::~HasDtor()(ptr noundef nonnull align 4 dereferenceable( 4 ) %1 ) # 4 , !dbg ! 31 br label %10 , !dbg ! 31 10 : %11 = load ptr, ptr %2 , align 8 , !dbg ! 31 %12 = load i32 , ptr %3 , align 4 , !dbg ! 31 %13 = insertvalue { ptr, i32 } poison, ptr %11 , 0 , !dbg ! 31 %14 = insertvalue { ptr, i32 } %13 , i32 %12 , 1 , !dbg ! 31 resume { ptr, i32 } %14 , !dbg ! 31 } declare i32 @__gxx_personality_v0 (...) In C++, in-scope objects with non-trivial destructors are destroyed
by the cleanup block. Here the cleanup block is 6 . The landingpad instruction advertises
its intent to cleanup in-scope
objects. The cleanup block copies out a { ptr, i32 } pair, which indicates the exception object, calls HasDtor ’s destructor, and resumes on that cached pair. Since
the function participates in exception handling it is associated with __gxx_personality_v0 , C++’s standard personality function , which abstracts some even lower-level
exception-handling APIs. 6.2 How Rust unwinds struct HasDtor { i : i32 } impl Drop for HasDtor { fn drop( & mut self ) { } } // Potentially throwing. (i.e. not noexcept) fn may_throw() { } fn func() -> i32 { let _a = HasDtor { i : 1 }; // On the cleanup edge out of may_throw, run a's dtor. may_throw() ; return 1 ; } define internal i32 @_ZN5throw4func17hd08044f7eb69f50cE () unnamed_addr # 1 personality ptr @rust_eh_personality { start: %0 = alloca [ 16 x i8 ], align 8 %_a = alloca [ 4 x i8 ], align 4 store i32 1 , ptr %_a , align 4 ; invoke throw::may_throw invoke void @_ZN5throw9may_throw17hb8b8ce4f5b598848E () to label %bb1 unwind label %cleanup bb3: ; preds = %cleanup ; invoke core::ptr::drop_in_place<throw::HasDtor> invoke void @"_ZN4core3ptr35drop_in_place$LT$throw..HasDtor$GT$17hcc21909492c17e73E" (ptr align 4 %_a ) # 5 to label %bb4 unwind label %terminate cleanup: ; preds = %start %1 = landingpad { ptr, i32 } cleanup %2 = extractvalue { ptr, i32 } %1 , 0 %3 = extractvalue { ptr, i32 } %1 , 1 store ptr %2 , ptr %0 , align 8 %4 = getelementptr inbounds i8 , ptr %0 , i64 8 store i32 %3 , ptr %4 , align 8 br label %bb3 bb1: ; preds = %start ; call core::ptr::drop_in_place<throw::HasDtor> call void @"_ZN4core3ptr35drop_in_place$LT$throw..HasDtor$GT$17hcc21909492c17e73E" (ptr align 4 %_a ) ret i32 1 terminate: ; preds = %bb3 %5 = landingpad { ptr, i32 } filter [ 0 x ptr] zeroinitializer %6 = extractvalue { ptr, i32 } %5 , 0 %7 = extractvalue { ptr, i32 } %5 , 1 ; call core::panicking::panic_in_cleanup call void @_ZN4core9panicking16panic_in_cleanup17hb5e4521fe5c4d68fE () # 6 unreachable bb4: ; preds = %bb3 %8 = load ptr, ptr %0 , align 8 %9 = getelementptr inbounds i8 , ptr %0 , i64 8 %10 = load i32 , ptr %9 , align 8 %11 = insertvalue { ptr, i32 } poison, ptr %8 , 0 %12 = insertvalue { ptr, i32 } %11 , i32 %10 , 1 resume { ptr, i32 } %12 } declare i32 @rust_eh_personality ( i32 , i32 , i64 , ptr, ptr) unnamed_addr # 1 Rust does all the same cleanup as C++. In fact, it does more
cleanup , because even its destructors are potentially throwing. C++
destructors are implicitly noexcept . In
this Rust example, the cleanup block is called cleanup . The landingpad instruction expresses the cleanup handler and caches the same { ptr, i32 } pair. The cleanup code branches to bb3 which calls HasDtor ’s destructor. But that
destructor is also potentially throwing. If the destructor
throws, it’s non-recoverable, since we’re already on the cleanup path.
That cleanup edge jumps to the terminate block which calls core :: panicking :: panic_in_cleanup .
That function prints “panic in a destructor during cleanup” and aborts.
The normal path out of the destructor branches to bb4 which resumes stack
unwinding. If you look closely you may one salient difference: Rust uses the rust_eh_personality personality
function. This is closely modeled on the C++ version: rust_eh_personality_impl . If Rust’s personality function is actually incompatible with
C++ cleanup (I don’t know if it is or not), it can be replaced by __gxx_personality_v0 . Additionally,
for consistency with C++ exceptions, Rust’s panic objects could be
allocated with __cxa_allocate_exception , the same
storage that backs C++ exceptions. That’s part of libc++abi . 6.3 RTTI (Compiler Explorer) struct S { int i; } ; void throw_it () { throw S { 10 } ; } int main () { try { throw_it () ; } catch ( S s ) { } catch ( int i ) { } } %struct.S = type { i32 } $_ZTS1S = comdat any $_ZTI1S = comdat any @_ZTVN10__cxxabiv117__class_type_infoE = external global [ 0 x ptr] @_ZTS1S = linkonce_odr dso_local constant [ 3 x i8 ] c "1S\00" , comdat, align 1 @_ZTI1S = linkonce_odr dso_local constant { ptr, ptr } { ptr getelementptr inbounds (ptr, ptr @_ZTVN10__cx xabiv117__class_type_infoE, i64 2 ), ptr @_ZTS1S }, comdat, align 8 @_ZTIi = external constant ptr ; Function Attrs: mustprogress noinline optnone uwtable define dso_local void @_Z8throw_itv () # 0 { %1 = call ptr @__cxa_allocate_exception ( i64 4 ) # 4 %2 = getelementptr inbounds %struct.S , ptr %1 , i32 0 , i32 0 store i32 10 , ptr %2 , align 16 call void @__cxa_throw (ptr %1 , ptr @_ZTI1S , ptr null ) # 5 unreachable } C++ uses RTTI typeinfo data to identify the type of a thrown
exception. The throw-expression passes a pointer to _ZTS1S to __cxa_throw . That’s the RTTI
typeinfo structure for class S . %8 = landingpad { ptr, i32 } catch ptr @_ZTI1S catch ptr @_ZTIi %9 = extractvalue { ptr, i32 } %8 , 0 store ptr %9 , ptr %2 , align 8 %10 = extractvalue { ptr, i32 } %8 , 1 store i32 %10 , ptr %3 , align 4 br label %11 The try-statement in main indicates the RTTI typeinfo data
for all of its catch-clauses . Rust doesn’t exactly conform to
this convention. Does that create interoperability problems? I’m not
sure. It is the case that C++ can’t catch panic objects. But this is
easy to resolve: emit a C++ RTTI typeinfo struct for the Rust panic type
and point __cxa_throw at that. This
is a very minor change, if it is necessary at all. We can unstick one of interop’s most irritating sticking points. C++
exceptions will propagate safely through Rust frames, properly
destroying all in-scope objects. As far as the ability to catch C++
exceptions, coverage could be added to Rust. But since that’s already
part of C++, you may as well do it there: write your catch / throw handler on the C++ side. Interop will let you return Result or any other Rust type. 7 Delivering safety It would be useful to have a textual representation for C++ code in
Rust and Rust code in C++. It would be truly ideal for a single
toolchain do everything: imagine implementing a full C++ frontend inside rustc . There’d be a single type
system and single AST to express entities from both languages. But that’s not where we are and absolutely seamless tooling isn’t
really the goal. Our aim is to accelerate the migration from
memory-unsafe to memory-safe languages. Both the C++ and Rust frontends
can gradually push out coverage to be less reliant on one another’s
language servers. But in the short term, utilizing two frontends in one
toolchain can help reduce interop friction and improve code quality. Adopting Rust’s standard library as the de-facto standard library in
a two-language project is the right design. While C++’s unsafe standard
library can be used from Rust, perhaps with less-than-seamless
ergonomics (thanks to every function being unsafe ), the goal is to write
safe code with safe containers , not write more unsafe code with
unsafe containers. Providing a juiced-up version of C++, which is essentially a superset
of Rust, lends developers a lot of freedom for interfacing new and old
code. The language boundary isn’t a hard boundary. Rust types can
permeate into the C++ side and C++ types can permeate into the Rust
side. And that is possible without any interop annotations . I like the idea of bi-directional language servers. I have a liberal
attitude towards bold, comprehensive language extensions to increase
interop surface area. Reducing interop friction is the best chance for
quickly drawing C++ developers to a memory-safe toolchain.
======>
https://mergiraf.org/introduction.html
-->>-->>
Light Rust Coal Navy Ayu Mergiraf document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    }); Are you held back by conflicts? Then meet Mergiraf Mergiraf can solve a wide range of Git merge conflicts . That's because it's aware of the trees in your files!
Thanks to its understanding of your language , it can often reconcile the needs of both sides. You can teach Mergiraf a new language in a completely declarative way. It's a nonviolent animal, so it prefers that over imperatives. Demo Configure Git to use Mergiraf instead of its default merge heuristics. This will enhance git merge , revert , rebase , cherry-pick and more. Renamed from /home/user/.local/share/mergiraf/merges/Parser.java_o0i2JL8B/line_based.java to /h ome/user/.local/share/mergiraf/merges/Parser.java_o0i2JL8B/structured_resolution.java 1 1 <<<<<<< HEAD 2 . import java.lang.IllegalArgumentException; 3 2 import org.codeberg.musicparser.Formats; 4 . ||||||| parent of 23d19ad (Commit on my_branch) 5 . import java.lang.IllegalArgumentException; 6 . 
======= 7 . >>>>>>> 23d19ad (Commit on my_branch) 8 3 import org.testng.annotations.Test; 9 4 10 5 class ParserTests { /home/user/.local/share/mergiraf/merges/Parser.java_o0i2JL8B/structured_resolution.java --- 2/2 --- Text (13 Java parse errors, exceeded DFT_PARSE_ERROR_LIMIT) 15 void parseValidInput() throws Exception 10 void parseValidInput() throws Exception .. { .. { 16 String input = "fis g a b a b g c b 11 String input = "fis g a b a b g c b .. c a d es d c"; .. c a d es d c"; 17 12 18 <<<<<<< HEAD 13 Melody melody = SUT.parse(input, For .. .. mats.LILYPOND); 19 Melody melody = null; .. 20         try { .. 21             melody = SUT.parse(input, Format .. .. s.LILYPOND); .. : 00:00 -00:16 Fullscreen (f) AsciinemaPlayer.create('asciinema/session.cast', document.getElementById('review_session_cast'), {
   poster: 'npt:0:11',
   preload: true
 }); You can also keep Git's original behaviour and manually invoke Mergiraf after encountering conflicts. ➜ repo git:( refactor ) ✗ git rebase master Auto-merging src/lawnmower.rs CONFLICT (content): Merge conflict in src/lawnmower.rs error: could not apply 162e8a1... Refactor and max_speed hint: Resolve all conflicts manually, mark them as resolved with hint: "git add/rm <conflicted_files>", then run "git rebase --continue". hint: You can instead skip this commit: run "git rebase --skip". hint: To abort and get back to the state before "git rebase", run "git rebase --abort". hint: Disable this message with "git config advice.mergeConflict false" Recorded preimage for 'src/lawnmower.rs' Could not apply 162e8a1... Refactor and max_speed ➜ repo git:( fc19ba6 ) ✗ vim src/lawnmower.rs ➜ repo git:( fc19ba6 ) ✗ mergiraf solve src/lawnmower.rs 00:00 -00:25 Fullscreen (f) AsciinemaPlayer.create('asciinema/solve.cast', document.getElementById('solve_cast'), {
   poster: 'npt:0:19.5',
   preload: true
 }); Figure 1: Two git users making inadequate use of blame , push and pull to resolve a conflict Ready to give it a try? Head to the installation page and start merging nonviolently today! Aspirations Mergiraf is designed with your needs in mind. Its goals are: Don't sweep conflicts under the rug Syntax-aware merging heuristics can sometimes be a bit too optimistic in considering a conflict resolved. Mergiraf does its best to err on the side of caution and retain conflict markers in the file when encountering suspicious cases. If it manages to resolve all conflicts on its own, it encourages you to review its mediation work via the mergiraf review command.
If a merge looks faulty, you can report it easily . Be fast enough for interactive use Figure 2: Mergiraf offers to mediate Did you know that giraffes can run as fast as 60 kilometers per hour? Anyways. The operation of merging diverging versions of files happens routinely when working on a code base, often without you noticing as long as there aren't any conflicts. So Mergiraf tries to be quick so as not to interrupt you in your tasks. Be open to other methods In many cases, line-based merging works just great and there is no need for tree-munging business. If a line-based merge is conflict-free, then Mergiraf just returns that merge (which is very quick).
One exception to this rule is when line-based merging creates duplicate keys . In such a case, Mergiraf does a bit more work to resolve the issue or highlight it to you with conflict markers. Figure 3: Harmony and peace reign on Earth Illustrations by Freya F-T , CC-BY 4.0 .
======>
https://old.reddit.com/r/rust/comments/1gnkws1/buildyourown_ide/
-->>-->>
https://preview.redd.it/nx7fuwk04yzd1.png?width=3022&format=png&auto=webp&s=3ab0711e50bee1a14dae47a3a05d159553355177   

   As promised from a week ago, I've uploaded my Rust-based IDE server code to GitHub. Thanks to everyone who showed interest!   

   This is a Rust-based IDE server that lets you build whatever frontend you want. Web, terminal, VR, AI whatever. The server handles all the heavy lifting (file operations, LSP, etc.) through a simple WebSocket API.   

   GitHub:    https://github.com/JaLnYn/websocket-ide   

   Current state:   

   
   Basic file operations working   
   LSP support (completion, hover, go-to-def (only tested for "rust-analyzer"))   
   Real-time file watching   
   

   I'm very much a beginner when it comes to IDE architecture, so I'd love to get feedback on:   

   
   Code structure   
   Performance bottlenecks   
   Missing features   
   Security considerations   
   Really, anything you think could be better   
   

   Want to help build something cool? Here's how:   

   
   Try building a frontend - CLI, web, whatever interests you. I would really appreciate feedback on how to make the api more use-friendly.   
   Open issues for bugs or missing features you find   
   Share your ideas for what you'd build with this!   
   Star the repo if you want to keep track of updates :)   
   

   I'd love to see what creative interfaces people come up with.   

   Also open to name suggestions. "websocket-ide" isn't very creative 😅   
   

======>
https://old.reddit.com/r/rust/comments/1gnhfdr/minecraft_mods_in_rust/
-->>-->>
Violin.rs    allows you to easily build Minecraft Mods in Rust!   

   Our Github can be found here    bedrock-crustaceans/violin_rs   

   We also have a    Violin.rs Discord   , feel free to join it for further information and help!   

   The following code demonstrates how easy it is be to create new unqiue 64 swords via    Violin.rs   

   for i in 1..=64 {
    pack.register_item_texture(ItemTexture::new(
        format!("violin_sword_{i}"),
        format!("sword_{i}"),
        Image::new(r"./textures/diamond_sword.png").with_hue_shift((i * 5) as f64),
    ));

    pack.register_item(
        Item::new(Identifier::new("violin", format!("sword_{i}")))
            .with_components(vec![
                ItemDamageComponent::new(i).build(),
                ItemDisplayNameComponent::new(format!("Sword No {i}\n\nThe power of programmatic addons.")).build(),
                ItemIconComponent::new(format!("violin_sword_{i}")).build(),
                ItemHandEquippedComponent::new(true).build(),
                ItemMaxStackValueComponent::new(1).build(),
                ItemAllowOffHandComponent::new(true).build(),
            ])
            .using_format_version(SemVer::new(1, 21, 20)),
    );                                                                                       
}       
   

   This code ends up looking surprisingly clean and nice!     

   Here is how it looks in game, we've added 64 different and unique swords with just a few lines of code.. and look they all even have a different color   

   https://preview.redd.it/2xijaknh9xzd1.png?width=1425&format=png&auto=webp&s=1a3ca8c37ff22854faea9a3a31f1f21dbe779658   

   Any suggestions are really appreciated! Warning this is for Minecraft Bedrock, doesn't mean that it is bad or not worth it.. if this makes you curious, please give it a shot and try it out!   

   We are planning on adding support for a lot more, be new blocks and mbos or use of the internal Scripting-API   

   We are also interested in crafting a Javascript/Typescript API that can generate mods easier and makes our tool more accessible for others!   

   This is a high quality product made by the    bedrock-crustaceans    (   bedrock-crustaceans discord   )   
   

======>
https://old.reddit.com/r/rust/comments/1gn74mu/rust_std_we_abort_because_such_a_program_is/
-->>-->>
https://preview.redd.it/o2hw3zsipuzd1.png?width=770&format=png&auto=webp&s=0aa9635e75eb3b99327822f7bf579cb5071cd407   

   https://github.com/rust-lang/rust/blob/957f6c3973ea4680f3b0917092252c30eeb2404e/library/alloc/src/sync.rs#L2152-L2155   

   "degenerate" doesn't do this justice. You'd have to clone an    Arc    9,223,372,036,854,775,807 times before you hit this case, each time using    std::mem::forget    on the new strong handle. Some ballpark math puts the amount of time required to do this between 2.5 and 12 years of all cores on a CPU running    rayon    or similar, cloning and forgetting    Arc   s.   

   I'm mostly just amazed the Rust team handled this case at all. Imagine the astonishment of the branch predictor when after 10 straight years of running one branch, it's suddenly flushing the pipeline for one final iteration.   

   What's even crazier is that it's still possible to trigger UB with this function, assuming you can clone the Arc 9,223,372,036,854,775,807 times within about 5 clock cycles at best (between the    fetch_add    and    abort    call, separated only by    if old_size > MAX_REFCOUNT   ).   

   Edit:    u/plugwash    pointed out this is only inconceivable for 64bit systems which I failed to realize. On a 32bit system, it could only take a few minutes to do this (though triggering UB is still improbable, even on 16bit systems).   
   
