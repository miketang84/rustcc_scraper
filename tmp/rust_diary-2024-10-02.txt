https://www.reddit.com/r/learnrust/s/x4yooOoUy0
-->>-->>
Related Rust Programming open-source software Technology Free software Software Information & communications technology forward back r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Rust to .NET compiler - end of GSoC, what now? 181 upvotes Â· 19 comments r/technicalwriting r/technicalwriting For people who take the unbelievably complicated things that scientists and engineers devise and make it understandable for non-technical people. 32K Members 16 Online WYSIWYG GUI Markdown editor 2 upvotes Â· 4 comments r/chromeos r/chromeos The largest independent, community-run forum for discussions related to Chromebooks and everything else ChromeOS. 574K Members 39 Online Good ad blocker with manifest v3 14 upvotes Â· 8 comments Promoted r/Blazor r/Blazor 19K Members 11 Online I just published v6.1.0 of the Blazor.Text.Editor NuGet Package. One of the new features was Vim Emulation. One of the bug fixes was for cultures that use a comma to deliminate decimals. I've left links to the demo and source code as a comment. 39 upvotes Â· 8 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online So what do you use for Rust development? 142 upvotes Â· 210 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Use Type-State pattern without the ugly code 205 upvotes Â· 51 comments r/WindowsOnDeck r/WindowsOnDeck This is a place for Steam Deck owners to chat about using Windows on Deck. Feel free to share gaming benchmarks and troubleshoot issues here. Have fun! â˜ºï¸ 24K Members 7 Online Disabling SMT for Yuzu 8 upvotes Â· 6 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Rust for Android 410 upvotes Â· 38 comments Promoted r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online What's the difference between `FnOnce`, `Fn` and `FnMut` 100 upvotes Â· 46 comments r/emacs r/emacs The extensible, customizable, self-documenting real-time display editor. 73K Members 49 Online [ANN] alphapapa/plz.el: v0.3 release (HTTP library for Emacs) github 78 upvotes Â· 8 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Reading Large (100GB+) Files. 146 upvotes Â· 52 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Cargo Watch is on life support 659 upvotes Â· 37 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online What do atomic operations accomplish? 127 upvotes Â· 63 comments r/neovim r/neovim Neovim is a hyperextensible Vim-based text editor. Learn more at neovim.io. 102K Members 64 Online UPDATE: neovim-plugin-boilerplate - ðŸ”Œ Plug and play template with pre-configured CI, CD, linter, docs and tests. 40 upvotes Â· 2 comments r/neovim r/neovim Neovim is a hyperextensible Vim-based text editor. Learn more at neovim.io. 102K Members 64 Online How to do Neovim dashboards cli cool artish designs? 2 upvotes Â· 8 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online I would choose rust just for the types 477 upvotes Â· 124 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Could rust theoretically achieve better optimisation with a costum backend, that takes more advantage of the rich type system Information that LLVM? 102 upvotes Â· 39 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Practice - v0.1.0 Release ðŸš€ 123 upvotes Â· 8 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online My Day at RustConf 189 upvotes Â· 36 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Help wanted for a crate :) 139 upvotes Â· 14 comments r/neovim r/neovim Neovim is a hyperextensible Vim-based text editor. Learn more at neovim.io. 102K Members 64 Online Neovim starter config 13 upvotes Â· 12 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online What are the areas where Rust is used the most right now? 233 upvotes Â· 244 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online The good and bad of C++ (as a Rust developer) chadnauseam 172 upvotes Â· 80 comments r/laravel r/laravel Laravel is a free and open-source PHP web framework created by Taylor Otwell.
Laravel features expressive, elegant syntax - freeing you to create without sweating the small things. 90K Members 23 Online WYSIWYG Markdown editor? 18 upvotes Â· 15 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 154 Online Binsider - A TUI for analyzing Linux binaries like a boss! 355 upvotes Â· 26 comments
======>
https://lib.rs/crates/yew-mdx
-->>-->>
Search Lib .rs â€º Embedded development # component # markdown # renderer # yew yew-mdx by Patrick Elsen Install API reference Source 1 unstable release 0.1.0-alpha.1 Mar 30, 2023 # 156 in #yew Download history 11/week @ 2024-03-28 7/week @ 2024-04-04 8/week @ 2024-04-25 73 downloads per month MIT license 6KB 109 lines Markdown renderer in Yew with support for embedded components Dependencies ~16MB ~286K SLoC markdown yew 0.20 See also: termimad , mdbook , glu , unclog , yew-hooks , yew , mrml , yew-bootstrap , patternfly-yew , mdsf , yewdux Lib.rs is an unofficial list of Rust/Cargo crates, created by kornelski . It contains data from multiple sources, including heuristics, and manually curated data . Content of this page is not necessarily endorsed by the authors of the crate. This site is not affiliated with nor endorsed by the Rust Project.
If something is missing or incorrect,
please file a bug .
======>
https://github.com/rambip
-->>-->>
493
      contributions
        in the last year 5 contributions on October 1st. No contributions on October 8th. 16 contributions on October 15th. No contributions on October 22nd. No contributions on October 29th. No contributions on November 5th. 12 contributions on November 12th. No contributions on November 19th. 3 contributions on November 26th. 6 contributions on December 3rd. 1 contribution on December 10th. No contributions on December 17th. 5 contributions on December 24th. No contributions on December 31st. 1 contribution on January 7th. No contributions on January 14th. No contributions on January 21st. No contributions on January 28th. No contributions on February 4th. No contributions on February 11th. 3 contributions on February 18th. No contributions on February 25th. No contributions on March 3rd. No contributions on March 10th. No contributions on March 17th. No contributions on March 24th. 7 contributions on March 31st. No contributions on April 7th. No contributions on April 14th. No contributions on April 21st. No contributions on April 28th. No contributions on May 5th. No contributions on May 12th. No contributions on May 19th. No contributions on May 26th. 3 contributions on June 2nd. No contributions on June 9th. No contributions on June 16th. No contributions on June 23rd. No contributions on June 30th. No contributions on July 7th. No contributions on July 14th. 1 contribution on July 21st. No contributions on July 28th. 1 contribution on August 4th. 1 contribution on August 11th. No contributions on August 18th. No contributions on August 25th. No contributions on September 1st. 8 contributions on September 8th. 1 contribution on September 15th. 1 contribution on September 22nd. No contributions on September 29th. 3 contributions on October 2nd. 2 contributions on October 9th. 4 contributions on October 16th. 1 contribution on October 23rd. No contributions on October 30th. 4 contributions on November 6th. 3 contributions on November 13th. No contributions on November 20th. No contributions on November 27th. No contributions on December 4th. No contributions on December 11th. No contributions on December 18th. No contributions on December 25th. No contributions on January 1st. No contributions on January 8th. No contributions on January 15th. No contributions on January 22nd. No contributions on January 29th. No contributions on February 5th. No contributions on February 12th. No contributions on February 19th. No contributions on February 26th. No contributions on March 4th. 1 contribution on March 11th. No contributions on March 18th. No contributions on March 25th. 16 contributions on April 1st. No contributions on April 8th. No contributions on April 15th. No contributions on April 22nd. No contributions on April 29th. No contributions on May 6th. No contributions on May 13th. No contributions on May 20th. 3 contributions on May 27th. 20 contributions on June 3rd. No contributions on June 10th. No contributions on June 17th. No contributions on June 24th. No contributions on July 1st. No contributions on July 8th. No contributions on July 15th. No contributions on July 22nd. No contributions on July 29th. No contributions on August 5th. 18 contributions on August 12th. No contributions on August 19th. 2 contributions on August 26th. 2 contributions on September 2nd. No contributions on September 9th. No contributions on September 16th. No contributions on September 23rd. No contributions on September 30th. 14 contributions on October 3rd. No contributions on October 10th. No contributions on October 17th. No contributions on October 24th. No contributions on October 31st. 4 contributions on November 7th. 1 contribution on November 14th. No contributions on November 21st. 15 contributions on November 28th. No contributions on December 5th. 4 contributions on December 12th. No contributions on December 19th. 6 contributions on December 26th. No contributions on January 2nd. No contributions on January 9th. No contributions on January 16th. No contributions on January 23rd. No contributions on January 30th. No contributions on February 6th. 2 contributions on February 13th. No contributions on February 20th. No contributions on February 27th. No contributions on March 5th. No contributions on March 12th. No contributions on March 19th. No contributions on March 26th. 3 contributions on April 2nd. No contributions on April 9th. No contributions on April 16th. No contributions on April 23rd. No contributions on April 30th. No contributions on May 7th. No contributions on May 14th. No contributions on May 21st. 2 contributions on May 28th. 2 contributions on June 4th. No contributions on June 11th. No contributions on June 18th. No contributions on June 25th. No contributions on July 2nd. No contributions on July 9th. No contributions on July 16th. No contributions on July 23rd. No contributions on July 30th. No contributions on August 6th. No contributions on August 13th. No contributions on August 20th. 1 contribution on August 27th. No contributions on September 3rd. No contributions on September 10th. No contributions on September 17th. No contributions on September 24th. No contributions on October 1st. 8 contributions on October 4th. No contributions on October 11th. 1 contribution on October 18th. 3 contributions on October 25th. No contributions on November 1st. 11 contributions on November 8th. No contributions on November 15th. No contributions on November 22nd. 7 contributions on November 29th. 1 contribution on December 6th. No contributions on December 13th. No contributions on December 20th. No contributions on December 27th. No contributions on January 3rd. 1 contribution on January 10th. No contributions on January 17th. No contributions on January 24th. No contributions on January 31st. No contributions on February 7th. 10 contributions on February 14th. No contributions on February 21st. No contributions on February 28th. No contributions on March 6th. No contributions on March 13th. No contributions on March 20th. 1 contribution on March 27th. 9 contributions on April 3rd. 6 contributions on April 10th. No contributions on April 17th. No contributions on April 24th. No contributions on May 1st. No contributions on May 8th. No contributions on May 15th. No contributions on May 22nd. 5 contributions on May 29th. No contributions on June 5th. No contributions on June 12th. No contributions on June 19th. No contributions on June 26th. No contributions on July 3rd. No contributions on July 10th. No contributions on July 17th. No contributions on July 24th. No contributions on July 31st. 1 contribution on August 7th. No contributions on August 14th. No contributions on August 21st. 4 contributions on August 28th. No contributions on September 4th. No contributions on September 11th. No contributions on September 18th. No contributions on September 25th. No contributions on October 2nd. No contributions on October 5th. 1 contribution on October 12th. No contributions on October 19th. No contributions on October 26th. No contributions on November 2nd. No contributions on November 9th. No contributions on November 16th. 23 contributions on November 23rd. 5 contributions on November 30th. 6 contributions on December 7th. No contributions on December 14th. No contributions on December 21st. 11 contributions on December 28th. No contributions on January 4th. No contributions on January 11th. No contributions on January 18th. No contributions on January 25th. No contributions on February 1st. No contributions on February 8th. No contributions on February 15th. No contributions on February 22nd. 3 contributions on February 29th. No contributions on March 7th. No contributions on March 14th. No contributions on March 21st. 2 contributions on March 28th. No contributions on April 4th. 1 contribution on April 11th. 8 contributions on April 18th. No contributions on April 25th. No contributions on May 2nd. No contributions on May 9th. No contributions on May 16th. No contributions on May 23rd. No contributions on May 30th. No contributions on June 6th. No contributions on June 13th. No contributions on June 20th. No contributions on June 27th. 5 contributions on July 4th. No contributions on July 11th. No contributions on July 18th. No contributions on July 25th. No contributions on August 1st. 1 contribution on August 8th. No contributions on August 15th. No contributions on August 22nd. 18 contributions on August 29th. 4 contributions on September 5th. 1 contribution on September 12th. No contributions on September 19th. No contributions on September 26th. No contributions on October 3rd. No contributions on October 6th. No contributions on October 13th. No contributions on October 20th. No contributions on October 27th. No contributions on November 3rd. No contributions on November 10th. 28 contributions on November 17th. No contributions on November 24th. No contributions on December 1st. 10 contributions on December 8th. No contributions on December 15th. No contributions on December 22nd. 5 contributions on December 29th. No contributions on January 5th. No contributions on January 12th. No contributions on January 19th. No contributions on January 26th. No contributions on February 2nd. No contributions on February 9th. No contributions on February 16th. 7 contributions on February 23rd. 2 contributions on March 1st. No contributions on March 8th. No contributions on March 15th. No contributions on March 22nd. No contributions on March 29th. No contributions on April 5th. 2 contributions on April 12th. 9 contributions on April 19th. No contributions on April 26th. No contributions on May 3rd. No contributions on May 10th. No contributions on May 17th. No contributions on May 24th. 1 contribution on May 31st. 2 contributions on June 7th. No contributions on June 14th. No contributions on June 21st. No contributions on June 28th. 4 contributions on July 5th. No contributions on July 12th. No contributions on July 19th. No contributions on July 26th. 2 contributions on August 2nd. 1 contribution on August 9th. No contributions on August 16th. No contributions on August 23rd. No contributions on August 30th. 5 contributions on September 6th. No contributions on September 13th. No contributions on September 20th. No contributions on September 27th. No contributions on October 7th. 4 contributions on October 14th. 6 contributions on October 21st. No contributions on October 28th. No contributions on November 4th. 7 contributions on November 11th. 1 contribution on November 18th. 1 contribution on November 25th. No contributions on December 2nd. 6 contributions on December 9th. No contributions on December 16th. 3 contributions on December 23rd. 1 contribution on December 30th. No contributions on January 6th. No contributions on January 13th. No contributions on January 20th. No contributions on January 27th. No contributions on February 3rd. No contributions on February 10th. No contributions on February 17th. 3 contributions on February 24th. No contributions on March 2nd. No contributions on March 9th. No contributions on March 16th. No contributions on March 23rd. No contributions on March 30th. No contributions on April 6th. No contributions on April 13th. 1 contribution on April 20th. No contributions on April 27th. No contributions on May 4th. No contributions on May 11th. No contributions on May 18th. No contributions on May 25th. No contributions on June 1st. No contributions on June 8th. No contributions on June 15th. No contributions on June 22nd. No contributions on June 29th. No contributions on July 6th. No contributions on July 13th. No contributions on July 20th. No contributions on July 27th. No contributions on August 3rd. No contributions on August 10th. No contributions on August 17th. 13 contributions on August 24th. 2 contributions on August 31st. 1 contribution on September 7th. No contributions on September 14th. No contributions on September 21st. 1 contribution on September 28th. Contribution Graph Day of Week October Oct November Nov December Dec January Jan February Feb March Mar April Apr May May June Jun July Jul August Aug September Sep Sunday Sun Monday Mon Tuesday Tue Wednesday Wed Thursday Thu Friday Fri Saturday Sat Learn how we count contributions Less No contributions. Low contributions. Medium-low contributions. Medium-high contributions. High contributions. More 2024 2023 2022 2021 2020 Contribution activity October 2024 rambip has no activity
          yet for this period. Loading Show more activity Seeing something unexpected? Take a look at the GitHub profile guide .
======>
https://github.com/alexpasmantier/rust-devicons
-->>-->>
Repository files navigation README Unlicense license ðŸ¦€ rust-devicons A Rust library inspired by vim-devicons , that provides filetype glyphs (icons) for a wide range of common file formats. Features ðŸ¦ž Icon Retrieval : Get file or directory icons based on file name/extension. ðŸ¦ž Icon Color : Retrieve the color associated with the icon depending on the specified theme. ðŸ¦ž Filetype Support : Supports a wide range of filetypes and filename conventions (dockerfile, makefile, etc.). ðŸ¦ž Customizable Themes : Supports both light and dark themes. Installation cargo add devicons NOTE : you'll need to use a NerdFont to properly display the icons. Usage Hereâ€™s a simple example of how to use devicons to retrieve a file icon with the dark theme: use std :: path :: Path ; use devicons :: { File , Theme , icon_for_file , FileIcon } ; fn main ( ) { // getting the icon from a path with a specified theme let path = Path :: new ( "Cargo.toml" ) ; let icon = icon_for_file ( path , Some ( Theme :: Dark ) ) ; // getting the icon from a string with a specified theme let icon = icon_for_file ( "Cargo.toml" , Some ( Theme :: Dark ) ) ; // getting the icon from a path with the default theme let icon = FileIcon :: from ( path ) ; // directly getting an icon from a filename let icon = FileIcon :: from ( "Cargo.toml" ) ; println ! ( "File: {}" , path.to_string_lossy ( ) ) ; println ! ( "Icon: {}" , icon.icon ) ; println ! ( "Color: {}" , icon.color ) ; } Running the Examples You can find more usage examples in the examples directory. To run them, use: cargo run --example < example_name > License This project is licensed under the UNLICENSE license .
======>
https://github.com/proxin187/Yaxi
-->>-->>
Repository files navigation README MIT license yaxi is a x11 library written from scratch Key Features Clean Interface - yaxi provides a clean interface, making it perfect for both beginners and experienced developers Safety - yaxi has safe interface for x11 unlike many other x11 libraries Not A Wrapper - yaxi is a pure rust implementation and is NOT a wrapper Goals Authorization Requests and Replies events (most) Extensions (Xinerama, Xft, ...) Comprehensive Documentation Window Manager in yaxi (work in progress) Example This example opens a window and waits for a keyboard press before it quits: use yaxi :: window :: { WindowArguments , WindowValuesBuilder , EventMask , WindowClass , WindowKind } ; use yaxi :: proto :: Event ; use yaxi :: display ; fn main ( ) -> Result < ( ) , Box < dyn std :: error :: Error > > { let mut display = display :: open_unix ( 0 ) ? ; let mut root = display . default_root_window ( ) ? ; let mut window = root . create_window ( WindowArguments { depth : root . depth ( ) , x : 5 , y : 5 , width : 80 , height : 50 , border_width : 15 , class : WindowClass :: InputOutput , visual : root . visual ( ) , values : WindowValuesBuilder :: new ( & [ ] ) , } ) ? ; window . select_input ( & [ EventMask :: KeyPress , EventMask :: KeyRelease ] ) ? ; window . map ( WindowKind :: Window ) ? ; let event = display . next_event ( ) ? ; match event { Event :: KeyEvent { kind , coordinates , window , root , subwindow , state , keycode , send_event } => { let window_copy = display . window_from_id ( window ) ? ; println ! ( "window from id: {}, keycode: {}" , window_copy.id ( ) , keycode ) ; } , _ => { } , } window . destroy ( WindowKind :: Window ) ? ; Ok ( ( ) ) } License Yaxi is licensed under the MIT License.
======>
https://old.reddit.com/r/rust/comments/1futdgf/accessible_frontend_web_development_using_rust/
-->>-->>
Hi! I'm an incoming software lead on a competitive engineering/biology team. I'm personally an engineer with a decent amount of backend programming experience using Rust, and have been eyeing Dioxus/Leptos/Yew as possible candidates to build a web deliverable for the upcoming season.    

   Our team's primary aims are to build an aesthetic and interactive/animated set of frontpages, with lots of eye candy and frills, and a large collection of highly detailed, highly technical documentation pages that should be easy to interact with and edit even for individuals without CS experience. These pages may have interactive components (e.g., embedded 3D model viewers, info bubbles, grid divs, photo galleries, etc.) but will mainly be text-based.   

   The structure would probably be akin to something like this, where CS represents eye-candy sites written by computer scientists, and SCI represents doc pages written by scientists (may not have good programming experience):   

   
   Landing frontpage - CS

   
   Hardware landing page - CS

   
   Hardware project 1 documentation - SCI   
   Hardware project 2 documentation - SCI   
   ... etc   
   
   Software landing page - CS

   
   Software component 1 - SCI   
   Software component 2 - SCI   
   ... etc   
   
   Lab projects - CS

   
   Lab notebook 1 - SCI   
   
   
   

   In past seasons, we've used Astro as a framework since it allows components to be written in JSX and pages to be written in MDX, which can easily be interacted with even for non-technical folk. Do any of the Rust web frameworks offer similar functionality? I know that    rambip    has written markdown interaction libraries for all these frameworks, but from my brief look over it seems that if you want a site like:   

   
   Some markdown 1   
   A component   
   Some markdown 2   
   

   You would probably need to create an rs file, write md 1 and 2 in separate files, and import them as a string passed to the markdown lib in the rs file. I also saw the    yew-mdx crate    which looks nice, but it seems like there's next to 0 proper documentation or examples of it being used, and it seems very early in development. I also found this macro that someone wrote, which seems promising (as per    this Reddit post   ). I might be able to import that and use it?   

   For anyone that has worked with these frameworks, I would love any thoughts or input.  Sorry for the long and rambly post, I'm just trying to get a good sense of the power of these frameworks and how easy they are to interact with. Thank you for any advice!   
   

======>
https://old.reddit.com/r/rust/comments/1fuf8a9/impl_ioread_vs_r_ioread/
-->>-->>
Are these 2 functions the same:
   rust
fn f(r: impl io::Read);
fn f<R: Io::Read>(r: R);
   
I'm also wandering is there a difference in this case if I replace impl with dyn in the first example    
   

======>
https://old.reddit.com/r/rust/comments/1fuu9sw/anyone_using_metal/
-->>-->>
Iâ€™m thinking of switching from wgpu to Metal, but Iâ€™m not willing to switch to C++ or Swift.  I want to keep the CPU side in Rust.    

   Is there anyone using metal-rs that might be willing to chat with me about it?  Iâ€™m curious as to how hard it would be to port my code over, how much XCode will I need/can I use, etc.    

   Thanks!   
   

======>
https://old.reddit.com/r/rust/comments/1fuwhtb/production_sqlx_and_pgbouncer/
-->>-->>
In production i got multiple SQL Servers where i have to use connection pooler like pgbouncer and i got high traffic so i am thinking of transaction mode.    

   Now Pgbouncer says we got support for prepared statements from version 1.21 and i got currently 1.22.   

   error returned from database: prepared statement "sqlx_s_1" does not exist   

   It flat out fails to run even, when i use session mode then it works perfect but CPU usage goes high and latency as well from 47ms to 240ms. Whole infrastructure is at local server.   

   In sqlx documentation i found raw_sql, i haven't tried it yet as then i am looking at significant code change because bind is not supported and then you build the query string on your own.   
   

======>
https://old.reddit.com/r/rust/comments/1fuh7w6/rustdevicons_a_rust_library_that_provides/
-->>-->>
Here's a practical (and dead-simple) crate that provides filetype glyphs for a wide range of common file formats.   

   It's primary use case is to display icons that correspond to various file types in tui applications.   

   Feel free to use it as you see fit, share, or even copy parts of it.   

   Cheers   

   https://github.com/alexpasmantier/rust-devicons   

   Supported file formats   
   

======>
https://github.com/AlexBuz/rust_to_bf
-->>-->>
Repository files navigation README GPL-3.0 license rust_to_bf rust_to_bf is a compiler from a subset of Rust to Brainfuck (BF), with support for primitive types ( usize , char , bool , &str ), integer arithmetic ( + , - , * , / , % ), boolean logic ( && , || , ! ), compound types (arrays, tuples, structs), references ( & , &mut ), control flow statements ( if , match , loop , while , break , continue ), functions (including recursion), dynamic memory allocation, input/output, and more . Background The target language of this compiler, BF, is an esoteric programming language known for its extreme minimalism and difficulty to write serious programs in. A program in BF consists of a sequence of single-character instructions that control the actions and movements of a data pointer along a one-dimensional array of zero-initialized integer cells: Instruction Action > Move the data pointer right by 1 cell. < Move the data pointer left by 1 cell. + Increment the value of the pointed-to cell by 1. - Decrement the value of the pointed-to cell by 1. . Output the value of the pointed-to cell. , Replace the value of the pointed-to cell with the next byte of input. [ If the value of the pointed-to cell is zero, jump forward to the matching ] . ] If the value of the pointed-to cell is nonzero, jump back to the matching [ . Despite their simplicity, these eight instructions are sufficient to render the BF language Turing-complete , meaning that it is capable of computing any computable function and thus is theoretically just as capable as any other programming language. The goal of this project is to turn theory into practice by actually compiling a high-level languageâ€”with full support for features like indirect addressing, dynamic memory allocation, and recursionâ€”into BF. Originally, I planned to develop my own high-level language for this purpose. However, as I worked on the parser, it started to resemble a simplified version of Rust, so I decided to embrace this and pursue writing a Rust-to-BF compiler instead. As an exercise, though, I still finished writing the parser using the chumsky parser combinator library rather than using a dedicated Rust parsing library like syn . Project Structure The compiler itself is split into three library subcrates, corresponding to the three major stages of compilation: In the frontend crate, the input Rust code is tokenized and parsed into an abstract syntax tree (AST). In the middle crate, the AST is transformed into a custom intermediate representation (IR) consisting of load/store, control flow, input/output, and stack frame management statements. This crate also includes an interpreter for running the IR. In the backend crate, the IR is translated into BF code. This crate also includes a BF interpreter for running the generated code. The rust_to_bf binary crate wraps these three components together and provides a command-line interface (CLI) for compiling Rust programs to BF as well as for running them using either the IR or BF interpreter. Usage To compile a Rust program to BF, use the compile subcommand, specifying the input Rust file and the output BF file (or omit the output file to print the BF code to stdout): cargo run --release -- compile < input.rs > [-o < output.bf > ] To run a Rust program without outputting BF code, use the run subcommand and optionally specify which interpreter to use (either ir or bf , defaulting to ir for greater speed): cargo run --release -- run < input.rs > [--interpreter = ir | bf] Example Programs The example_programs directory contains several example programs that can be compiled and run by rust_to_bf . These include: recursive_fibonacci.rs : Computes Fibonacci numbers recursively. day_of_week.rs : Determines the day of the week for any given date. prime_printer.rs : Prints as many prime numbers as the user desires. collatz.rs : Prints the Collatz sequence starting from a user-specified number. linked_list.rs : Demonstrates how a linked list can be implemented using the boxed! macro for heap allocation (see the Standard Library section for more information). bf_interpreter.rs : An interpreter for arbitrary BF programs. Takes a BF program as input, optionally followed by an exclamation mark ( ! ) and the input to the program, and outputs the result of running the program with the given input. tic_tac_toe.rs : A text-based tic-tac-toe game with an unbeatable computer opponent as well as a 2-player mode. Caveats Although rust_to_bf supports many Rust features, it lacks support for many others, including enums, pattern matching, methods, generics, modulues, traits, and lifetimes (see the Supported Rust Features section for a more detailed list). It also lacks support for most of the Rust standard library. However, it does come with a small standard library of its own, which includes macros and functions for performing I/O, allocating heap memory, and terminating the program prematurely. See the Standard Library section for more information. Additionally, the generated BF code is not optimized for efficiency, nor does the provided BF interpreter perform optimizations. This means that complex Rust programs may compile to BF code that is slow to run. Note, though, that the primary goal of this project is to demonstrate that it is possible to compile Rust to BF, not necessarily do generate efficient BF code in the process. With that being said, optimizations are certainly an avenue for future work, and given the systematic nature of the IR-to-BF translation, it is conceivable that the BF interpreter could be made to reverse the translation process and run the corresponding IR code instead. Standard Library Input read_char!() -> char : Reads a character of input from the user. read_int() -> usize : Reads an integer from the user. Note that this is a function, not a macro, so it must be called without the ! . Output print!(...) : Takes a format string literal and a variable number of arguments and prints the string with the arguments interpolated in place of the {} placeholders. Arguments must be of primitive type ( usize , char , bool , &str ). println!(...) : Same as print!(...) , but appends a newline to the output. If no arguments are provided, it simply prints a newline. Memory Management boxed!(value: T) -> &mut T : Stores a value of type T on the heap and returns a mutable reference to it. malloc!(n: usize) -> &mut [usize] : Allocates a contiguous block of n cells on the heap and returns a mutable reference to it. The cells are guaranteed to be zero-initialized. size_of_val!(value: T) -> usize : Returns the size in cells of any value. Early Termination exit!() : Terminates the program. panic!(...) : Prints an error message and terminates the program. Equivalent to println!(...) followed by exit!() . Implementation Details Frontend This component is responsible for tokenizing and parsing the Rust source code and producing an AST. This is accomplished by composing a series of parser combinators provided by the chumsky library. Specifically, an alpha version of chumsky 1.0.0 is used which supports zero-copy parsing. This avoids the need to clone strings when constructing the AST. Middle This component is responsible typechecking the AST and transforming it into IR code. The IR statements operate on a abstract machine with a stack that is addressable either absolutely or relative to a movable frame base. There are statements for raising and lowering the frame base, adding/subtracting values between stack cells and a temporary register, input/output, repeatedly executing a block of statements while a given stack cell is nonzero, and conditionally executing one of multiple blocks depending on the value of a given stack cell. To facilitate dynamic memory allocation, the IR reserves every other stack cell for heap allocations, with the first such cell storing the address of the next available heap cell. To convert Rust control flow constructs into IR statements, a vector of basic blocks (straight-line sequences of statements with a single entry and exit point) is built as the AST is traversed. Then, at the top level of the IR, an all-encompassing Switch statement is used to dispatch control to the appropriate basic block based on the value at the base of the current stack frame, which is initially set to the entry block ID of the main function. To call a function, the frame base is raised to preserve the local variables of the current function, make space for the return value, and store the return block ID. Then, the value at the bottom of the now-raised frame is set to target function's entry block ID. Once the target function begins executing, it lowers the frame base to give itself access the return value slot. To return, it sets the return value and raises the frame base just enough to preserve that value, leaving the return block ID at the bottom of the now-raised frame. The return block in the calling function then lowers the frame base to access the return value as well as the rest of its local variables, and execution continues from there. A similar process is used to jump to blocks within the same function, allowing for loops and conditional statements to be translated to IR code. In these cases, less movement of the frame base is required. In particular, the entry block ID of the current function is simply overwritten with the target block ID and the frame base is raised just enough to preserve the return value slot and return block ID. The target block then lowers the frame base to access the return value slot and continues execution from there. Here is a diagram illustrating the movements of the frame base as described above: stack layout:  [..., return value, return id, call/jump id, args, locals]
1. caller: ^^^ 2. to call: ^^^^^^^^^^^^^^^^^^ 3. callee: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ callee control flow:
  1. to jump: ^^^^^^^^^^^^^^^^^^^^^^^^^^ 2. post-jump: ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 1. to return: ^^^^^^^^^ 2. post-return: ^^^^^^^^^^^^^^^^^ The ^^^ characters on each line indicate the portion of the stack (starting at the frame base) that remains accessible at that stage. The return value slot is where the callee's return value is placed, the return id slot is used to store the block ID to return to, the call/jump id slot is used to store the block ID to call or jump to, args represents the arguments passed to the callee, and locals represents the local variables of the callee. Backend This component is responsible for translating the IR into BF code. To accomplish this, the BF tape is laid out as follows: reg1, reg0,
mem_base (0), stack_base (0),
temp0, mem0, mem0_marker, unused (0),
temp1, mem1, mem1_marker, stack0_marker,
temp2, mem2, mem2_marker, unused (0),
temp3, mem3, mem3_marker, stack1_marker,
temp4, mem4, mem4_marker, unused (0),
temp5, mem5, mem5_marker, stack2_marker,
... The reg0 cell serves as the destination for Load statements and the source for Store statements. The reg1 cell serves as a temporary register for Store statements that write to an indirect memory location, since the reg0 cell is overwritten with the address of the target memory location during indirect addressing. The mem_base cell is always set to zero and marks the beginning of the heap. The stack_base cell is always set to zero and marks the beginning of the stack. This cell also serves as the home position for the BF data pointer, which is moved back to this cell after each statement is executed. After the reg1 , reg0 , mem_base , and stack_base cells, the tape is divided into blocks of four cells each, with each block representing a memory location: The first cell of each block is a temporary cell that is used by Load statements to preserve the value of the source memory location while it is being copied to the reg0 cell, since copying is implemented in BF as a loop that repeatedly subtracts the value of the source cell and increments the value of the destination cell until the source cell is zero. By first moving the source cell to this temporary cell (i.e., by using a BF loop like [-<+>] ), the source cell can then be restored while the reg0 cell is updated. The second cell of each block stores the actual value of the memory location. The third cell of each block is a marker that is used to implement indirect addressing. When an indirect memory location is being accessed, a trail of 1s is written to the markers leading up to it. This trail can then be traversed by repeatedly moving left or right by four cells until a zero is encountered (i.e., [<<<<] or [>>>>] in BF). This allows for moving between the indirect memory location and reg0 without needing to know the distance between them in advance. The fourth cell of each block alternates between being unused (for even-numbered blocks, which are reserved for heap memory) and marking stack cells that are below the current frame base (for odd-numbered blocks, which are used for stack memory). To raise the frame base by n cells, n additional stack markers are set to 1, and to lower the frame base by n cells, the last n stack markers are set to 0. Thus, the first cell of the current frame is marked by the first stack marker with a value of 0. This facilitates accessing local variables, since the stack markers can be traversed to move between the stack base and the current frame base without indirect addressing. Supported Rust Features (non-exhaustive) variables: immutable: let three = 3; mutable: let mut a = 'A'; with explicit type: let b: bool = false; types: primitives: usize , char , bool , &str tuples: (T,) , (T, U) , (T, U, V) , ... arrays: [T; len] references: &T , &mut T automatic coercion from &mut T to &T when appropriate structs: struct Foo { a: usize, b: char } explicit casting: 41 as char , true as usize , &mut arr as &mut [usize] expressions literals: 3 , 'A' , false , "Hello ðŸ‘‹ world!" tuples: (3,) , ('A', false) , (30, true, 'B') arrays: [3, 1, 4, 1, 5, 9] [false; 4] for [false, false, false, false] structs: Foo { a: 12, b: 'W' } operators (with standard precedence): arithmetic: + , - , * , / , % relational: == , != , > , >= , < , <= logical: && , || , ! parentheses: ( , ) assignment: operators: = , += , -= , *= , /= , %= assignable places: variables: x = 5; tuple elements: t.0 = 3; struct fields: f.a += 1 array elements: arr[2] = 'H'; dereferenced references: *p = 3; auto-deref: p.0 is desugared to (*p).0 if p is a reference to a tuple p.a is desugared to (*p).a if p is a reference to a struct p[3] is desugared to (*p)[3] if p is a reference to an array if statements: if condition { ... } else if other_condition { ... } else { ... } loops: infinite loop: loop { ... } while loop: while condition { ... } break and continue statements functions: declaration: fn foo(a: usize, b: char) -> bool { ... } call: foo(3, 'A') recursion mutual recursion comments: line comments: // this is a line comment block comments: /* this is a /* nested */ block comment */ macros: print! , println! , panic! enums pattern matching generics impl blocks methods associated functions blanket impls trait-related features traits constrained generics iterators for loops closures standard library types and traits expanded format specifier support {:?} for Debug &[T] and &str with length information (i.e., fat pointers) non-ASCII char values expression-oriented features control flow statements as expressions last expression in block as return value range types/patterns expanded numeric types specific-width integers signed integers floating-point numbers bitwise operators modules dynamic dispatch lifetimes and borrow-checking
======>
https://old.reddit.com/r/rust/comments/1fuc2gy/support_for_sqlites_jsonjsonb_has_landed_on_diesel/
-->>-->>
Hello there!   

   I'm proud to announce one of my first major public contribution to the Rust ecosystem.   

   My PR to add support for SQLite's JSON/JSONB in    diesel   , the safe, extensible ORM and Query Builder for Rust, has just been merged on `master`.   

   Here is a concrete example of what used to be available to the PostgreSQL backend only, but is now supported on SQLite too:   

   table! {
    contacts {
        id -> Integer,
        name -> Text,
        address -> Jsonb,
    }
}

let santas_address: serde_json::Value = serde_json::from_str(r#"{
    "street": "Article Circle Expressway 1",
    "city": "North Pole",
    "postcode": "99705",
    "state": "Alaska"
}"#)?;
let inserted_address = insert_into(contacts)
    .values((name.eq("Claus"), address.eq(&santas_address)))
    .returning(address)
    .get_result::<serde_json::Value>(connection)?;
assert_eq!(santas_address, inserted_address);
   

   More in the docs:   

   https://docs.diesel.rs/master/diesel/sql_types/struct.Jsonb.html   

   According to the maintainer:   

   
   I think the next step for json support in the SQLite backend is to add definitions for the built-in SQL functions to diesel. Especially adding the json and jsonb functions should make it much easier to actually use this work. If you are interested in working on that as well, just reach out and I will provide more details on how this should be done. That part should be much more straight forward than adding these impls, as we don't need to care about parsing complicated stuff.   
   
   

======>
https://oxc.rs/docs/learn/performance.html
-->>-->>
switch i64 %s.1, label %bb6 [ i64 2, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit.i" i64 3, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit280.i" i64 4, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit325.i" i64 5, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit380.i" i64 6, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit450.i" i64 7, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit540.i" i64 8, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit590.i" i64 9, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit625.i" i64 10, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit655.i" i64 11, label %"_ZN4core5slice3cmp81_$LT$impl$u20$core..cmp..PartialEq$LT$$u5b$B$u5d$$GT$$u20$for$u20$$u5b$A$u5d$$GT$2eq17h46d405acb5da4997E.exit665.i" ], !dbg !191362

======>
https://old.reddit.com/r/rust/comments/1funrkh/yaxi_a_postmodern_x11_rust_library_focusing_on_a/
-->>-->>
Today I'm happy to announce Yaxi, a x11 rust library.   

   Why you may ask? I find that the currently established x11 libraries for rust are either horribly unsafe or have poor documentation.
Yaxi wants to change this, our goal is a provide a x11 rust library that has both great functionality and backwards compatibility while providing comprehensive documentation even for functions previously existing in xlib.   

   I appreciate all feedback, contributions and stars, thank you!   

   https://github.com/proxin187/Yaxi   
   

======>
https://jgayfer.com/dont-write-rust-like-java
-->>-->>
Iâ€™ve been interested in the idea of Rust for a couple years now. Type safe, memory safe, and an emphasis on correctness. Whatâ€™s not to love? The percentage of errors I encounter while working on Apollo (a Python app) that could have been caught by the Rust compiler is quite high (I wonâ€™t claim 100%, but pretty close). In general, compilers can catch a lot of issues that might otherwise make their way to production when using a dynamic language (like Python or Ruby), though not all compilers are equal. Type safety is great, but Rustâ€™s emphasis on correctness is where I find the most appeal. Iâ€™ve been writing a fair chunk of Java at work. While not my favourite language, the compile time checks are empowering. Significant refactors arenâ€™t as scary as in Python or Ruby. You have the compiler on your side! An incorrect or missing import statement isnâ€™t going to grind your program to a halt at runtime. We usually have tests to catch these issues, yes, but thereâ€™s something to be said about having these checks baked into the language. The Java compiler isnâ€™t perfect however. There are entire classes of errors it does not protect against, the most infamous being null references. (Almost) everything can be null in Java, and you wonâ€™t find out until runtime. Rust on the other hand has constructs in place to guide you towards handling unknown values. You can of course choose to ignore such guidances, but the compiler forces you to make a deliberate decision to do so. So is Rust a better Java? There is certainly a lot to like. The promise of Rust is one I find incredibly enticing. But my Rust journey hasnâ€™t been all sunshine and rainbows. Despite the similarities, Rust is not Java. I didnâ€™t discover the joy of writing Rust code until I stopped trying to make the language something it isnâ€™t. Everything must be an interface While not entirely accurate, thereâ€™s some truth to the trope that Java developers need everything to be an interface (I am one such developer). Interfaces in Java are fun to work with. Your application is composed of small units of work, where no one unit of work has direct knowledge of the inner workings of another. Bootstrapping your dependency tree requires some work up front, but once complete, you have an army of independent services at your beck and call. We donâ€™t have interfaces in Rust; we have traits . Theyâ€™re similar to interfaces in Java in many ways. However, attempting to make everything a trait in Rust isnâ€™t fun. Remember that great feature of Rust being memory safe? It comes at the cost of not being able to easily â€œinjectâ€ something that implements a trait. trait Named { fn name (& self ) -> String ; } struct Service { named : Named } The above code will not compile, as the size of Named cannot be determined at compile time. To get around this, we can â€œboxâ€ the trait, allowing us to point to dynamically allocated memory on the heap (called a trait object). The Box itself is of a known size, allowing our program to compile. trait Named { fn name (& self ) -> String ; } struct Service { named : Box < dyn Named > } Boxing isnâ€™t my favourite pattern as theyâ€™re awkward to work with. I avoid them if possible. We can instead use generics to specify the trait type. trait Named { fn name (& self ) -> String ; } struct Service < T : Named > { named : T } How is this different? At first glance the result is the same. The difference comes down to dynamic vs static dispatch. With a trait object, the concrete type is resolved at runtime . With generics, the concrete type is resolved at compile time . In practice this means that as long as we can infer all types at compile time, we can get away with generics. If types cannot be inferred until runtime, a box is necessary. What about ownership? The question of ownership remains. What if our Named trait is a required dependent of other services in our application? Do we create a single â€œmasterâ€ Named and pass in a &Named to each dependant, introducing lifetimes? struct Service <' a > { named : &' a dyn Named } Or do we use an Arc such that our dependent services hold onto an Arc<dyn Named> , allowing concurrent access of the owned resource? struct Service { named : Arc < dyn Named > } Iâ€™ve tried both approaches. They work , but arenâ€™t enjoyable, especially when every service in our app is affected. Itâ€™s okay to use functions Forcing Rust to be a purely object oriented language isnâ€™t fun. While I do still write â€œservice objectsâ€ as in the above examples, I try and only use them where necessary, instead preferring functions. Consider a function for handling a Stripe checkout session complete event that updates the Stripe customer ID in our system. async fn handle_session_completed ( user_repo : & mut impl UserRepo , session : & CheckoutSession , ) -> anyhow :: Result <()> { let user_id = session .client_reference_id . clone () . context ( "Missing client reference ID" )?; let customer_id = session .customer_id . clone () . context ( "Missing customer ID" )?; user_repo . update_stripe_customer_id ( user_id , & customer_id ) . await ?; Ok (()) } While we could have written this as a service where UserRepo is an injected value, doing so would introduce the complexities weâ€™ve already explored. Thereâ€™s also no reason to write this as a service as we can still easily inject different implementations of UserRepo , such as providing an implementation that doesnâ€™t hit a live database. The downside is our function signature can get a bit busy, but this level of â€œpainâ€ is nothing compared to the alternatives. Embrace Rust for what it is I fell deep into the hole of Rust is hard . A big reason was my insistence that Rust code should look like other code Iâ€™ve written before. While drawing from the past is the boon of experience, embracing existing idioms is important to achieve mastery. Rust requires a mindset shift. Donâ€™t fight Rust for what it isnâ€™t, embrace it for what it is.
======>
https://v2.tauri.app/blog/tauri-20/
-->>-->>
On this page Overview Overview What is Tauri? When Should I Use Tauri? How Popular is Tauri? How Did We Get to 2.0? Who Made This Release Possible? What Makes 2.0 Great? Getting Started Experience Hot-Module Replacement Plugins Mobile Support The Allowlist is Dead, Long Live the Allowlist External Security Audit Inter Process Communication (IPC) Rewrite Distribution Guides Changelog Added Enhancements Bug Fixes Changed Removed Config restructure Migration Call To Action Roadmap On this page Overview What is Tauri? When Should I Use Tauri? How Popular is Tauri? How Did We Get to 2.0? Who Made This Release Possible? What Makes 2.0 Great? Getting Started Experience Hot-Module Replacement Plugins Mobile Support The Allowlist is Dead, Long Live the Allowlist External Security Audit Inter Process Communication (IPC) Rewrite Distribution Guides Changelog Added Enhancements Bug Fixes Changed Removed Config restructure Migration Call To Action Roadmap Tauri 2.0 Stable Release Oct 2, 2024 Tillmann Weidinger Tauri Security We are very proud to finally announce the stable release for the new major version of Tauri.
Welcome to Tauri 2.0! What is Tauri? Definition Tauri is a framework for building tiny and fast binaries for all major desktop (macOS, linux, windows) and mobile (iOS, Android) platforms. Developers can integrate any frontend framework that compiles to HTML, JavaScript, and CSS for building their user experience while leveraging languages such as Rust, Swift, and Kotlin for backend logic when needed. In a Tauri application the frontend is written in your favorite web frontend stack.
This runs inside the operating system WebView and communicates with the application core written mostly in Rust. No Rust Skills Needed! You donâ€™t need to write Code in Rust, Swift or Kotlin in most cases. Tauri already offers an extensive JavaScript API. When Should I Use Tauri? If you check any of the boxes below, you should use Tauri: Do you want a single UI codebase for all platforms? Do you want to reach as many users as possible on their platform (eg. Windows, MacOS, Linux, Android, iOS)? Are you a frontend web developer and want to write native applications? Are you a Rust developer looking to write applications with a nice looking UI with the option to do it in Rust? Do you have an existing team of web developers and want to expand to native application markets with low upfront investment? Do you have an existing team of rustaceans and want everything written in Rust? How Popular is Tauri? On GitHub the Tauri repository has ~4,878 Pull Requests and ~3,570 Issues closed and around 1000 discussions , at the time of writing.
To get a more detailed insight take a look at the OSSinsight analysis of the Tauri repository. Our Discord Server currently has ~17,700 members. We are seeing a lot of individual user support, questions on Tauri itself, questions directly to the working group or just discussions between fellow Tauri app developers. We are very happy about the positive and supportive community and grateful to all the community members answering or helping others in Discord or GitHub. We maintain a curated list of Tauri related projects, applications, plugins, guides and more at awesome-tauri . Check this out if you want to get inspiration, see what others are building and ideally create a PR to add your project. Of course this is only a representative sample set and we donâ€™t know exactly who else is building on Tauri. How Did We Get to 2.0? In June 2022 we released Tauri 1.0 with a great impact on the desktop operating system market and how cross platform applications can be built. In the end of 2022 we released our initial alpha version of 2.0 to get initial feedback and to test out how mobile interaction should be defined. After the initial alpha we spent close to two years refining and changing the architecture of Tauri in public. After we saw the broad picture clear enough ourselves we released the beta in Februrary this year. At the same time we collaborated and worked with external security auditors to check our decisions, architecture changes and much more. This August we published the release candidate version of 2.0 to iron out major bugs and to get more feedback from productive use. At the same time the external audit was concluded and made public. The release candidate time frame was considerably shorter and consisted mainly of high impact bugfixes and documentation improvements. Some breaking changes we had to make during the release candidate phase were bundled up until the end and are now included in the stable release. Take a look at the migration section if your main concern is upgrading from a previous version. In total we spent over two years working on improvements, new features, bugfixes, documentation, rewrites and a lot of discussions. This all happened while we released 8 minor versions of the Tauri 1.x branch and backported security fixes and other important bug fixes in several patch releases. Who Made This Release Possible? This release and Tauri itself is only possible due to massive amount of contributions from Lucas , who has provided a constant stream of code changes over the years â¤ï¸. Obviously, Lucas is not the only individual working and contributing to Tauri, but we feel he deserves a very special mention for carrying, starting, and supporting the project and its community throughout the years. We have had major contributions to the Tauri repository in 2.0 from Amr , Fabian-Lars , Tony , Chip , Jason , YuWei , icb , Simon , Oliver Lemasle and many more contributors ( source data ). We received an increasing number of drive-by contributors (one or very few PRs). We are grateful for these, but naming everyone would make this a very long list here. We have a lot(!) of repositories in our organization, which are supporting the success of Tauri and without community and working group contributions Tauri would not be where it is now. A big thank you to everyone involved! Another special shout out and thanks for their constant involvement in the community goes to Fabian-Lars and Simon . If you have been involved in Tauriâ€™s Discord or Github discussions you likely know their name or avatar. If you ever searched on Google or YouTube for Tauri, you have probably seen one of Jacobâ€™s streams . If thatâ€™s not the case please make sure to check it out and subscribe as his sessions are beyond just educational. Another special place in our heart has the Tauri Board , highlighting Daniel Yvetot-Thompson for the numerous hours, sweat, blood and dedication to make Tauri known and sustainable. One important thing we should not forget, is that we acquired support from a stable partner of this open source project. CrabNebula granted multiple people mentioned above and others that are not mentioned here, the privilege to work on the Tauri ecosystem not only in their private time, but also during work time. You can find the partnership announcement on our blog and we have been more than happy about this collaboration over the last year. In 2024 alone they spent over 2,870 work hours on this project, which massively pushed the progress and allows us to announce the stable 2.0 release today. If you were not aware of CrabNebula yet, make sure to check out their products and services and consider the symbiotic relationship with Tauri if you are interested in not only improving your workflows, but also supporting the Tauri ecosystem. What Makes 2.0 Great? With this major release we improved and changed several aspects of how and where you can build, develop and publish your Tauri app. In the following sections we have more detailed insight. This does not cover everything, but should give you a decent impression on what you can expect from Tauri. Getting Started Experience One thing you are always going to go through when starting with a new framework or tool is the initial onboarding or getting started process. We value developer experience (DX) and try to make this initial process as seamless as building and distributing your final application. For this we created another project, which is called create-tauri-app or in short CTA.
This tool allows developers to start from scratch and get to a running Tauri app in a few minutes instead of hours. (() => {
	class StarlightTabsRestore extends HTMLElement {
		connectedCallback() {
			const starlightTabs = this.closest('starlight-tabs');
			if (!(starlightTabs instanceof HTMLElement) || typeof localStorage === 'undefined') return;
			const syncKey = starlightTabs.dataset.syncKey;
			if (!syncKey) return;
			const label = localStorage.getItem(`starlight-synced-tabs__${syncKey}`);
			if (!label) return;
			const tabs = [...starlightTabs?.querySelectorAll('[role="tab"]')];
			const tabIndexToRestore = tabs.findIndex(
				(tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label
			);
			const panels = starlightTabs?.querySelectorAll(':scope > [role="tabpanel"]');
			const newTab = tabs[tabIndexToRestore];
			const newPanel = panels[tabIndexToRestore];
			if (tabIndexToRestore < 1 || !newTab || !newPanel) return;
			tabs[0]?.setAttribute('aria-selected', 'false');
			tabs[0]?.setAttribute('tabindex', '-1');
			panels?.[0]?.setAttribute('hidden', 'true');
			newTab.removeAttribute('tabindex');
			newTab.setAttribute('aria-selected', 'true');
			newPanel.removeAttribute('hidden');
		}
	}
	customElements.define('starlight-tabs-restore', StarlightTabsRestore);
})() Bash PowerShell npm Yarn pnpm bun Cargo sh <( curl https://create.tauri.app/sh ) irm https://create.tauri.app/ps | iex npm create tauri-app@latest yarn create tauri-app pnpm create tauri-app bun create tauri-app cargo install create-tauri-app --locked cargo create-tauri-app Of course you need to install some prerequisites on your development system before you can start building your application. For this we have extensive guides with operating system specific sections in our official documentation . This whole onboarding experience has been improved and now also bootstraps mobile development templates for iOS and Android. Hot-Module Replacement After the initial onboarding you will regularly develop and debug your Tauri application. We considered what would improve your development process already in 1.x of Tauri and extended the Hot-Module Replacement (HMR) to mobile devices and emulators. This means that all changes to the frontend of your application do not require a rebuild of your whole application and you can live preview how it will look like in the device or operating system your are developing for. Your browser does not support the video tag. Plugins With Tauri 2.0 we built a more advanced plugin system. We transferred a lot of our previous functionality into our official plugins (see plugins-workspace ), to allow the community an easier entry into contributing to Tauri. We also hope to attract more maintainers for plugins and to speed up the process of implementing new features. This move to plugins has another benefit. We are going to be able to define a definition of done for Tauriâ€™s core. We hope to stabilize the core functionality and offer a stable framework, where the moving parts are mostly plugins offering access to system specific functionality. You no longer need to understand all of Tauri to improve or implement specific features. The plugins usually do not depend on other plugins, with some exceptions. This means to implement a new file system access functionality it is only required to contribute to the fs plugin instead of Tauri itself. As this release also targets mobile platforms, the plugin system also supports mobile plugins. You can write or re-use native code in Swift on iOS and Kotlin on Android and directly expose functions to the Tauri frontend using Annotations ( @Command on Android), implementing a Subclass ( YourPluginClass: Plugin ) on iOS, or by invoking the Swift or Kotlin code from a Rust based Tauri command. Check out the documentation on how to write your own plugin. As we are releasing Tauri as 2.0, the official plugins will follow the major version of Tauri to make compatibility with Tauriâ€™s major version visible at a glance. Not all plugins are as stable as Tauri itself though. Each pluginâ€™s stableness is defined per plugin and documented (soon) in the plugin documentation. The plugin API can possibly break in minor versions, but we will try to keep these changes to a minimum, especially for plugins considered stable. Tip You can pin your plugin versions to only patch updates if you need absolute stable interfaces. We generally try to backport security updates and will announce advisories on GitHub. Autostart Automatically launch your app at system startup. Barcode Scanner Allows your mobile application to use the camera to scan QR codes, EAN-13 and other types of barcodes. Biometric Prompt the user for biometric authentication on Android and iOS. Clipboard Read and write to the system clipboard. Command Line Interface (CLI) Parse arguments from the command line interface. Deep Linking Set your Tauri application as the default handler for an URL. Dialog Native system dialogs for opening and saving files along with message dialogs. File System Access the file system. Global Shortcut Register global shortcuts. HTTP Client Access the HTTP client written in Rust. Localhost Use a localhost server in production apps. Logging Configurable logging. NFC Read and write NFC tags on Android and iOS. Notifications Send native notifications to the user. OS Information Read information about the operating system. Persisted Scope Persist runtime scope changes on the filesystem. Positioner Move windows to common locations. Process Access the current process. Shell Access the system shell to manage files and URLs using their default application and to spawn child processes. Single Instance Ensure that a single instance of your Tauri app is running at a time. SQL Tauri Plugin providing an interface for the frontend to communicate with SQL databases through sqlx. Store Persistent key value storage. Stronghold Encrypted, secure database. System Tray Updater In-app updates for Tauri applications. Upload File uploads through HTTP. Websocket Open a WebSocket connection using a Rust client in JavaScript. Window Customization Window State Persist window sizes and positions. Mobile Support A very much awaited part of this release is the mobile operating system support. The previous version of Tauri allowed to have a single UI code base for desktop operating systems but now this extends to iOS and Android. We have investigated and experimented with different solutions to support mobile and decided on using the operating system native language (Swift and Kotlin) to build an interface for the Rust code and to allow developers to write part of their functionality in these languages. This means you can re-use existing logic of your Swift or Kotlin app that interacts with the system and expose it to Rust or the frontend. Right now this works as mentioned above via the plugin system. We support development with an emulator or a real device and provide a lot of tooling to make the process as seamless as possible. We are not completely happy about the developer experience at the moment but are actively improving to bring it up to par with the desktop experience. On mobile not all of the official plugins are supported. Some are by design not a good fit for mobile and some are just not implemented to support mobile yet. If you would like to contribute on this part check the last section of this post. The Allowlist is Dead, Long Live the Allowlist Yes, there is no allowlist anymore, as we hit the limits of this system pretty quickly. We made it exclusive for Tauri core features and it did not even cover all of Tauriâ€™s APIs. Our new system not only covers all of Tauriâ€™s core API surface, it also supports app and plugin developers to implement their own access control and scoping with a unified approach. The new system we implemented is using permissions - â€œOn-off toggles for Tauri commandsâ€ , scopes - â€œParameter validation for Tauri commandsâ€ and capabilities - â€œAttaching permissions and scopes to Windows and WebViewsâ€ , to create a flexible but simple to use access control system. It allows the creation of named permission or scoping files and to re-use and combine them with other named permissions or scopes. This makes it possible to build more fine grained descriptive sets containing several simple or complex permissions and scopes. As a plugin developer you can abstract away several base permissions into a default permission. This can be based on your default security assumptions and threat model. All official Tauri plugin default permissions are reasonably secure by default. As an app developer you can use, extend or reduce plugin permissions. Of course you can also build permissions and scopes for your own application. With this addition, Tauriâ€™s core is now able to understand if a command invoke message from a frontend WebView is allowed to reach the command function. It is also able to attach the configured scope to the message. The command implementation is responsible for interpreting and enforcing the scope. You can read more about our Threat Model and approach to security in our documentation . External Security Audit The major changes and architecture of v2 was independently audited by Radically Open Security during the beta and release candidate period. Please take your time to read the report and learn more about the awesome work of @gronke and @pcwizz . The whole audit was funded by the great folks at NLNet via funding from NGI and we are super grateful to be in the privileged position to get fully funded external security audits for major releases. The results of this audit caused us to rewrite parts of how our dev server is exposed, specifically for mobile development. Without the help and guidance of the auditors this rewrite would not have been possible â¤ï¸. Additionally, we hardened our iFrame API exposure, fixed scope validation and resource identifier access for the fs and http plugin, improved our inter-process communication stability, and many other security related fixes and improvements. Inter Process Communication (IPC) Rewrite With the rewrite of our IPC layer we now support a long wished feature of Raw Payloads and generally changed how it works under the hood. Previously all IPC payloads were json serialized and deserialized which caused an overhead. This was noticeable once more than a few kilobytes were transfered between frontend and backend. The new system supports Raw Requests . These speed up the transfer of large data from backend to frontend and vice versa, where you can either use raw bytes directly or use your own (de)serialization process (eg. bson, protobuf, avro and others). For directly reading files from the filesystem into the WebView we still recommend the convertFileSrc functionality, as it is most likely still faster if you do not need to process the data on the Rust backend. Distribution Guides With Tauri 2.0 the distribution diversity greatly increased. Partially, due to the mobile ecosystem and partially due to our community contributions. We have official guides on how to ship to the Apple Appstore , Google Play , Microsoft Store , CrabNebula Cloud , Flathub , Snapcraft , AUR and more distribution formats in our distribution docs . Github Action Our GitHub action ( tauri-action ) is in progress to support automated building for the mobile operating systems but does not support it yet. Changelog This section contains all changes going from 1.x in a concise list. Show the Full List Added Added Mobile support. Added multiwebview support behind the unstable feature flag. See WindowBuilder and WebviewBuilder for more information. Added rustls-tls cargo feature flag Added shadow option when creating a webview window, WebviewWindow::set_shadow method in Rust and equivalent API in JS. Added tauri::Webview , tauri::WebviewBuilder , tauri::WebviewWindow , tauri::WebviewWindowBuilder structs in Rust and equivalent classes in Js. The old tauri::Window and tauri::WindowBuilder behaviors have moved to tauri::WebviewWindow and tauri::WebviewWindowBuilder . Added tauri::scope::fs module Added tauri::App/AppHandle::default_window_icon method. Added tauri::ipc module with IPC primitives. Added tauri::ipc::Channel type and equivalent JS Channel type to send data across the IPC. Added incognito option when creating a webview window. Added windowEffects option when creating a webview window and WebviewWindow::set_effects to try and change effects at runtime. Added tauri::path::PathResolver Added tauri::Manager::path method to access the new PathResolver Added visibleOnAllWorkspaces option when creating a webview window. Added tauri::App/AppHandle::primary_monitor and App/AppHandle::available_monitors methods. Added tauri::plugin::Builder::on_navigation and tauri::plugin::Plugin::on_navigation . Added tauri::WebviewWindow::navigate method Added tauri::RunEvent::Opened on macOS and iOS for deep link support. Added file associations support in bundler. Added tauri::App/AppHandle::cleanup_before_exit to manually call the cleanup logic. You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs. On Linux, add tauri::WebviewWindow::default_vbox method to get a reference to the gtk::Box that contains the menu bar and the webview. Added linux-libxdo cargo feature flag (disabled by default) to enable linking to libxdo which is used to make Cut , Copy , Paste and SelectAll native menu items work on Linux. On macOS, add tauri::WebviewWindow::ns_view method to get a pointer to the NSWindow content view. Added tauri::Builder::register_asynchronous_uri_scheme_protocol to allow resolving a custom URI scheme protocol request asynchronously to prevent blocking the main thread. Included drop and hover position for drag and drop events. Added tauri::WebviewWindow::set_progress_bar method Added tauri::WebviewWindow::set_always_on_bottom method and alwaysOnTop option when creating a webview window. Added tauri::WebviewWindowBuilder::on_page_load method. Added common-controls-v6 cargo feature flag (enabled by default). Added Window::destroy to force close a window. Added tauri::EventId type Added tauri::WindowBuilder::on_download to handle download request events. Added tauri::WebviewWindowBuilder::parent which is a convenient wrapper around parent functionality for Windows, Linux and macOS. Added tauri::WebviewWindowBuilder::owner on Windows only. Added tauri::WebviewWindowBuilder::transient_for and tauri::WebviewWindowBuilder::transient_for_raw on Linux only. Added tauri::WebviewWindow::start_resize_dragging and tauri::ResizeDirection enum. Added tauri::WebviewWindowBuilder::proxy_url method. Added tauri::WebviewEvent enum Added tauri::RunEvent::WebviewEvent variant. Added tauri::Builder::on_webview_event and tauri::Webview::on_webview_event methods. Added tauri::image module which includes tauri::image::Image and tauri::image::JsImage types and tauri::image::include_img! macro. Added tauri::is_dev function to determine whether the app is running in development mode or not. Added tauri::Assets::setup method on tauri::Assets trait that lets you run initialization code for your custom asset provider. Added tauri::Rect struct. Added tauri::WebviewWindow::set_zoom method Added zoomHotkeys option when creating a webview window. Added window.isTauri JS global function to check whether running in tauri or not. Added specta feature flag which adds specta support for AppHandle , State , Window , Webview and WebviewWindow types. Added tauri::App/AppHandle/WebviewWindow::cursor_position getter to get the current cursor position. Added tauri::App/AppHandle/WebviewWindow::monitor_from_point(x,y) getter to get the monitor from a given point.. Added tauri::RunEvent::Reopen to handle click on dock icon on macOS. Added defaultWindowIcon to the JS app module to retrieve the default window icon in JS. Added tauri::WebviewWindow::set_title_bar_style to set title bar at runtime on macOS. Add APIs to enable setting window size constraints separately: Added tauri::WindowBuilder::inner_size_constraints and tauri::WebviewWindowBuilder::inner_size_constraints Added tauri::WindowSizeConstraints struct Added tauri::Window::set_size_constraints and tauri::WebviewWindow::set_size_constraints Enhancements Use custom protocols on the IPC implementation to enhance performance. Enhance centering a newly created window, it will no longer jump to center after being visible. The custom-protocol Cargo feature is no longer required on your application and is now ignored. To check if running on production, use #[cfg(not(dev))] instead of #[cfg(feature = "custom-protocol")] . Improved the JS path APIs to return simplified paths on Windows when possible, i.e removing UNC ( \\?\ ) prefix. Improved the error message that is shown when deserializing the Tauri plugin config. Set the gtk application id to the identifier defined in tauri.conf.json to ensure the app uniqueness. This can be disabled by setting enableGtkAppId option to false . On Windows, handle resizing undecorated windows natively which improves performance and fixes a couple of annoyances with previous JS implementation: No more cursor flickering when moving the cursor across an edge. Can resize from top even when data-tauri-drag-region element exists there. Upon starting rezing, clicks donâ€™t go through elements behind it so no more accidental clicks. Mark AppHandle::restart and process::restart as diverging functions Bug Fixes No longer unpacking and flattening the payload over the IPC so that commands with arguments called cmd , callback , error , options or payload arenâ€™t breaking the IPC. Fix calling set_activation_policy when the event loop is running. Fix can not prevent closing a window from another webview. On Windows, fix decorated window not transparent initially until resized. Resolve symlinks on the filesystem scope check. Fix the JS basename(path, 'ext') API implementation removing all occurances of ext where it should only remove the last one. Fix window white flashing on exit on Windows Apply minWidth , minHieght , maxWidth and maxHeight constraints separately, which fixes a long standing bug where these constraints were never applied unless width and height were constrained together. Changed The window creation and setup hook are now called when the event loop is ready. Renamed the default-tls feature to native-tls and. Changed the plugin setup hook to take a second argument of type PluginApi Changed tauri::Window struct behavior and moved its old behavior to the new tauri::WebviewWindow type. Moved tauri::api::path module to tauri::path Moved all functions from tauri::api::path to be methods on tauri::path::PathResolver Renamed system-tray feature flag to tray-icon . Changed tauri::App::handle and tauri::Manager::app_handle methods to return a reference to an AppHandle instead of an owned value. Changed tauri::Builder::register_uri_scheme_protocol to return a http::Response instead of Result<http::Response> . To return an error response, manually create a response with status code >= 400. The custom protocol on Windows and Android now uses the http scheme instead of https . Changed tauri::Env.args to tauri::Env.args_os and now uses OsString instead of String Changed TAURI_AUTOMATION env var to TAURI_WEBVIEW_AUTOMATION Changed tauri::Builder::invoke_system to take references instead of owned values. Changed tauri::Builder::invoke_system , tauri::Builder::on_page_load hooks to take a tauri::Webview argument instead of a tauri::Window . Moved the tauri::command module items to the tauri::ipc module so its import name does not clash with the tauri::command macro. Changed tauri::App::run_iteration to take a callback and removed its return value. Changed AppHandle::exit and AppHandle::restart to trigger RunEvent::ExitRequested and RunEvent::Exit Renamed tauri::WebviewWindowBuilder::owner_window to tauri::WebviewWindowBuilder::owner_raw and tauri::WebviewWindowBuilder::parent_window to tauri::WebviewWindowBuilder::parent_raw . Renamed the window-data-url feature flag to webview-data-url . Changed tauri::WebviewWindow::close to trigger a close requested event instead of forcing the window to be closed. Use tauri::WebviewWindow::destroy to force close. Renamed icon-ico and icon-png feature flags to image-ico and image-png respectively. Removed tauri::Icon enum, use the new tauri::Image type instead. All APIs that previously accepted tauri::Icon have changed to accept tauri::Image instead. Changed tauri::Context struct and tauri::Assets trait to have a R: Runtime generic. Renamed tauri::Context::assets_mut to tauri::Context::set_assets Changed tauri::Context type to not have <A: Assets> generic so the assets implementation can be swapped with Context::set_assets . Changed tauri::Context::assets to return &dyn Assets instead of &A generic. Renamed tauri::FileDropEvent enum to tauri::DragDropEvent and renamed its variants. Also renamed the js events Renamed tauri::WindowEvent::FileDrop enum variant to tauri::WindowEvent::DragDrop Renamed file drop emitted events to tauri://drag-enter , tauri://drag-over , tauri://drag-drop , and tauri://drag-leave Renamed tauri::WebviewWindow::disable_file_drop_handler to tauri::WebviewWindow::disable_drag_drop_handler . Changed tauri::WebviewWindow::url getter to return a result. Changed tauri::Env.args_os , to include the binary path, previously it was skipped. Renamed getAll and getCurrent to getAllWindows and getCurrentWindow in the JS window module but you probably want getAllWebviewWindows and getCurrentWebviewWindow from the webviewWindow module. Removed The reqwest-* Cargo features were removed UpdaterEvent Removed tauri::api module and moved them into standalone plugins in plugins-workspace repo. Removed tauri::scope::IpcScope Removed tauri::scope::ipc module and all its types. Removed tauri::scope::FsScope , use tauri::scope::fs::Scope Removed tauri::scope::GlobPattern , use tauri::scope::fs::Pattern Removed tauri::scope::FsScopeEvent , use tauri::scope::fs::Event Removed tauri::scope::HttpScope Removed tauri::scope::ShellScope Removed tauri::scope::ShellScopeAllowedCommand Removed tauri::scope::ShellScopeAllowedArg Removed tauri::scope::ExecuteArgs Removed tauri::scope::ShellScopeConfig Removed tauri::scope::ShellScopeError Removed linux-protocol-headers cargo feature flag, now enabled by default. Removed tauri::path::Error and tauri::path::Result and added its variants to tauri::Error Removed tauri::path::Result and tauri::plugin::Result aliases, you should use tauri::Result or your own Result type. Changed tauri::Builder::on_page_load handler to take references. The page load hook is now triggered for load started and finished events, to determine what triggered it see tauri::PageLoadPayload::event field. Removed tauri::GlobalWindowEvent struct, and unpacked its fields to be passed directly to tauri::Builder::on_window_event . Removed tauri::EventHandler type. Renamed tauri::Context::default_window_icon_mut to tauri::Context::set_default_window_icon and changed it to accept Option<T> . Config restructure Restructured Tauri config per RFC#5 : Moved package.productName , package.version and tauri.bundle.identifier fields to the top-level. Removed package object. Renamed tauri object to app . Moved tauri.bundle object to the top-level. Renamed build.distDir field to frontendDist . Renamed build.devPath field to devUrl and will no longer accepts paths, it will only accept URLs. Moved tauri.pattern to app.security.pattern . Removed tauri.bundle.updater object, and its fields have been moved to the updater plugin under plugins.updater object. Moved build.withGlobalTauri to app.withGlobalTauri . Moved tauri.bundle.dmg object to bundle.macOS.dmg . Moved tauri.bundle.deb object to bundle.linux.deb . Moved tauri.bundle.appimage object to bundle.linux.appimage . Removed all license fields from each bundle configuration object and instead added bundle.license and bundle.licenseFile . Renamed AppUrl to FrontendDist and refactored its variants to be more explicit. Renamed tauri.window.fileDropEnabeld to app.window.dragDropEnabled Migration As we try to make the migration from previous Tauri versions as smooth as possible, we have documentation available to guide you through the process. If you are migrating from a 1.x release please check out this migration guide . For upgrading from a 2.0 beta or release candidate version check out this migration guide . The Tauri v2 CLI includes a migrate command that automates most of the process and helps you finish the migration: npm yarn pnpm cargo npm install @tauri-apps/cli@next npm run tauri migrate yarn upgrade @tauri-apps/cli@next yarn tauri migrate pnpm update @tauri-apps/cli@next pnpm tauri migrate cargo install tauri-cli --version " ^2.0.0 " --locked cargo tauri migrate Rust Migration We can not automatically migrate your Rust code, so make sure to go through the documentation and rust docs of the 2.0 version. Call To Action If you are familiar with Tauri and have used it already during your journey, please take your time to check out the Github Discssions , Github Issues . Maybe you have already solved the issues your fellow newcomers to Tauri are experiencing right now. If you think that some of these problems you have seen are generic and should be documented somewhere we probably have the perfect place for it in our official documentation . To contribute improvements or additions we are open for PRs in the tauri-docs repository. Please make sure youâ€™ve read the guidelines for contribution though. If you are in the position to understand and translate the current documentation into your native language we appreciate content translations to our documentation. The repositories surrounding Tauri are also looking for contributors, especially we would love more maintainers and contributors to the plugin-workspace . The plugins are now a major part of the development and user experience of Tauri and all kind of help is welcome there. From discussing new plugin ideas, collaborating with others to write new plugins, contributing PRs to fix bugs in existing plugins or documenting weird workarounds and knowledge in the plugin readme or code. Roadmap You probably expect solid plans for the future and new cool ideas from us.
We currently have some in mind but have not committed to a roadmap beyond 2.x yet. We mainly want to focus on improving this major version with a better developer experience, better documentation and less impactful bugs. We want to improve especially the mobile development experience and make the whole flow from idea to published application as seamless as possible. Things on our radar for the future we feel we should mention at least: Providing or Bundling Chromium Embedded Framework (CEF) for Linux as an alternative to WebKit2GTK Servo as Tauri WebView ( POC in Wry ) If you want to collaborate on these ideas, please let us know and we will figure it out together. Tauri 2.0 Release Candidate Edit page Last updated: Oct 2, 2024 Previous All posts Next Tauri 2.0 Release Candidate Â© 2024 Tauri Contributors. CC-BY / MIT
