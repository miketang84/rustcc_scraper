https://rust-gcc.github.io/2024/09/20/reusing-rustc-components.html
-->>-->>
GCC Front-End For Rust Alternative Rust Compiler for GCC View the Project on GitHub (Re)Using rustc components in gccrs In order to speed up development, as well as make sure gccrs exposes the exact same behavior as rustc in critical compiler passes, we decided last year to start reusing components and crates from the official Rust compiler where possible. These components range from external crates used for certain nightly options to internal rustc workspace packages. As expected, these components are written in Rust - which poses an interesting challenge for gccrs , a compiler written in C++, to be able to use them. The goal of this blogpost is to explore some of these components, explain why we are reusing them, and talk about how they will be integrated into the compiler once it is more complete. Which components? The first rustc component that was added to gccrs was rustc_parse_format , which we integrated at the beginning of the year in 2024. The role of this crate is to parse “Rust format strings” - which correspond to the various string templates used in string formatting and inline assembly. The crate should parse the template string, as well as each of the “pieces” used in the template string. For example, when looking at the following code: println! ( "Hello {ferris}!" ) the parser will emit three “pieces” - two for the static strings "Hello " and "!" , and one for the named argument ferris . Slightly simplified, the resulting vector will look like this: vec! [ Piece :: Static ( "Hello " ), Piece :: ArgumentNamed ( ferris , Trait :: Display ), Piece :: Static ( "!" ), ] Once we get these pieces back into the compiler, we can generate Rust code to call into core::fmt functions, so that at runtime your code will correctly call into the proper formatting traits like Display , Debug and so on. For the version of the language we are targeting, that generated code looks something like this: io :: _print ( fmt :: Arguments :: new_v1 ( & [ "Hello, " , "! \n " ], & [ fmt :: ArgumentV1 :: new ( & ferris , fmt :: Display :: fmt )] ) ); We could rewrite the parser from scratch, as rustc_parse_format is a tiny component and not terribly difficult to implement. But tweaking the build system to allow the reuse of that component, as well as writing the various Rust <-> C++ interfaces needed for interacting with the crate , helped pave the way for the most crucial of the components we are currently reusing - polonius , the next generation Rust borrow-checker, which you can read more about here . It can already be used on rustc with the nightly -Z polonius option. It is currently being rewritten, and not stable yet, but will eventually allow a couple more constructs which are rejected by the current borrow-checking algorithm while still being just as correct. We plan on adding more components to rustc in the future where possible. For example, there are currently efforts towards making a new trait solver for rustc - if separate enough from the compiler, it could be integrated and used by gccrs to perform trait-solving on our internal representation. Similarly, Jack Wrenn gave a fantastic talk at RustConf 2024 detailling safe-transmutes . Talking with Jack afterwards revealed that the algorithm powering the project is quite separate from the compiler. It uses its own graph representation, which is built from rustc ’s internal representation, but could also be built using gccrs ’! While we do want to encourage sharing between the two projects, it is not possible to reuse any component we want from rustc - The two compilers’ internal representations are extremely different, and converting back-and-forth from one to the other would be extremely costly. A simple but really annoying example of this lies in our AST structure, namely for representing the “block” expressions used in Rust: let result = { let x = heavy_computation (); let y = complex_math (); x + y } In rustc , the structure used looks like this (taken from rustc’s github) : pub struct Block { pub stmts : ThinVec < Stmt > , pub id : NodeId , ... } So for the code above, we’d have the following: Block { stmts : [ LetStmt ( ... ), LetStmt ( ... ), ArithmeticOperation ( ... ) ], id : ... } Whereas in gccrs , we use the following class: class BlockExpr : public ExprWithBlock { std :: vector < std :: unique_ptr < Stmt >> statements ; std :: unique_ptr < Expr > expr ; ... }; so the previous code snippet would be represented as this: BlockExpr { statements : [ LetStmt ( ... ), LetStmt ( ... ) ], expr : ArithmeticOperation ( ... ) } In rustc , expressions can be statements - hence, the last expression of a block can simply be represented as a statement. In gccrs , this isn’t the case, so we have to represent the tail expression as a separate member. Obviously, this has repercussions on how certain algorithms in both compilers should treat block expressions, and thus cannot be used interchangeably. Why is it important to be the exact same as rustc? Borrow-checking is an extremely complex subject, and a core part of the Rust programming language. It is important that gccrs gets it right, and it is important for us not to introduce subtle differences with rustc for such a crucial error pass. Instead of rolling out our own borrow-checking algorithm, reusing one which will be used by rustc allows us to at least reduce the amount of differences we will introduce. Of course, we still need to be extremely careful when creating the information used by polonius , and to test the output extensively. But we already know that polonius itself has been tested extensively within rustc , and will continue to be tested once it gets integrated into the official compiler. This similar reasoning can be applied to the future trait-solver. The same reasoning can be applied to trait-solving, and other user-facing, complex compiler passes. While we currently have a trait-solver, and can use it to typecheck real-world Rust code, it will not be close to the work done by a dedicated team over multiple years to achieve next generation trait-solving . For string templating, making sure that we parse template string properly is important, as the compiler needs to emit code calling into Rust’s standard library. By using the exact same parser crate, we can be sure that we generate the same runtime calls to the standard library’s formatting module, thus helping us ensure users will have the same behavior with rustc and gccrs when using string formatting. This also helps ensure that inline assembly nodes are constructed properly, as rustc uses the same crate to parse them. How do we use them? The components are written in Rust. We are writing a Rust compiler. Seems like we could just… reuse our project to compile these components? And yes, we can! But not just yet. At the moment, gccrs is still a work in progress compiler, and cannot compile a lot of real-world Rust code out there - including rustc_parse_format and polonius-engine . For this reason, we currently rely on cargo and rustc to compile these crates for us, and we then link them to our compiler’s executable at the end of the compilation process. Once gccrs is more complete, we plan to integrate these crates to our compiler using the following bootstrapping process: First, we use a C++ compiler to build gccrs , disabling the borrow-checking pass of the compiler. It is important to ensure borrow-checking cannot be disabled at runtime using a command line flag, as this could have a negative impact on the Rust ecosystem - however, building gccrs without borrow-checking to use it as an intermediate compiler in our bootstrapping process is okay. Similarly, secret powers can be unlocked from rustc if you define certain environment variables, which among other things allow a stable compiler to compile the Rust standard library - which relies heavily on nightly Rust features. Since this intermediate bootstrapping compiler will also be built without any of the Rust components we plan on using, it will be quite limited. For example, its string formatting capabilities will be nil, and it will not be able to be used for regular Rust display operations - its sole purpose will be to build the polonius-engine crate. Other Rust components we may depend on will either be “mocked”, or replaced by an alternative, simpler and less complete re-implementation in C++. Once this intermediate compiler is built, we use it to compile polonius , as well as the rest of the Rust components we use. We can then use these crates and link them to gccrs , giving us a proper compiler with borrow-checking enabled, and string formatting capabilities. To make sure the crates we have compiled are valid, we need to compile them once again with our newly-built complete compiler, or exit the bootstrapping process if this fails. And voila! We now have a Rust compiler, with Rust components inside it. Dogfed .
======>
https://old.reddit.com/r/rust/comments/1fqfij3/dynamic_compilation_for_highperformance_computing/
-->>-->>
I am interesting in using Rust for some scientific computing in optimization, particularly in solving discrete optimization problems. In my use case I would write an algorithm to solve an arbitrary DO problem, then load the specific numbers in and solve it. Is there a way to easily/automatically recompile an algorithm with hardcoded values in order to improve performance? Would this even speed things up that much?   
   

======>
https://old.reddit.com/r/rust/comments/1fqd6i3/learning_by_doing/
-->>-->>
The main way ive learned programming languages in the past is by doing things in small parts and modifying simple existing projects and seeing results quickly. Are there similar resources to this for rust? -- maybe something similar to rustlings?   

   Sorry if it sounds a bit vague   
   

======>
https://crates.io/crates/ftag
-->>-->>

======>
https://github.com/emilk/egui/releases/tag/0.29.0
-->>-->>
Releases 0.29.0 0.29.0 - Multipass, `UiBuilder`, & visual improvements Latest Latest Compare Choose a tag to compare Could not load tags Nothing to show {{ refName }} default Loading View all tags emilk released this 26 Sep 13:35 0.29.0 59d7183 egui is an easy-to-use immediate mode GUI for Rust that runs on both web and native. Try it now: https://www.egui.rs/ egui development is sponsored by Rerun , a startup building an SDK for visualizing streams of multimodal data. egui changelog ✨ Highlights This release adds initial support for multi-pass layout, which is a tool to circumvent a common limitation of immediate mode . You can use the new UiBuilder::sizing_pass ( #4969 ) to instruct the Ui and widgets to shrink to their minimum size, then store that size. Then call the new Context::request_discard ( #5059 ) to discard the visual output and do another pass immediately after the current finishes. Together, this allows more advanced layouts that is normally not possible in immediate mode. So far this is only used by egui::Grid to hide the "first-frame jitters" that would sometimes happen before, but 3rd party libraries can also use it to do much more advanced things. There is also a new UiBuilder for more flexible construction of Ui s ( #4969 ). By specifying a sense for the Ui you can make it respond to clicks and drags, reading the result with the new Ui::response ( #5054 ). Among other things, you can use this to create buttons that contain arbitrary widgets. 0.29 also adds improve support for automatic switching between light and dark mode. You can now set up a custom Style for both dark and light mode, and have egui follow the system preference ( #4744 #4860 ). There also has been several small improvements to the look of egui: Fix vertical centering of text (e.g. in buttons) ( #5117 ) Sharper rendering of lines and outlines ( #4943 ) Nicer looking text selection, especially in light mode ( #5017 ) The new text selection What text selection used to look like 🧳 Migration id_source is now called id_salt everywhere ( #5025 ) Ui::new now takes a UiBuilder ( #4969 ) Deprecated (replaced with UiBuilder ): ui.add_visible_ui ui.allocate_ui_at_rect ui.child_ui ui.child_ui_with_id_source ui.push_stack_info ⭐ Added Create a UiBuilder for building Ui s #4969 by @emilk Add egui::Sides for  adding UI on left and right sides #5036 by @emilk Make light & dark visuals customizable when following the system theme #4744 #4860 by @bash Interactive Ui :s: add UiBuilder::sense and Ui::response #5054 by @lucasmerlin Add a menu button with text and image #4748 by @NicolasBircksZR Add Ui::columns_const() #4764 by @v0x0g Add Slider::max_decimals_opt #4953 by @bircni Add Label::halign #4975 by @rustbasic Add ui.shrink_clip_rect #5068 by @emilk Add ScrollArea::scroll_bar_rect #5070 by @emilk Add Options::input_options for click-delay etc #4942 by @girtsf Add WidgetType::RadioGroup #5081 by @bash Add return value to with_accessibility_parent #5083 by @bash Add Ui::with_visual_transform #5055 by @lucasmerlin Make Slider and DragValue compatible with NonZeroUsize etc #5105 by @emilk Add Context::request_discard for multi-pass layouts #5059 by @emilk Add UI to modify FontTweak live #5125 by @emilk Add Response::intrinsic_size to enable better layout in 3rd party crates #5082 by @lucasmerlin Add support for mipmap textures #5146 by @nolanderc Add DebugOptions::show_unaligned #5165 by @emilk Add Slider::clamping for precise clamp control #5119 by @emilk 🚀 Performance Optimize Color32::from_rgba_unmultiplied with LUT #5088 by @YgorSouza 🔧 Changed Rename id_source to id_salt #5025 by @bircni Avoid some Id clashes by seeding auto-ids with child id #4840 by @ironpeak Nicer looking text selection, especially in light mode #5017 by @emilk Fix blurry lines by aligning to pixel grid #4943 by @juancampa Center-align all text vertically #5117 by @emilk Clamp margin values in Margin::ui #4873 by @rustbasic Make scroll_to_* animations configurable #4305 by @lucasmerlin Update Button to correctly align contained image #4891 by @PrimmR Deprecate ahash re-exports #4979 by @oscargus Fix: Ensures correct IME behavior when the text input area gains or loses focus #4896 by @rustbasic Enable rustdoc generate-link-to-definition feature on docs.rs #5030 by @GuillaumeGomez Make some Memory methods public #5046 by @bircni Deprecate ui.set_sizing_pass #5074 by @emilk Export module egui::frame #5087 by @simgt Use log crate instead of eprintln & remove some unwraps #5010 by @bircni Fix: Event::Copy and Event::Cut behave as if they select the entire text when there is no selection #5115 by @rustbasic 🐛 Fixed Prevent text shrinking in tooltips; round wrap-width to integer #5161 by @emilk Fix bug causing tooltips with dynamic content to shrink #5168 by @emilk Remove some debug asserts #4826 by @emilk Handle the IME event first in TextEdit to fix some bugs #4794 by @rustbasic Slider: round to decimals after applying step_by #4822 by @AurevoirXavier Fix: hint text follows the alignment set on the TextEdit #4889 by @PrimmR Request focus on a TextEdit when clicked #4991 by @Zoxc Fix Id clash in Frame styling widget #4967 by @YgorSouza Prevent ScrollArea contents from exceeding the container size #5006 by @DouglasDwyer Fix bug in size calculation of truncated text #5076 by @emilk Fix: Make sure RawInput::take clears all events, like it says it does #5104 by @emilk Fix DragValue range clamping #5118 by @emilk Fix: panic when dragging window between monitors of different pixels_per_point #4868 by @rustbasic eframe changelog ✨ Highlights Upgrade winit to 0.30 ( #4849 #4939 ) Fix virtual keyboard on (mobile) web ( #4848 #4855 ) 🧳 Migration WebRunner::start now expects a HtmlCanvasElement rather than the id of it ( #4780 ) NativeOptions::follow_system_theme and default_theme is gone, and is now in egui::Options instead ( #4860 ) ⭐ Added Conditionally propagate web events using a filter in WebOptions #5056 by @liamrosenfeld 🔧 Changed Pass HtmlCanvasElement element directly in WebRunner::start #4780 by @jprochazk Upgrade winit to 0.30.2 #4849 #4939 by @ArthurBrussee Allow non- static eframe::App lifetime #5060 by @timstr Improve glow context switching #4814 by @rustbasic Ignore viewport size/position on iOS #4922 by @frederik-uni Update web-sys & wasm-bindgen #4980 by @bircni Remove the need for setting web_sys_unstable_apis #5000 by @emilk Remove the directories dependency #4904 by @YgorSouza Update to wgpu 22.1 #4964 by @wumpf & #4847 by @KeKsBoTer Wgpu paint callback now gets a wgpu::RenderPass<'static> , making it easier to insert resources not owned by CallbackResources #5149 by @wumpf 🐛 Fixed Fix: call save when hiding web tab, and update when focusing it #5114 by @emilk Force canvas/text input focus on touch for iOS web browsers #4848 by @BKSalman Fix virtual keyboard on (mobile) web #4855 by @micmonay Fix: Backspace not working after IME input #4912 by @rustbasic Fix iOS build, and add iOS step to CI #4898 by @lucasmerlin Fix iOS compilation of eframe #4851 by @ardocrat Fix crash when changing viewport settings #4862 by @pm100 Fix eframe centering on multiple monitor systems #4919 by @VinTarZ Fix viewport not working when minimized #5042 by @rustbasic Clarified eframe::run_simple_native() persistence #4846 by @tpstevens Assets 2 Loading 25 torokati44, TheRustyPickle, ardura, ales-tsurko, Swarkin, lucasmerlin, dimlev, ethan-descDNA, bluurryy, fh-klaus, and 15 more reacted with hooray emoji 16 torokati44, zachbateman, sevonj, TheRustyPickle, AlexanderARodin, quietvoid, lucasmerlin, dimlev, ethan-descDNA, fh-klaus, and 6 more reacted with heart emoji All reactions 25 reactions 16 reactions 31 people reacted
======>
https://old.reddit.com/r/rust/comments/1fq2jym/how_to_suggest_a_feature_for_rust/
-->>-->>
Hi, i have an idea for a really simple new feature for rust that i could implement by myself.   

   How is the process to submit a feature suggestion/implementation?   
   

======>
https://josephg.com/blog/rewriting-rust/
-->>-->>
Seph 26 Sep 2024 on rust | programming Rewriting Rust The Rust programming language feels like a first generation product. You know what I mean. Like the first iPhone - which was amazing by the way . They made an entire operating system around multitouch. A smart phone with no keyboard. And a working web browser. Within a few months, we all realised what the iPhone really wanted to be. Only, the first generation iphone wasn't quite there. It didn't have 3G internet. There was no GPS chip. And there was no app store. In the next few years, iPhones would get a lot better. Rust feels a bit like that first iPhone. I fell in love with Rust at the start. Algebraic types? Memory safety without compromising on performance? A modern package manager? Count me in. But now that I've been programming in rust for 4 years or so, it just feels like its never quite there. And I don't know if it will ever be there. Progress on the language has slowed so much . When I first started using it, every release seemed to add new, great features in stable rust. Now? Crickets. The rust "unstable book" lists 700 different unstable features - which presumably are all implemented, but which have yet to be enabled in stable rust. Most of them are changes to the standard library - but seriously. Holy cow. How much of this stuff will ever make it into the language proper? The rust RFC process is a graveyard of good ideas. Features like Coroutines . This RFC is 7 years old now. Make no mistake - coroutines are implemented in the compiler. They're just, not available for us "stable rust" peasants to use. If coroutines were a child, they would be in grade school by now. At this point, the coroutines RFC has lasted longer than World War 1 or 2. I suspect rust is calcifying because its consensus process just doesn't scale. Early on, rust had a small group of contributors who just decided things. The monsters. Now, there are issue threads like this , in which 25 smart, well meaning people spent 2 years and over 200 comments trying to figure out how to improve Mutex . And as far as I can tell, in the end they more or less gave up. Maybe this is by design. Good languages are stable languages. It might be time to think of rust as a fully baked language - warts and all. Python 2.7 for life. But that doesn't change anything for me. I want a better rust, and I feel powerless to make that happen. Where are my coroutines? Even javascript has coroutines . Fantasy language Sometimes I lie awake at night fantasising about forking the compiler. I know how I'd do it. In my fork, I'd leave all the rust stuff alone and but make my own "seph" edition of the rust language. Then I could add all sorts of breaking features to that edition. So long as my compiler still compiles mainline rust as well, I could keep using all the wonderful crates on Cargo. I think about this a lot. If I did it, here's what I'd change: Function traits (effects) Rust has traits on structs. These are used in all sorts of ways. Some are markers. Some are understood by the compiler (like Copy ). Some are user defined. Rust should also define a bunch of traits for functions. In other languages, function traits are called "effects". This sounds weird at first glance - but hear me out. See, there's lots of different "traits" that functions have. Things like: Does the function ever panic? Does the function have a fixed stack size? Does the function run to the end, or does it yield / await? If the function is a coroutine, what is the type of the continuation? Is the function "pure" (ie, the same input produces the same output, and it has no side effects) Does the function (directly or indirectly) run unsafe code in semi-trusted libraries? Is the function guaranteed to terminate? And so on. A function's parameters and return type are just associated types on the function: fn some_iter() -> impl Iterator<Item = usize> {  
    vec![1,2,3].into_iter()
}

fn main() {  
    // Why doesn't this work already via FnOnce?
    let x: some_iter::Output = some_iter();
} TAIT eat your heart out. Exposing these properties is super useful. For example, the linux kernel wants to guarantee (at compile time) that some block of code will never panic. This is impossible to do in rust today. But using function traits, we could explicitly mark a function as being able - or unable - to panic: #[disallow(Panic)] // Syntax TBD.
fn some_fn() { ... } And if the function does anything which could panic (even recursively), the compiler would emit an error. The compiler already sort of implements traits on functions, like Fn , FnOnce and FnMut . But for some reason they're anemic. (Why??) I want something like this: /// Automatically implemented on all functions.
trait Function {  
  type Args,
  type Output,
  type Continuation, // Unit type () for normal functions
  // ... and so on.

  fn call_once(self, args: Self::Args) -> Self::Output;
}

trait NoPanic {} // Marker trait, implemented automatically by the compiler.

/// Automatically implemented on all functions which don't recurse.
trait KnownStackSize {  
  const STACK_SIZE: usize,
} Then you could write code like this: fn some_iter() -> impl Iterator<Item = usize> {  
  vec![1,2,3].into_iter();
}

struct SomeWrapperStruct {  
  iter: some_iter::Output, // In 2024 this is still impossible in stable rust.
} Or with coroutines: coroutine fn numbers() -> impl Iterator<Item = usize> {  
  yield 1;
  yield 2;
  yield 3;
}

coroutine fn double<I: Iterator<Item=usize>>(inner: I) -> impl Iterator<Item = usize> {  
  for x in inner {
    yield x * 2;
  }
}

struct SomeStruct {  
  // Suppose we want to store the iterator. We can name it directly:
  iterator: double<numbers>::Continuation,
} Or, say, take a function parameter but require that the parameter itself doesn't panic: fn foo<F>(f: F)  
    where F: NoPanic + FnOnce() -> String
{ ... } Yoshua Wuyts has an excellent talk & blog post going into way more detail about effects - why they're useful and how this could work. Compile-time Capabilities Most rust projects pull in an insane number of 3rd party crates. Most of these crates are small utility libraries - like the human-size crate which formats file sizes for human consumption. Great stuff! But unfortunately, all of these little crates add supply chain risk. Any of those authors could push out an update which contains malicious code - cryptolockering our computers, our servers or sneaking bad code into our binaries. I think this problem is similar to the problem of memory safety. Sure - its sometimes useful to write memory-unsafe code. The rust standard library is full of it. But rust's unsafe keyword lets authors opt in to potentially unsafe things. We only add unsafe blocks when its necessary. Lets do the same thing for privileged function calls - like reading and writing to and from the filesystem or the network. This is useful stuff, but its potentially dangerous. Developers should actively whitelist code that is allowed to call these functions. To implement this, first we want to add marker traits to all the security-sensitive functions in the standard library (opening a file from a string, exec , FFI, opening network connections, most unsafe functions that interact with raw pointers, and so on). So, for example, std::fs::write(path, contents) writes to an arbitrary path on disk with the credentials of the user. We add some #[cap(fs_write)] marker tag to the function itself, marking that this can only be called from code which is in some way trusted. The compiler automatically "taints" any other functions which call write in the entire call tree. Suppose I call a function in a 3rd party crate which needs the fs_write capability. In order to call that function, I need to explicitly whitelist that call. (Either by adding the permission explicitly in my Cargo.toml or maybe with an annotation at the call site). So, lets say the foo crate contains a function like this. The function will be marked (tainted) with the "writes to filesystem" tag: // In crate `foo`.

// (this function is implicitly tagged with #[cap(fs_write)])
pub fn do_stuff() {  
  std::fs::write("blah.txt", "some text").unwrap();
} When I try to run that function from my code: fn main() {  
  foo::do_stuff();
} The compiler can give me a nice rusty error, like this: Error: foo::do_stuff() writes to the local filesystem, but the `foo` crate has not been trusted with this capability in Cargo.toml.

Tainted by this line in do_stuff:

  std::fs::write("blah.txt", "some text").unwrap();

Add this to your Cargo.toml to fix:

foo = { version = "1.0.0", allow_capabilities: ["fs_write"] } Obviously, most uses of unsafe would also require explicit whitelisting. Most crates I use - like human-size or serde don't need any special capabilities to work. So we don't need to worry so much about their authors "turning evil" and adding malicious code to our software. Reducing the supply chain risk from the 100 or so crates I currently transitively depend on down to just a few would be massive. This is a very simple, static way that capabilities could be introduced to Rust. But it might be possible & better to change privileged code to require an extra Capability parameter (some unit struct type). And heavily restrict how Capability objects can be instantiated. Eg: struct FsWriteCapability;

impl FsWriteCapability {  
    fn new() { Self } // Only callable from the root crate
}

// Then change std::fs::write's signature to this:
pub fn write(path: Path, contents: &[u8], cap: FsWriteCapability) { ... } This requires more boilerplate, but its much more flexible. (And obviously, we'd also need to, somehow, apply a similar treatment to build.rs scripts and unsafe blocks.) The result of all of this is that utility crates become "uncorruptable". Imagine if crates.io is hacked and serde is maliciously updated to include with cryptolocker code. Today, that malicious code would be run automatically on millions of developer machines, and compiled into programs everywhere. With this change, you'd just get a compiler error. This is huge, and singlehandedly this one feature is probably worth the cost of forking rust. At least, to someone. (Anyone want to sponsor this work?) Pin, Move and Struct Borrows Feel free to skip this section if Pin & the borrow checker gives you a migraine. Pin in rust is a weird, complicated hack to work around a hole in the borrow checker. Its a band-aid from the land of bizzaro choices that only make sense when you need to maintain backwards compatibility at all costs. Its the reverse of the trait you actually want. It would make way more sense to have a Move marker trait (like Copy ) indicating objects which can move. But Pin isn't an actual trait. There's only Unpin (double negative now) and !Unpin - which is not-not-not- Move . For example impl !Unpin for PhantomPinned . Is !Unpin the same as Pin ? Uhhhh, ... No? Because .. reasons? I get an instant headache when I think about this stuff. Here's the documentation for Unpin if you want to try your luck. Pin only applies to reference types. If you read through code which uses Pin a lot, you'll find unnecessary Box -ing of values everywhere . For example, in tokio , or helper libraries like ouroboros , async trait and self cell . The pain spreads. Any function that takes a pinned value needs the value wrapped using some horrible abomonation like Future::poll(self: Pin<&mut Self>, ..) . And then you need to figure out how to read the actual values out using projections, which are so complicated there are multiple crates for dealing with them. The pain cannot be confined. It spreads outwards, forever, corrupting everything. I swear, it took more effort to learn pinning in rust than it took me to learn the entire Go programming language. And I'm still not convinced I'm totally across it. And I'm not alone. I've heard the Fuchsia operating system project abandoned Rust for C++ in some parts because of how impossibly complex Pin makes everything. Why is Pin needed, anyway? We can write rust functions like this: fn main() {  
    let x = vec![1,2,3];
    let y = &x;

    //drop(x); // error[E0505]: cannot move out of `x` because it is borrowed
    dbg!(y);
} All variables in a rust function are actually, secretly in one of 3 different states: Normal (owned) Borrowed Mutably borrowed While a variable is borrowed ( y = &x ), you can't move, mutate or drop the variable. In this example, x is put into a special "borrowed" state throughout the lifetime of y . Variables in the "borrowed" state are pinned, immutable, and have a bunch of other constraints. This "borrowed state" is visible to the compiler, but its completely invisible to the programmer. You can't tell that something is borrowed until you try to compile your program. (Aside: I wish Rust IDEs made this state visible while programming!) But at least this program works . Unfortunately, there's no equivalent to this for structs. Lets turn the function async : async fn foo() {  
    let x = vec![1,2,3];
    let y = &x;

    some_future().await;

    dbg!(y);
} When you compile this, the compiler creates a hidden struct for you, which stores the suspended state of this function. It looks something like this: struct FooFuture {  
  x: Vec<usize>,
  y: &'_ Vec<usize>,
}

impl Future for FooFuture { ... } x is borrowed by y . So it needs to be placed under all the constraints of a borrowed variable: It must not move in memory. (It needs to be Pinned) It must be immutable We can't take mutable references to x (because of the & xor &mut rule). x must outlive y . But there's no syntax for this. Rust doesn't have syntax to mark a struct field as being in a borrowed state. And we can't express the lifetime of y . Remember: the rust compiler already generates and uses structs like this whenever you use async functions. The compiler just doesn't provide any way to write code like this ourselves. Lets just extend the borrow checker and fix that! I don't know what the ideal syntax would be, but I'm sure we can come up with something. For example, maybe y gets declared as a "local borrow", written as y: &'Self::x Vec<usize> . The compiler uses that annotation to figure out that x is borrowed. And it puts it under the same set of constraints as a borrowed variable inside a function. This would also let you work with self-referential structs, like an Abstract Syntax Tree (AST) in a compiler: struct Ast {  
  source: String,
  ast_nodes: Vec<&'Self::source str>,
} This syntax could also be adapted to support partial borrows: impl Foo {  
  fn get_some_field<'a>(&'a self) -> &'a::some_field usize {
    &self.some_field
  }
} This isn't a complete solution. We'd also need a Move marker trait, to replace Pin . Any struct with borrowed fields can't be Moved - so it wouldn't have impl Move . I'd also consider a Mover trait, which would allow structs to intelligently move themselves in memory. Eg: trait Mover {  
  // Something like that.
  unsafe fn move(from: *Self, to: MaybeUninit<&mut Self>);
} We'd also need a sane, safe way to construct structs like this in the first place. I'm sure we can do better than MaybeUninit . Miguel Young de la Sota gave a fantastic talk a few years ago talking about Move in rust. But I think it would be much more "rusty" to lean on the borrow checker instead. If you ask me, Pin is a dead end solution. Rust already has a borrow checker. Lets use it for structs. Comptime This is a hot opinion. I haven't spent a lot of time with zig, but at least from a distance I adore comptime . In the rust compiler we essentially implement two languages: Rust and the Rust Macro language. (Well, arguably there's 3 - because proc macros). The Rust programming language is lovely. But the rust macro languages are horrible. But, if you already know rust, why not just use rust itself instead of sticking another language in there? This is the genius behind Zig's comptime . The compiler gets a little interpreter tacked on that can run parts of your code at compile time. Functions, parameters, if statements and loops can all be marked as compile-time code. Any non-comptime code in your block is emitted into the program itself. I'm not going to explain the feature in full here. Instead, take in just how gorgeous this makes Zig's std print function . Its entirely implemented using comptime. So when you write this in zig: pub fn main() void {  
    print("here is a string: '{s}' here is a number: {}\n", .{ a_string, a_number });
} print takes the format string as a comptime parameter, and parses it within a comptime loop. Aside from a couple keywords, the function is just regular zig code - familiar to anyone who knows the language. It just gets executed within the compiler. And the result? It emits this beauty: pub fn print(self: *Writer, arg0: []const u8, arg1: i32) !void {  
    try self.write("here is a string: '");
    try self.printValue(arg0);
    try self.write("' here is a number: ");
    try self.printValue(arg1);
    try self.write("\n");
    try self.flush();
} Read the full case study for more details. In comparison, I tried to look up how rust's println!() macro is implemented. But println! calls some secret format_args_nl function . I assume that function is hardcoded in the rust compiler itself. Its not a great look when even the rust compiler authors don't want to use rust's macro language. Weird little fixes Bonus round time. Here's some other little "nits" I'd love to fix while we're at it: impl<T: Copy> for Range<T> . If you know, you know. Fix derive with associated types . Full example here . Make if-let expressions support logical AND. Its so simple, so obvious, and so useful. This should work: // Compile error! We can't have nice things.
if let Some(x) = some_var && some_expr { } You can sort of work around this problem today as below, but its awkward to write, hard to read and the semantics are different from how normal if statements work because it lacks short-circuit evaluation. // check_foo() will run even if some_var is None.
if let (Some(x), true) = (some_var, check_foo()) { ... } Full example here . Rust's ergonomics for raw pointers are also uniquely horrible. When I work with unsafe code, my code should be as easy to read & write as humanly possible. But the rust compiler seems intent on punishing me for my sins. For example, if I have a reference to a struct in rust, I can write myref.x . But if I have a pointer, rust insists that I write (*myptr).x or, worse: (*(*myptr).p).y . Horrible. Horrible and entirely counterproductive. Unsafe code should be clear. I'd also change all the built in collection types to take an Allocator as a constructor argument. I personally don't like Rust's decision to use a global allocator. Explicit is better than implicit. Closing thoughts Thats all the ideas I have. I mean, async needs some love too. But there's so much to say on the topic that async deserves a post of its own. Unfortunately, most of these changes would be incompatible with existing rust. Even adding security capabilities would require a new rust edition, since it introduces a new way that crates can break semver compatibility. A few years ago I would have considered writing RFCs for all of these proposals. But I like programming more than I like dying slowly in the endless pit of github RFC comments. I don't want months of work to result in yet another idea in rust's landfill of unrealised dreams . Maybe I should fork the compiler and do it myself. Urgh. So many projects. If I could live a million lifetimes, I'd devote one to working on compilers. Joseph Gentle http://josephg.com Subscribe! All content copyright Seph © 2024 • All rights reserved. Proudly published with Ghost
======>
https://www.zdnet.com/article/rust-in-linux-now-progress-pitfalls-and-why-devs-and-maintainers-need-each-other/
-->>-->>
Business Home Business Enterprise Software Rust in Linux now: Progress, pitfalls, and why devs and maintainers need each other Where do Linux and Rust go from here? A roundtable of kernel developers share their thoughts. Written by Steven Vaughan-Nichols, Senior Contributing Editor Sept. 26, 2024 at 7:20 a.m. PT rank trend 1 Synchron now lets users control Amazon Alexa with their thoughts 2 OpenAI’s new o1 model preview aces ZDNET’s coding tests 3 Instagram makes teen accounts private by default 4 United Airlines to launch free onboard wifi via Starlink view trend report Jonathan Corbet, Linux kernel developer and LWN editor, at Open Source Summit Europe 2024. The Linux Foundation Prominent Linux kernel developers gathered to share insights on kernel development's current state and future at a recent roundtable discussion during the Open Source Summit Europe in Vienna. The panel, moderated by Jonathan Corbet, Linux kernel developer and co-founder of Linux Weekly News (LWN) , featured developers Alice Ryhl, a Google software engineer on the Android Rust team, Josef Bacik, tech lead for Meta 's kernel file system team, Anna-Maria Behnsen, a Linux kernel developer at Linutronix who's worked on real-time Linux, and Dan Williams, a member of Intel's Linux core kernel architecture team. Also: Linus Torvalds muses about maintainer gray hairs and the next 'King of Linux' The panel, in short, included people from several companies. In the Linux and open-source world, people work together across company borders all the time. These folks are also gainfully employed to work on Linux. Some say you can't make a living working on open-source software and Linux. That's not true. There's real money in Linux and open-source jobs . Much of the discussion centred on integrating Rust into the Linux kernel . At the Linux Kernel Maintainer Summit the day before, Corbet said: "There's been some frustration in some quarters about just how long it was taking. I think some people wanted Rust to take over the world more quickly than it has." At the Maintainer Summit, Linus Torvalds, who likes having Rust in Linux , observed that some kernel features, such as modversions , are currently incompatible with Rust but are being worked on. Ryhl, who works with Rust, expressed optimism about the progress despite acknowledging that it will take time for the integration to take place: "There are some things that I wish were already in and some things could have gone in faster, but things will always get better." Also: The Linux file system structure explained One problem Rust in the Linux kernel faces, said Willams, is that "kernel maintainers tend to be very conservative." They know C backward and forward, but they don't know Rust. So, they "don't know how to review this or debug that because they don't understand the code." Newsletters ZDNET Tech Today ZDNET's Tech Today newsletter is a daily briefing of the newest, most talked about stories, five days a week. Subscribe See all According to Linux and Rust developer Miguel Ojeda, who spoke at the Linux Plumbers Rust in Linux panel, the answer is for maintainers to work with Rust for Linux developers. The maintainers bring their understanding of the subsystem, while the Rust programmers bring their language expertise. By working together, the two groups can help bring Rust code into Linux. Rhyl agreed: "A successful approach for me is to combine a kernel developer and a Rust expert. I had a call with the maintainer, and we went through the patch together. We could learn from each other." That was an example of what can happen when things go well. Sometimes, however, they don't. Wedson Almeida, a Microsoft software engineer and one of the Rust for Linux maintainers, recently quit the project in a note to the Linux Kernel Mailing List (LKML) . He left because, "After almost four years, I find myself lacking the energy and enthusiasm I once had to respond to some of the nontechnical nonsense , so it's best to leave it up to those who still have it in them." Ojeda said that despite this, "The core Rust team is still growing." Also: The most popular programming languages in 2024 However, the panel agreed that a positive side effect of people working together is that it's led to changes in existing C APIs and documentation practices. By making people think about how Rust can help Linux, they've also had to dig deep into their own code and explain it. For example, Al Viro, the Linux Virtual Filesystem (VFS) maintainer, said Josef Bacik has reworked 65 pages of documentation. This, in turn, has made the associated C code much simpler for future developers to convert to. The documentation now gives clear rules on what the code does and why. Yet the panel also pointed out a critical issue: despite thousands of paid kernel developers, no one is funded specifically for documentation work. This is an all-too-well-known but often ignored problem with Linux and open-source documentation . Also: These Linux distributions are best for developers - here's why Corbet also observed that some of the tension around documentation comes from Rust and C's fundamentally different ways of dealing with things: If you look at how a C API in the kernel designs calls it this way, you have to make sure to call it this way, and that pointer better not be null, and don't touch that button over there, or the whole thing will explode. The Rust approach is that we will design the API, so your code will probably be correct if the compiler lets you call it. C just doesn't let you do that. But when we're trying to design Rust APIs for the kernel, they have to sit on top of these C APIs. And so there's a fundamental mismatch in the approach being taken, and I see that it's pushing back into the C APIs and trying to force changes there. I think the changes are good, but I think it creates some resistance from the maintainers of the existing APIs, who put decades into creating and using those APIs, know where the pitfalls are and can instinctively avoid them. Still, while not everyone is thrilled with Rust in Linux, progress is being made. At the Maintainers Summit, Torvalds said maintainers don't need to understand Rust to let it into a subsystem. After all, he pointed out, half ironically, " Nobody understands the memory-management subsystem, but everybody can work with it." Also: Linux and open-source documentation is a mess: Here's the solution Ojeda also remarked that some Linux distros, notably Debian and Ubuntu , are adopting Rust. In short, he concluded, "Rust is now in a good position." Rust may not have gotten into Linux as fast as some people wanted, but it's progressing well. Linux The best Linux laptops for consumers and developers Want to save your aging computer? Try these 5 Linux distributions The best distros for beginners How to enable Linux on your Chromebook (and why you should) The best Linux laptops for consumers and developers Want to save your aging computer? Try these 5 Linux distributions The best distros for beginners How to enable Linux on your Chromebook (and why you should) Editorial standards Show Comments Log In to Comment Community Guidelines Click to unmute Are you prepared for the future of AI, automation, and jobs? Are you prepared for the future of AI, automation, and jobs? Video Player is loading. Play Video Pause Skip Backward Skip Forward Next playlist item Unmute Current Time 0:34 / Duration 0:51 Loaded : 100.00% 0:34 Stream Type LIVE Seek to live, currently behind live LIVE Remaining Time - 0:17 1x Playback Rate Chapters Chapters Descriptions descriptions off , selected Captions captions settings , opens captions settings dialog captions off , selected en-US Share Audio Track en (Main) , selected Fullscreen This is a modal window. Beginning of dialog window. Escape will cancel and close the window. Text Color White Black Red Green Blue Yellow Magenta Cyan Opacity Opaque Semi-Transparent Text Background Color Black White Red Green Blue Yellow Magenta Cyan Opacity Opaque Semi-Transparent Transparent Caption Area Background Color Black White Red Green Blue Yellow Magenta Cyan Opacity Transparent Semi-Transparent Opaque Font Size 50% 75% 100% 125% 150% 175% 200% 300% 400% Text Edge Style None Raised Depressed Uniform Drop shadow Font Family Proportional Sans-Serif Monospace Sans-Serif Proportional Serif Monospace Serif Casual Script Small Caps Reset Done Close Modal Dialog End of dialog window. Close Modal Dialog This is a modal window. This modal can be closed by pressing the Escape key or activating the close button. This is a modal window. This modal can be closed by pressing the Escape key or activating the close button. Share: Facebook Twitter Direct Link Embed Code Close Modal Dialog Related Linus Torvalds muses about maintainer gray hairs and the next 'King of Linux' These Linux distributions are best for developers - here's why 5 Linux commands you should never run (and why)
======>
https://smallcultfollowing.com/babysteps/blog/2024/09/26/overwrite-trait/?utm_source=atom_feed#fnref:2
-->>-->>
Making overwrite opt-in #crazyideas 26 September 2024 What would you say if I told you that it was possible to (a) eliminate a lot of “inter-method borrow conflicts” without introducing something like view types and (b) make pinning easier even than boats’s pinned places proposal, all without needing pinned fields or even a pinned keyword? You’d probably say “Sounds great… what’s the catch?” The catch it requires us to change Rust’s fundamental assumption that, given x: &mut T , you can always overwrite *x by doing *x = /* new value */ , for any type T: Sized . This kind of change is tricky, but not impossible, to do over an edition. TL;DR We can reduce inter-procedural borrow check errors, increase clarity, and make pin vastly simpler to work with if we limit when it is possible to overwrite an &mut reference. The idea is that if you have a mutable reference x: &mut T , it should only be possible to overwrite x via *x = /* new value */ or to swap its value via std::mem::swap if T: Overwrite . To start with, most structs and enums would implement Overwrite , and it would be a default bound, like Sized ; but we would transition in a future edition to have structs/enums be !Overwrite by default and to have T: Overwrite bounds written explicitly. Structure of this series This blog post is part of a series: This first post will introduce the idea of immutable fields and show why they could make Rust more ergonomic and more consistent. It will then show how overwrites and swaps are the key blocker and introduce the idea of the Overwrite trait, which could overcome that. In the next post, I’ll dive deeper into Pin and how the Overwrite trait can help there. After that, who knows? Depends on what people say in response. 1 If you could change one thing about Rust, what would it be? People often ask me to name something I would change about Rust if I could. One of the items on my list is the fact that, given a mutable reference x: &mut SomeStruct to some struct, I can overwrite the entire value of x by doing *x = /* new value */ , versus only modifying individual fields like x.field = /* new value */ . Having the ability to overwrite *x always seemed very natural to me, having come from C, and it’s definitely useful sometimes (particularly with Copy types like integers or newtyped integers). But it turns out to make borrowing and pinning much more painful than they would otherwise have to be, as I’ll explain shortly. In the past, when I’ve thought about how to fix this, I always assumed we would need a new form of reference type, like &move T or something. That seemed like a non-starter to me. But at RustConf last week, while talking about the ergonomics of Pin , a few of us stumbled on the idea of using a trait instead. Under this design, you can always make an x: &mut T , but you can’t always assign to *x as a result. This turns out to be a much smoother integration. And, as I’ll show, it doesn’t really give up any expressiveness. Motivating example #1: Immutable fields In this post, I’m going to motivate the changes by talking about immutable fields . Today in Rust, when you declare a local variable let x = … , that variable is immutable by default 2 . Fields, in contrast, inherit their mutability from the outside: when a struct appears in a mut location, all of its fields are mutable. Not all fields are mutable, but I can’t declare that in my Rust code It turns out that declaring local variables as mut is not needed for the borrow checker — and yet we do it nonetheless, in part because it helps readability. It’s useful to see when a variable might change. But if that argument holds for local variables, it holds double for fields! For local variables, we can find all potential mutation just by searching one function. To know if a field may be mutated, we have to search across many functions. And for fields, precisely because they can be mutated across functions, declaring them as immutable can actually help the borrow checker to see that your code is safe. Idea: Declare fields as mutable So what if we extended the mutable declaration to fields? The idea would be that, in your struct, if you want to mutate fields, you have to declare them as mut . This would allow them to be mutated: but only if the struct itself appears in a mutable local field. For example, maybe I have an Analyzer struct that is created with some vector of datums and which has to compute the number of “important” ones: #[derive(Default)] struct Analyzer { /// Data being analyzed: will never be modified. data : Vec < Datum > , /// Number of important datums uncovered so far. mut important : usize , } As you can see from the struct declaration, the field data is declared as immutable. This is because we are only going to be reading the Datum values. The important field is declared as mut , indicating that it will be updated. When can you mutate fields? In this world, mutating a field is only possible when (1) the struct appears in a mutable location and (2) the field you are referencing is declared as mut . So this code compiles fine, because the field important is mut : let mut analyzer = Analyzer :: new (); analyzer . important += 1 ; // OK: mut field in a mut location But this code does not compile, because the local variable x is not: let x = Analyzer :: default (); x . important += 1 ; // ERROR: `x` not declared as mutable And this code does not compile, because the field data is not declared as mut : let mut x = Analyzer :: default (); x . data . clear (); // ERROR: field `data` is not declared as mutable Leveraging immutable fields in the borrow checker So why is it useful to declare fields as mut ? Well, imagine you have a method like increment_if_important , which checks if datum.is_important() is true and modifies the important flag if so: impl Analyzer { fn increment_if_important ( & mut self , datum : & Datum ) { if datum . is_important () { self . important += 1 ; } } } Now imagine you have a function that loops over self.data and calls increment_if_important on each item: impl Analyzer { fn count_important ( & mut self ) { for datum in & self . data { self . increment_if_important ( datum ); } } } I can hear the experienced Rustaceans crying out in pain now. This function, natural as it appears, will not compile in Rust today. Why is that? Well, we have a shared borrow on self.data but we are trying to call an &mut self function, so we have no way to be sure that self.data will not be modified. But what about immutable fields? Doesn’t that solve this? Annoyingly, immutable fields on their own don’t change anything! Why? Well, just because you can’t write to a field directly doesn’t mean you can’t mutate the memory it’s stored in. For example, maybe I write a malicious version of increment_if_important : impl Analyzer { fn malicious_increment_if_important ( & mut self , datum : & Datum ) { * self = Analyzer :: default (); } } This version never directly accesses the field data , but it just writes to *self , and hence it has the same impact. Annoying! Generics: why we can’t trivially disallow overwrites Maybe you’re thinking “well, can’t we just disallow overwriting *self if there are fields declared mut ?” The answer is yes, we can, and that’s what this blog post is about. But it’s not so simple as it sounds, because we are changing the “basic contract” that all Rust types currently satisfy. In particular, Rust today assumes that if you have a reference x: &mut T and a value v: T , you can always do *x = v and overwrite the referent of x . That means I could can write a generic function like set_to_default : fn set_to_default < T : Default > ( r : & mut T ) { * r = T :: default (); } Now, since Analyzer implements Default , I can make increment_if_important call set_to_default . This will still free self.data , but it does it in a sneaky way, where we can’t obviously tell that the value being overwritten is an instance of a struct with mut fields: impl Analyzer { fn malicious_increment_if_important ( & mut self , datum : & Datum ) { // Overwrites `self.data`, but not in an obvious way set_to_default ( self ); } } Recap So let’s step back and recap what we’ve seen so far: If we could distinguish which fields were mutable and which were definitely not, we could eliminate many inter-function borrow check errors 3 . However, just adding mut declarations is not enough, because fields can also be mutated indirectly. Specifically, when you have a &mut SomeStruct , you can overwrite with a fresh instance of SomeStruct or swap with another &mut SomeStruct , thus changing all fields at once. Whatever fix we use has to consider generic code like std::mem::swap , which mutates an &mut T without knowing precisely what T is. Therefore we can’t do something simple like looking to see if T is a struct with mut fields 4 . The trait system to the rescue My proposal is to introduce a new, built-in marker trait called Overwrite : /// Marker trait that permits overwriting /// the referent of an `&mut Self` reference. #[marker] // <-- means the trait cannot have methods trait Overwrite : Sized {} The effect of Overwrite As a marker trait, Overwrite does not have methods, but rather indicates a property of the type. Specifically, assigning to a borrowed place of type T requires that T: Overwrite is implemented. For example, the following code writes to *x , which has type T ; this is only legal if T: Overwrite : fn overwrite < T > ( x : & mut T , t : T ) { * x = t ; // <— requires `T: Overwrite` } Given this this code compiles today, this implies that a generic type parameter declaration like <T> would require a default Overwrite bound in the current edition. We would want to phase these defaults out in some future edition, as I’ll describe in detail later on. Similarly, the standard library’s swap function would require a T: Overwrite bound, since it (via unsafe code) assigns to *x and *y : fn swap < T > ( x : & mut T , y : & mut T ) { unsafe { let tmp : T = std :: ptr :: read ( x ); std :: ptr :: write ( * x , * y ); // overwrites `*x`, `T: Overwrite` required std :: ptr :: write ( * y , tmp ); // overwrites `*y`, `T: Overwrite` required } } Overwrite requires Sized The Overwrite trait requires Sized because, for *x = /* new value */ to be safe, the compiler needs to ensure that the place *x has enough space to store “new value”, and that is only possible when the size of the new value is known at compilation time (i.e., the type implements Sized ). Overwrite only applies to borrowed values The overwrite trait is only needed when assigning to a borrowed place of type T . If that place is owned, the owner is allowed to reassign it, just as they are allowed to drop it. So e.g. the following code compiles whether or not SomeType: Overwrite holds: let mut x : SomeType = /* something */ ; x = /* something else */ ; // <— does not require that `SomeType: Overwrite` holds Subtle: Overwrite is not infectious Somewhat surprisingly, it is ok to have a struct that implements Overwrite which has fields that do not. Consider the types Foo and Bar , where Foo: Overwrite holds but Bar: Overwrite does not: struct Foo ( Bar ); struct Bar ; impl Overwrite for Foo { } impl ! Overwrite for Bar { } The following code would type check: let foo = & mut Foo ( Bar ); // OK: Overwriting a borrowed place of type `Foo` // and `Foo: Overwrite` holds. * foo = Foo ( Bar ); However, the following code would not: let foo = & mut Foo ( Bar ); // ERROR: Overwriting a borrowed place of type `Bar` // but `Bar: Overwrite` does not hold. foo . 0 = Bar ; Types that do not implement Overwrite can therefore still be overwritten in memory, but only as part of overwriting the value in which they are embedded. In the FAQ I show how this non-infectious property preserves expressiveness. 5 Who implements Overwrite ? This section walks through which types should implement Overwrite . Copy implies Overwrite Any type that implements Copy would automatically implement Overwrite : impl < T : Copy > Overwrite for T { } (If you, like me, get nervous when you see blanket impls due to coherence concerns, it’s worth noting that RFC #1268 allows for overlapping impls of marker traits, though that RFC is not yet fully implemented nor stable. It’s not terribly relevant at the moment anyway.) “Pointer” types are Overwrite Types that represent pointers all implement Overwrite for all T : &T &mut T Box<T> Rc<T> Arc<T> *const T *mut T dyn , [] , and other “unsized” types do not implement Overwrite Types that do not have a static size, like dyn and [] , do not implement Overwrite . Safe Rust already disallows writing code like *x = … in such cases. There are ways to do overwrites with unsized types in unsafe code, but they’d have to prove various bounds. For example, overwriting a [u32] value could be ok, but you have to know the length of data. Similarly swapping two dyn Value referents can be safe, but you have to know that (a) both dyn values have the same underlying type and (b) that type implements Overwrite . Structs and enums The question of whether structs and enums should implement Overwrite is complicated because of backwards compatibility. I’m going to distinguish two cases: Rust 2021, and Rust Next, which is Rust in some hypothetical future edition (surely not 2024, but maybe the one after that). Rust 2021. Struct and enum types in Rust 2021 implement Overwrite by default. Structs could opt-out from Overwrite with an explicit negative impl ( impl !Overwrite for S ). Integrating mut fields. Structs that have opted out from Overwrite require mutable fields to be declared as mut . Fields not declared as mut are immutable. This gives them the nicer borrow check behavior. 6 Rust Next. In some future edition, we can swap the default, with fields being !Overwrite by default and having to opt-in to enable overwrites. This would make the nice borrow check behavior the default. Futures and closures Futures and closures can implement Overwrite iff their captured values implement Overwrite , though in future editions it would be best if they simple do not implement Overwrite . Default bounds and backwards compatibility The other big backwards compatibility issue has to do with default bounds. In Rust 2021, every type parameter declared as T implicitly gets a T: Sized bound. We would have to extend that default to be T: Sized + Overwrite . This also applies to associated types in trait definitions and impl X types. 7 Interestingly, type parameters declared as T: ?Sized also opt-out from Overwrite . Why is that? Well, remember that Overwrite: Sized , so if T is not known to be Sized , it cannot be known to be Overwrite either. This is actually a big win. It means that types like &T and Box<T> can work with “non-overwrite” types out of the box. Associated type bounds are annoying, but perhaps not fatal Still, the fact that default bounds apply to associated types and impl Trait is a pain in the neck. For example, it implies that Iterator::Item would require its items to be Overwrite , which would prevent you from authoring iterators that iterate over structs with immutable fields. This can to some extent be overcome by associated type aliases 8 (we could declare Item to be a “virtual associated type”, mapping to Item2021 in older editions, which require Overwrite , and ItemNext in newer ones, which do not). Frequently asked questions OMG endless words. What did I just read? Let me recap! It would be more declarative and create fewer borrow check conflicts if we had users declare their fields as mut when they may be mutated and we were able to assume that non- mut fields will never be mutated. If we were to add this, in the current Rust edition it would obviously be opt-in. But in a future Rust edition it would become mandatory to declare fields as mut if you want to mutate them. But to do that, we need to prevent overwrites and swaps. We can do that by introducing a trait, Overwrite , that is required to a given location. In the current Rust edition, this trait would be added by default to all type parameters, associated types, and impl Trait bounds; it would be implemented by all structs, enums, and unions. In a future Rust edition, the trait would no longer be the default, and structs, enums, and unions would have to explicitly implement if they want to be overwriteable. This change doesn’t seem worth it just to get immutable fields. Is there more? But wait, there’s more! Oh, you just said that. Yes, there’s more. I’m going to write a follow-up post showing how opting out from Overwrite eliminates most of the ergonomic pain of using Pin . In “Rust Next”, who would ever implement Overwrite manually? I said that, in Rust Next, types should be !Overwrite by default and require people to implement Overwrite manually if they want to. But who would ever do that? It’s a good question, because I don’t think there’s very much reason to. Because Overwrite is not infectious, you can actually make a wrapper type… #[repr(transparent)] struct ForceOverwrite < T > { t : T } impl < T > Overwrite for ForceOverwrite < T > { } …and now you can put values of any type X into an ForceOverwrite <X> which can be reassigned. This pattern allows you to make “local” use of overwrite, for example to implement a sorting algorithm (which has to do a lot of swapping). You could have a sort function that takes an &mut [T] for any T: Ord ( Overwrite not required): fn sort < T : Ord > ( data : & mut [ T ]) Internally, it can safely transmute the &mut [T] to a &mut [ForceOverwrite<T>] and sort that . Note that at no point during that sorting are we moving or overwriting an element while it is borrowed (the slice that owns it is borrowed, but not the elements themselves). What is the relationship of Overwrite and Unpin ? I’m still puzzling that over myself. I think that Overwrite is “morally the same” as Unpin , but it is much more powerful (and ergonomic) because it is integrated into the behavior of &mut (of course, this comes at the cost of a complex backwards compatibility story). Let me describe it this way. Types that do not implement Overwrite cannot be overwritten while borrowed, and hence are “pinned for the duration of the borrow”. This has always been true for &T , but for &mut T has traditionally not been true. We’ll see in the next post that Pin<&mut T> basically just extends that guarantee to apply indefinitely. Compare that to types that do not implement Unpin and hence are “address sensitive”. Such types are pinned for the duration of a Pin<&mut T> . Unlike T: !Overwrite types, they are not pinned by &mut T references, but that’s a bug, not a feature: this is why Pin has to bend over backwards to prevent you from getting your hands on an &mut T . I’ll explain this more in my next post, of course. Should Overwrite be an auto trait? I think not. If we did so, it would lock people into semver hazards in the “Rust Next” edition where mut is mandatory for mutation. Consider a struct Foo { value: u32 } type. This type has not opted into becoming Copy , but it only contains types that are Copy and therefore Overwrite . By auto trait rules it would by default be Overwrite . But that would prevent you from adding a mut field in the future or benefit from immutable fields. This is why I said the default would just be !Overwrite , no matter the field types. Conclusion =) After this grandiose intro, hopefully I won’t be printing a retraction of the idea due to some glaring flaw… eep! ↩︎ Whenever I saw immutable here, I mean immutable-modulo- Cell , of course. We should probably find another word for that, this is kind of terminology debt that Rust has bought its way into and I’m not sure the best way for us to get out! ↩︎ Immutable fields don’t resolve all inter-function borrow conflicts. To do that, you need something like view types . But in my experience they would eliminate many. ↩︎ The simple solution — if a struct has mut fields, disallow overwriting it — is basically what C++ does with their const fields. Classes or structs with const fields are more limited in how you can use them. This works in C++ because they don’t wait until post-substitution to check templates for validity. ↩︎ I love the Felleisen definition of “expressiveness” : two language features are equally expressive if one can be converted into the other with only local rewrites, which I generally interpret as “rewrites that don’t affect the function signature (or other abstraction boundary)”. ↩︎ We can also make the !Overwrite impl implied by declaring fields mut , of course. This is fine for backwards compatibility, but isn’t the design I would want long-term, since it introduces an odd “step change” where declaring one field as mut implicitly declares all other fields as immutable (and, conversely, deleting the mut keyword from that field has the effect of declaring all fields, including that one, as mutable). ↩︎ The Self type in traits is exempt from the Sized default, and it could be exempt from the Overwrite default as well, unless the trait is declared as Sized . ↩︎ Hat tip to TC, who pointed this out to me. ↩︎
======>
https://old.reddit.com/r/rust/comments/1fpwvcj/psa_use_diagnosticon_unimplemented_its_amazing/
-->>-->>
In    zerocopy 0.8   , you can    #[derive(IntoBytes)]    on a type, which permits you to inspect its raw bytes. Due to limitations in how derives work, it's historically had some pretty bad error messages. This code:   

   #[derive(IntoBytes)]
#[repr(C)]
struct Foo {
    a: u8,
    b: u16,
}
   

   ...produces this error:   

   error[E0277]: the trait bound `HasPadding<Foo, true>: ShouldBe<false>` is not satisfied               
   --> src/lib.rs:4:10
    |
550 | #[derive(IntoBytes)]
    |          ^^^^^^^^^ the trait `ShouldBe<false>` is not implemented for `HasPadding<Foo, true>`
    |
    = help: the trait `ShouldBe<true>` is implemented for `HasPadding<Foo, true>`
   

   What on earth?   

   But now that we've    added support for #[diagnostic::on_unimplemented]   , it's so much better:   

   error[E0277]: `Foo` has inter-field padding
   --> src/lib.rs:4:10
    |
550 | #[derive(IntoBytes)]
    |          ^^^^^^^^^ types with padding cannot implement `IntoBytes`
    |
    = help: the trait `PaddingFree<Foo, true>` is not implemented for `()`
    = note: consider using `zerocopy::Unalign` to lower the alignment of individual fields
    = note: consider adding explicit fields where padding would be
    = note: consider using `#[repr(packed)]` to remove inter-field padding
   

   (We also used it to replace       this absolutely cursed error message       with       this much nicer one   .)   

   You should use    #[diagnostic::on_unimplemented]   ! It's awesome!   
   

======>
https://blog.rust-lang.org/inside-rust/2024/09/26/rtn-call-for-testing.html
-->>-->>

======>
https://thehackernews.com/2024/09/googles-shift-to-rust-programming-cuts.html?m=1
-->>-->>
 Sep 25, 2024  Ravie Lakshmanan Secure Coding / Mobile Security Google has revealed that its transition to memory-safe languages such as Rust as part of its secure-by-design approach has led to the percentage of memory-safe vulnerabilities discovered in Android dropping from 76% to 24% over a period of six years. The tech giant said focusing on Safe Coding for new features not only reduces the overall security risk of a codebase, but also makes the switch more "scalable and cost-effective." Eventually, this leads to a drop in memory safety vulnerabilities as new memory unsafe development slows down after a certain period of time, and new memory safe development takes over, Google's Jeff Vander Stoep and Alex Rebert said in a post shared with The Hacker News. Perhaps even more interestingly, the number of memory safety vulnerabilities tends to register a drop notwithstanding an increase in the quantity of new memory unsafe code. The paradox is explained by the fact that vulnerabilities decay exponentially, with a study finding that a high number of vulnerabilities often reside in new or recently modified code. "The problem is overwhelmingly with new code, necessitating a fundamental change in how we develop code," Vander Stoep and Rebert noted. "Code matures and gets safer with time, exponentially, making the returns on investments like rewrites diminish over time as code gets older." Google, which formally announced its plans to support the Rust programming language in Android way back in April 2021, said it began prioritizing transitioning new development to memory-safe languages around 2019. As a result, the number of memory safety vulnerabilities discovered in the operating system has declined from 223 in 2019 to less than 50 in 2024. It also goes without saying that much of the decrease in such flaws is down to advancements in the ways devised to combat them, moving from reactive patching to proactive mitigating to proactive vulnerability discovery using tools like Clang sanitizers . The tech giant further noted that memory safety strategies should evolve even more to prioritize "high-assurance prevention" by incorporating secure-by-design principles that enshrine security into the very foundations. "Instead of focusing on the interventions applied (mitigations, fuzzing), or attempting to use past performance to predict future security, Safe Coding allows us to make strong assertions about the code's properties and what can or cannot happen based on those properties," Vander Stoep and Rebert said. That's not all. Google said it is also focusing on offering interoperability between Rust, C++, and Kotlin, instead of code rewrites, as a "practical and incremental approach" to embracing memory-safe languages and ultimately eliminating entire vulnerability classes. "Adopting Safe Coding in new code offers a paradigm shift, allowing us to leverage the inherent decay of vulnerabilities to our advantage, even in large existing systems," it said. "The concept is simple: once we turn off the tap of new vulnerabilities, they decrease exponentially, making all of our code safer, increasing the effectiveness of security design, and alleviating the scalability challenges associated with existing memory safety strategies such that they can be applied more effectively in a targeted manner." The development comes as Google touted increased collaboration with Arm's product security and graphics processing unit (GPU) engineering teams to flag multiple shortcomings and elevate the overall security of the GPU software/firmware stack across the Android ecosystem. This includes the discovery of two memory issues in Pixel's customization of driver code ( CVE-2023-48409 and CVE-2023-48421 ) and another in Arm Valhall GPU firmware and 5th Gen GPU architecture firmware ( CVE-2024-0153 ). "Proactive testing is good hygiene as it can lead to the detection and resolution of new vulnerabilities before they're exploited," Google and Arm said . Found this article interesting?  Follow us on Twitter  and LinkedIn to read more exclusive content we post. var share_url = encodeURIComponent('https://thehackernews.com/2024/09/googles-shift-to-rust-programming-cuts.html');
var share_title = document.getElementsByTagName("title")[0].innerHTML;
share_title = encodeURIComponent(share_title); SHARE      Tweet  Share  Share  Share   Share on Facebook  Share on Twitter  Share on Linkedin  Share on Reddit  Share on Hacker News  Share on Email  Share on WhatsApp Share on Facebook Messenger  Share on Telegram SHARE  Android cybersecurity mobile security Rust Programming secure coding software development technology Vulnerability
