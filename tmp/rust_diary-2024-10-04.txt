https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=b7362f2fef51a088badb864988b3abf4
-->>-->>
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
======>
https://rust-unofficial.github.io/too-many-lists/fifth.html
-->>-->>
Light (default) Rust Coal Navy Ayu Learning Rust With Entirely Too Many Linked Lists document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    }); An Ok Unsafe Singly-Linked Queue Ok that reference-counted interior mutability stuff got a little out of
control. Surely Rust doesn't really expect you to do that sort of thing
in general? Well, yes and no. Rc and Refcell can be great for handling
simple cases, but they can get unwieldy. Especially if you
want to hide that it's happening. There's gotta be a better way! In this chapter we're going to roll back to singly-linked lists and
implement a singly-linked queue to dip our toes into raw pointers and Unsafe Rust . NARRATOR: And I will point out the mistakes. And we won't make any mistakes. Let's add a new file called fifth.rs : // in lib.rs pub mod first; pub mod second; pub mod third; pub mod fourth; pub mod fifth; Our code is largely going to be derived from second.rs, since a queue is
mostly an augmentation of a stack in the world of linked lists. Still, we're
going to go from scratch because there's some fundamental issues we want to
address with layout and what-not.
======>
https://docs.rs/quick-builder/0.1.0/quick_builder/#alternatives
-->>-->>
Crate quick_builder Copy item path Settings Help Summary source Expand description Â§ QuickBuilder: Compile-Time Builder with Enforcement of Run-Time Invariants This crate offers a simple, but powerful, compile-time builder pattern generator.
The philosophy is to verify as much as possible at compile-time, while also
providing a straightforward way to enforce run-time invariants. Â§ When Should You Try QuickBuilder? Give QuickBuilder a shot if you want to derive a builder for your struct,
that makes it a compile error if you forget to set a field and allows you to specify run-time invariants for your struct that
are enforced at run-time and you can live with the more ascetic interface that the builder provides,
see the sections on limitations and alternatives. Â§ Motivation There are great builder crates, like bon or typed-builder , that allow you
to create idiomatic builders enforcing that all necessary fields
have been set at compile-time. Like those crates, QuickBuilder
can generate a builder that only allows to call the final .build() method if
all fields were initialized. use quick_builder::QuickBuilder; #[derive(QuickBuilder)] struct ImageRef< 'a , T> {
    width: usize,
    height: usize,
    data: & 'a [T],
} fn main() { let image_data = & [ 1 , 2 , 3 , 4 , 5 , 6 ]; let imgref = ImageRef::builder()
        .width( 3 )
        .height( 2 )
        .data(image_data)
        .build();
} However, the example above is not the main usecase for QuickBuilder. If thatâ€™s
all you ever need to do, check out the bon or typed-builder crates. Those offer,
among other things, more exhaustive support for idioms like optional and
default parameters, as well as great ergonomics. QuickBuilder shines when
you additionally need to enforce run-time invariants about your data structure. Â§ Enforcing Run-Time Invariants In the example above we might want to enforce a couple of invariants
about the data structure which we can only check at run-time. The following
example shows, how we can use QuickBuilder to enforce thatâ€¦ â€¦the width of the image is greater 0 and the height of the image is an even number greater 0 and the product of width and height is equal to the length of the given slice. use quick_builder::QuickBuilder; #[derive(QuickBuilder)]
#[invariant(|my| my.width * my.height == my.data.len())] struct ImageRef< 'a , T> { #[invariant(|w| * w> 0 )] width: usize, #[invariant(check_height)] height: usize,
    data: & 'a [T],
} // if the conditions to check invariants are too
// unwieldy to put into a closure, you can also
// define a standalone function. fn check_height(height : & usize) -> bool { * height > 0 && * height % 2 == 0 } fn main() { let image_data = & [ 1 , 2 , 3 , 4 , 5 , 6 ]; let imgref = ImageRef::builder()
        .width( 3 )
        .height( 2 )
        .data(image_data)
        .build()
        .unwrap();
} One (or zero) #[invariant(...)] attributes can be applied to each field or
to the struct itself. The attributes take a closure or function name to check
if the invariant holds. The function (or closure) must take its
argument by reference and return a bool , where true means that the invariant
holds and false means itâ€™s violated. As soon as an #[invariant(...)] attribute is encountered, the build function
changes its signature. It now returns an optional instance of the original
structure, where the optional contains a value if and only if all invariants
where upheld during construction. Â§ Limitations Build Order : The builder function must be executed in the order of
field declarations in the struct. Typically, IDE support is good enough
to provide you with the next allowed option, so you donâ€™t have to look
up the struct fields. The bon and typed-builder crates allow arbitrary
orders, but they donâ€™t have a mechanism for enforcing run-time invariants. Default/Optional Arguments : there is no support for default or optional
arguments (yet). Weird Generics : The builder structure contains a bit of generic magic
and is not meant for passing around. Consuming Builder Pattern Only : The builder uses the consuming pattern always.
If you need to set fields conditionally, check out the apply_if crate. Â§ Protecting Field Access: Getters If care about enforcing invariants about your data, you probably want to provide getters
to your fields rather than making them publicly accessible. In that case, youâ€™ll
be happy to hear that this crate works seamlessly with the popular getset and derive-getters crates. Those offer derive macros for getters and setters. Â§ Alternatives There is a great overview of builder crates by the bon team. Of those, to my knowledge, only the derive_builder crate provides a way to enforce run-time invariants. However, that crate
makes it a run-time error if not all required fields were set.
Some might argue that if we have run-time errors anyways (due to the invariants)
we might not care about that. But my philosophy is that Iâ€™d rather validate as
much as I can at compile-time and let run-time errors be run-time errors.
But thatâ€™s just me. Derive Macros Â§ Quick Builder
======>
https://crates.io/crates/quick-builder
-->>-->>

======>
https://crates.io/crates/quick-builder
-->>-->>

======>
https://github.com/Cr0a3/ygen
-->>-->>
Repository files navigation README Code of conduct Apache-2.0 license Security Ygen - Yet another Code Generator Welcome to Ygen!
This repository contains the source code of the ygen project. Ygen is a toolkit for building fast and clean compilers using a memory safe api. Why ygen? You are probably wondering: why would I choose ygen and not llvm or cranelift??
Here are a few reasons: Simplicity : One of ygens main focus is simplicity which means to us that as much code as possible is readable and shared Similare API : Ygens API is very similar to LLVMs API for example i designed the IRBuilder to be very similar to the Builder from LLVM Traits : Ygen uses a lot of traits to overload functions. Great examples are the Build... functions from the IRBuilder to build ir nodes Warning This project is still early in its developement. Bugs and miscompilations are expected. ONLY USE YGEN FOR TOY COMPILERS Contributions Simple example Here is a simple example on how to use Ygen to build an add function: use std :: error :: Error ; use Ygen :: prelude :: * ; pub fn main ( ) -> Result < ( ) , Box < dyn Error > > { let mut module = Module ( ) ; let mut builder = IRBuilder ( ) ; let ty = FnTy ( vec ! [ TypeMetadata :: i32 , TypeMetadata :: i32 ] , TypeMetadata :: i32 ) ; let func = module . add ( "add" , & ty ) ; func . extrn ( ) ; // make function externally visible let entry = func . addBlock ( "entry" ) ; builder . positionAtEnd ( entry ) ; let val = builder . BuildAdd ( ty . arg ( 0 ) , ty . arg ( 1 ) ) ; builder . BuildRet ( val ) ; module . verify ( ) . print ( ) ; eprintln ! ( "{}" ,
        module.dumpColored ( ) ) ; Ok ( ( ) ) } When executed this simple program builds an add function and dumps it's ir: define i32 @add ( i32 %0 , i32 %1 ) {
 entry: %2 = add i32 %0 , %1 ret i32 %2 } You can add following lines (you need to include std::fs::Path ) to compile the IR down to assembly: module . emitToAsmFile ( Triple :: host ( ) , & mut initializeAllTargets ( Triple :: host ( ) ) ? , Path :: new ( "out.asm" ) ) ? ; Support Ygen currently supports following architectures Name Full ir Full isa x64 Yes No Copyright This project is owned by Cr0a3 and licensed under the Apache2 License
======>
https://www.reddit.com/r/rust/comments/1fvfgx0/ygen_release_012/
-->>-->>
Go to rust r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online â€¢ 1 day ago Cr0a3 ADMIN MOD Ygen: release 0.1.2 Hi, I recently released the version 0.1.2 of ygen. Ygen is my small (16k locs) code generation libary. It's not designed to be used by other people because it is just a little code generation learning project. What features does ygen currently has? Ygen currently supports these IR nodes: alloca is used to allocate a variable on the stack. ( Code example from the tests ) assign an variable assignment ( Code example from the tests ) br either an unconditional branch or an conditional branch ( Code example from the tests ) call a simple call ( Code example from the tests ) cast a cast between two types cmp compares two variables ( Code example from the tests ) load loads an value from an memory pointer add performs the add operation on two variables sub performs the sub operation on two variables xor performs the xor operation on two variables or performs the or operation on two variables and performs the and operation on two variables mul performs the mul operation on two variables div performs the div operation on two variables ret returns an variable or value store stores an variable/value into an pointer Optimizations: constant evaluation: ygen can pre compute constant values and inline const variables dead node elimination: ygen can remove unused variables Debug metadata: you can add debug metadata Architecturs: Ygen currently only supports x86_64 Targets: I only tested Windows and Linux but theoretically all x86_64 targets wich either have WindowsFastcall or SystemV as their calling convention should work I am only 13yrs old so do not expect to much . Ygen also doesn't stick to the naming convention (please don't judge my by that) Here's the github: https://github.com/Cr0a3/ygen And it's website (made in 1 day): https://ygen.vercel.app/ Bye Read more Grammarly â€¢ Official â€¢ Promoted Believe in your ideas, but struggle to convey them effectively? Grammarlyâ€™s AI writing assistant ensures your intelligence shines through in every paper. Add a Comment Sort by: Best Open comment sort options Best Top New Controversial Old Q&A Ok-Ingenuity-6262 â€¢ 1d ago â€¢ THIRTEEN??? Bro no hate but I hope you get enough social life. And very impressive project. Reply reply Cr0a3 â€¢ 1d ago â€¢ Thank you very much! I play with my friends every day video games after school and only work on ygen like 2 or 3 hours Reply reply 5 more replies 5 more replies More replies More replies BionicVnB â€¢ 1d ago â€¢ Bro is 13 and more talented than I could ever be Reply reply Cr0a3 â€¢ 23h ago â€¢ Thank you Reply reply More replies Comun4 â€¢ 1d ago â€¢ Wow, that's very cool project Unfortunately, reddit is 14+ so we kinda need to ban you ðŸ˜… /jk Reply reply Cr0a3 â€¢ 23h ago â€¢ Bro Reply reply LeSaR_ â€¢ 21h ago â€¢ me when i spread misinformation on the internet Reply reply More replies Top 1% Rank by size Public Anyone can view, post, and comment to this community More posts you may like Related Rust Programming open-source software Technology Free software Software Information & communications technology forward back r/europe r/europe Europe: 50 (+6) countries, 230 languages, 746M peopleâ€¦ 1 subreddit. 7.5M Members 1.4K Online On this day in 1919 Greek troops invaded Izmir, Turkey 258 upvotes Â· 362 comments r/exmormon r/exmormon A forum for ex-mormons and others who have been affected by Mormonism to get support and share news, commentary, and comedy about the Mormon church. 312K Members 240 Online Getting this email warmed my cold, non-believing heart 845 upvotes Â· 254 comments r/pics r/pics A place for photographs, pictures, and other images. 31M Members 3.7K Online Left is a photo, right is a drawing. 219 upvotes Â· 20 comments Promoted r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Practice - v0.1.0 Release ðŸš€ 123 upvotes Â· 8 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online ureq 3.x release candidate 1 104 upvotes Â· 11 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Loco.rs v0.9.0 Released: new docs, new website, new features! 205 upvotes Â· 60 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Reading Large (100GB+) Files. 146 upvotes Â· 52 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Rust for Android 414 upvotes Â· 38 comments Promoted r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Binsider - A TUI for analyzing Linux binaries like a boss! 355 upvotes Â· 26 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Pax enters Beta: Rust GUIs with an integrated design tool 242 upvotes Â· 54 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Support for SQLite's JSON/JSONB has landed on diesel 122 upvotes Â· 7 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Rust to .NET compiler - end of GSoC, what now? 182 upvotes Â· 19 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Could rust theoretically achieve better optimisation with a costum backend, that takes more advantage of the rich type system Information that LLVM? 102 upvotes Â· 39 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online What's the difference between `FnOnce`, `Fn` and `FnMut` 100 upvotes Â· 48 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online A better way to manage environment variables ðŸ› ï¸! 130 upvotes Â· 20 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Help wanted for a crate :) 142 upvotes Â· 16 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Use Type-State pattern without the ugly code 206 upvotes Â· 51 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Come test a novel "trait debugger" for Rust 108 upvotes Â· 5 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Quality of RustRover versus rust-analyzer 110 upvotes Â· 139 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online So what do you use for Rust development? 145 upvotes Â· 213 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Giving Bevy the Quick-Start Guide it deserves 133 upvotes Â· 7 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online The One Billion Rows Challenge - My solution in Rust - 1 second 126 upvotes Â· 40 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online Hyperion - 10k player Minecraft Game Engine 706 upvotes Â· 52 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online PSA: Use #[diagnostic::on_unimplemented]! It's amazing! 300 upvotes Â· 17 comments r/rust r/rust A place for all things related to the Rust programming languageâ€”an open-source systems language that emphasizes performance, reliability, and productivity. 313K Members 158 Online We have coded a multiplayer Minecaft clone with glium (OpenGL) to learn Rust 128 upvotes Â· 19 comments
======>
https://docs.rs/clap/latest/clap/struct.Command.html#method.subcommand
-->>-->>
clap Struct Command Copy item path Settings Help Summary source pub struct Command { /* private fields */ } Expand description Build a command-line interface. This includes defining arguments, subcommands, parser behavior, and help output.
Once all configuration is complete,
the Command::get_matches family of methods starts the runtime-parsing
process. These methods then return information about the user supplied
arguments (or lack thereof). When deriving a Parser , you can use CommandFactory::command to access the Command . Basic API Application-wide Settings Command-specific Settings Subcommand-specific Settings Reflection Â§ Examples let m = Command::new( "My Program" )
    .author( "Me, me@mail.com" )
    .version( "1.0.2" )
    .about( "Explains in brief what the program does" )
    .arg(
        Arg::new( "in_file" )
    )
    .after_help( "Longer explanation to appear after the options when \
                 displaying the help information from --help or -h" )
    .get_matches(); // Your program logic starts here... Implementations Â§ source Â§ impl Command Â§ Basic API source pub fn new (name: impl Into < Str >) -> Command Creates a new instance of an Command . It is common, but not required, to use binary name as the name . This
name will only be displayed to the user when they request to print
version or help and usage information. See also command! and crate_name! . Â§ Examples Command::new( "My Program" ) Examples found in repository ? examples/multicall-busybox.rs ( line 8 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn applet_commands() -> [Command; 2 ] {
    [ Command::new ( "true" ).about( "does nothing successfully" ), Command::new ( "false" ).about( "does nothing unsuccessfully" ),
    ]
} fn main() { let cmd = Command::new ( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand( Command::new ( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} More examples Hide additional examples examples/derive_ref/hand_subcommand.rs ( line 55 ) 54 55 56 57 58 59 60 61 62 63 fn augment_subcommands(cmd: Command) -> Command {
        cmd.subcommand(AddArgs::augment_args( Command::new ( "add" )))
            .subcommand(RemoveArgs::augment_args( Command::new ( "remove" )))
            .subcommand_required( true )
    } fn augment_subcommands_for_update(cmd: Command) -> Command {
        cmd.subcommand(AddArgs::augment_args( Command::new ( "add" )))
            .subcommand(RemoveArgs::augment_args( Command::new ( "remove" )))
            .subcommand_required( true )
    } examples/derive_ref/augment_subcommands.rs ( line 12 ) 11 12 13 14 15 16 17 18 19 20 21 fn main() { let cli = Command::new ( "Built CLI" ); // Augment with derived subcommands let cli = Subcommands::augment_subcommands(cli); let matches = cli.get_matches(); let derived_subcommands = Subcommands::from_arg_matches( & matches)
        .map_err(|err| err.exit())
        .unwrap(); println! ( "Derived subcommands: {derived_subcommands:#?}" );
} examples/tutorial_builder/02_apps.rs ( line 4 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn main() { let matches = Command::new ( "MyApp" )
        .version( "1.0" )
        .about( "Does awesome things" )
        .arg( arg! (--two <VALUE>).required( true ))
        .arg( arg! (--one <VALUE>).required( true ))
        .get_matches(); println! ( "two: {:?}" ,
        matches.get_one::<String>( "two" ).expect( "required" )
    ); println! ( "one: {:?}" ,
        matches.get_one::<String>( "one" ).expect( "required" )
    );
} examples/multicall-hostname.rs ( line 4 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new ( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .subcommand( Command::new ( "hostname" ).about( "show hostname part of FQDN" ))
        .subcommand( Command::new ( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/derive_ref/augment_args.rs ( line 10 ) 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fn main() { let cli = Command::new ( "CLI" ).arg( arg! (-b - -built).action(clap::ArgAction::SetTrue)); // Augment built args with derived args let cli = DerivedArgs::augment_args(cli); let matches = cli.get_matches(); println! ( "Value of built: {:?}" , matches.get_flag( "built" )); println! ( "Value of derived via ArgMatches: {:?}" ,
        matches.get_flag( "derived" )
    ); // Since DerivedArgs implements FromArgMatches, we can extract it from the unstructured ArgMatches.
    // This is the main benefit of using derived arguments. let derived_matches = DerivedArgs::from_arg_matches( & matches)
        .map_err(|err| err.exit())
        .unwrap(); println! ( "Value of derived: {derived_matches:#?}" );
} Additional examples can be found in: examples/repl.rs examples/git.rs examples/pacman.rs source pub fn arg (self, a: impl Into < Arg >) -> Command Adds an argument to the list of valid possibilities. Â§ Examples Command::new( "myprog" ) // Adding a single "flag" argument with a short and help text, using Arg::new() .arg(
        Arg::new( "debug" )
           .short( 'd' )
           .help( "turns on debugging mode" )
    ) // Adding a single "option" argument with a short, a long, and help text using the less
    // verbose Arg::from() .arg( arg! (-c --config <CONFIG> "Optionally sets a config file to use" )
    ) Examples found in repository ? examples/tutorial_builder/02_apps.rs ( line 7 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn main() { let matches = Command::new( "MyApp" )
        .version( "1.0" )
        .about( "Does awesome things" )
        . arg ( arg! (--two <VALUE>).required( true ))
        . arg ( arg! (--one <VALUE>).required( true ))
        .get_matches(); println! ( "two: {:?}" ,
        matches.get_one::<String>( "two" ).expect( "required" )
    ); println! ( "one: {:?}" ,
        matches.get_one::<String>( "one" ).expect( "required" )
    );
} More examples Hide additional examples examples/derive_ref/flatten_hand_args.rs ( lines 39-44 ) 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 fn augment_args(cmd: Command) -> Command {
        cmd. arg (
            Arg::new( "foo" )
                .short( 'f' )
                .long( "foo" )
                .action(ArgAction::SetTrue),
        )
        . arg (
            Arg::new( "bar" )
                .short( 'b' )
                .long( "bar" )
                .action(ArgAction::SetTrue),
        )
        . arg (
            Arg::new( "quuz" )
                .short( 'q' )
                .long( "quuz" )
                .action(ArgAction::Set),
        )
    } fn augment_args_for_update(cmd: Command) -> Command {
        cmd. arg (
            Arg::new( "foo" )
                .short( 'f' )
                .long( "foo" )
                .action(ArgAction::SetTrue),
        )
        . arg (
            Arg::new( "bar" )
                .short( 'b' )
                .long( "bar" )
                .action(ArgAction::SetTrue),
        )
        . arg (
            Arg::new( "quuz" )
                .short( 'q' )
                .long( "quuz" )
                .action(ArgAction::Set),
        )
    } examples/derive_ref/augment_args.rs ( line 10 ) 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fn main() { let cli = Command::new( "CLI" ). arg ( arg! (-b - -built).action(clap::ArgAction::SetTrue)); // Augment built args with derived args let cli = DerivedArgs::augment_args(cli); let matches = cli.get_matches(); println! ( "Value of built: {:?}" , matches.get_flag( "built" )); println! ( "Value of derived via ArgMatches: {:?}" ,
        matches.get_flag( "derived" )
    ); // Since DerivedArgs implements FromArgMatches, we can extract it from the unstructured ArgMatches.
    // This is the main benefit of using derived arguments. let derived_matches = DerivedArgs::from_arg_matches( & matches)
        .map_err(|err| err.exit())
        .unwrap(); println! ( "Value of derived: {derived_matches:#?}" );
} examples/multicall-busybox.rs ( lines 21-29 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand(
            Command::new( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                . arg (
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/git.rs ( line 15 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                . arg ( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                . arg ( arg! (base: [COMMIT]))
                . arg ( arg! (head: [COMMIT]))
                . arg ( arg! (path: [PATH]).last( true ))
                . arg ( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                . arg ( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                . arg ( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ). arg ( arg! ([STASH])))
                .subcommand(Command::new( "apply" ). arg ( arg! ([STASH]))),
        )
} examples/pacman.rs ( lines 17-25 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        .version( "5.2.1" )
        .subcommand_required( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                .short_flag( 'Q' )
                .long_flag( "query" )
                .about( "Query the package database." )
                . arg (
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                . arg (
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                .short_flag( 'S' )
                .long_flag( "sync" )
                .about( "Synchronize packages." )
                . arg (
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                . arg (
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                . arg (
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn args (self, args: impl IntoIterator <Item = impl Into < Arg >>) -> Command Adds multiple arguments to the list of valid possibilities. Â§ Examples Command::new( "myprog" )
    .args([ arg! (-d --debug "turns on debugging info" ),
        Arg::new( "input" ).help( "the input file to use" )
    ]) Examples found in repository ? examples/git.rs ( line 49 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                . args (push_args())
                .subcommand(Command::new( "push" ). args (push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} source pub fn mut_arg <F>(self, arg_id: impl AsRef < str >, f: F) -> Command where
    F: FnOnce ( Arg ) -> Arg , Allows one to mutate an Arg after itâ€™s been added to a Command . Â§ Panics If the argument is undefined Â§ Examples let mut cmd = Command::new( "foo" )
    .arg(Arg::new( "bar" )
        .short( 'b' )
        .action(ArgAction::SetTrue))
    .mut_arg( "bar" , |a| a.short( 'B' )); let res = cmd.try_get_matches_from_mut( vec! [ "foo" , "-b" ]); // Since we changed `bar`'s short to "B" this should err as there
// is no `-b` anymore, only `-B` assert! (res.is_err()); let res = cmd.try_get_matches_from_mut( vec! [ "foo" , "-B" ]); assert! (res.is_ok()); source pub fn mut_args <F>(self, f: F) -> Command where
    F: FnMut ( Arg ) -> Arg , Allows one to mutate all Arg s after theyâ€™ve been added to a Command . This does not affect the built-in --help or --version arguments. Â§ Examples let mut cmd = Command::new( "foo" )
    .arg(Arg::new( "bar" )
        .long( "bar" )
        .action(ArgAction::SetTrue))
    .arg(Arg::new( "baz" )
        .long( "baz" )
        .action(ArgAction::SetTrue))
    .mut_args(|a| { if let Some (l) = a.get_long().map(|l| format! ( "prefix-{l}" )) {
            a.long(l)
        } else {
            a
        }
    }); let res = cmd.try_get_matches_from_mut( vec! [ "foo" , "--bar" ]); // Since we changed `bar`'s long to "prefix-bar" this should err as there
// is no `--bar` anymore, only `--prefix-bar`. assert! (res.is_err()); let res = cmd.try_get_matches_from_mut( vec! [ "foo" , "--prefix-bar" ]); assert! (res.is_ok()); source pub fn mut_group <F>(self, arg_id: impl AsRef < str >, f: F) -> Command where
    F: FnOnce ( ArgGroup ) -> ArgGroup , Allows one to mutate an ArgGroup after itâ€™s been added to a Command . Â§ Panics If the argument is undefined Â§ Examples Command::new( "foo" )
    .arg( arg! (-- "set-ver" <ver> "set the version manually" ).required( false ))
    .arg( arg! (--major "auto increase major" ))
    .arg( arg! (--minor "auto increase minor" ))
    .arg( arg! (--patch "auto increase patch" ))
    .group(ArgGroup::new( "vers" )
         .args([ "set-ver" , "major" , "minor" , "patch" ])
         .required( true ))
    .mut_group( "vers" , |a| a.required( false )); source pub fn mut_subcommand <F>(self, name: impl AsRef < str >, f: F) -> Command where
    F: FnOnce ( Command ) -> Command , Allows one to mutate a Command after itâ€™s been added as a subcommand. This can be useful for modifying auto-generated arguments of nested subcommands with Command::mut_arg . Â§ Panics If the subcommand is undefined Â§ Examples let mut cmd = Command::new( "foo" )
        .subcommand(Command::new( "bar" ))
        .mut_subcommand( "bar" , |subcmd| subcmd.disable_help_flag( true )); let res = cmd.try_get_matches_from_mut( vec! [ "foo" , "bar" , "--help" ]); // Since we disabled the help flag on the "bar" subcommand, this should err. assert! (res.is_err()); let res = cmd.try_get_matches_from_mut( vec! [ "foo" , "bar" ]); assert! (res.is_ok()); source pub fn group (self, group: impl Into < ArgGroup >) -> Command Adds an ArgGroup to the application. ArgGroup s are a family of related arguments.
By placing them in a logical group, you can build easier requirement and exclusion rules. Example use cases: Make an entire ArgGroup required, meaning that one (and only one) argument from that group must be present at runtime. Name an ArgGroup as a conflict to another argument.
Meaning any of the arguments that belong to that group will cause a failure if present with
the conflicting argument. Ensure exclusion between arguments. Extract a value from a group instead of determining exactly which argument was used. Â§ Examples The following example demonstrates using an ArgGroup to ensure that one, and only one,
of the arguments from the specified group is present at runtime. Command::new( "cmd" )
    .arg( arg! (-- "set-ver" <ver> "set the version manually" ).required( false ))
    .arg( arg! (--major "auto increase major" ))
    .arg( arg! (--minor "auto increase minor" ))
    .arg( arg! (--patch "auto increase patch" ))
    .group(ArgGroup::new( "vers" )
         .args([ "set-ver" , "major" , "minor" , "patch" ])
         .required( true )) source pub fn groups (
    self,
    groups: impl IntoIterator <Item = impl Into < ArgGroup >>,
) -> Command Adds multiple ArgGroup s to the Command at once. Â§ Examples Command::new( "cmd" )
    .arg( arg! (-- "set-ver" <ver> "set the version manually" ).required( false ))
    .arg( arg! (--major "auto increase major" ))
    .arg( arg! (--minor "auto increase minor" ))
    .arg( arg! (--patch "auto increase patch" ))
    .arg( arg! (-c <FILE> "a config file" ).required( false ))
    .arg( arg! (-i <IFACE> "an interface" ).required( false ))
    .groups([
        ArgGroup::new( "vers" )
            .args([ "set-ver" , "major" , "minor" , "patch" ])
            .required( true ),
        ArgGroup::new( "input" )
            .args([ "c" , "i" ])
    ]) source pub fn subcommand (self, subcmd: impl Into < Command >) -> Command Adds a subcommand to the list of valid possibilities. Subcommands are effectively sub- Command s, because they can contain their own arguments,
subcommands, version, usage, etc. They also function just like Command s, in that they get
their own auto generated help, version, and usage. A subcommandâ€™s Command::name will be used for: The argument the user passes in Programmatically looking up the subcommand Â§ Examples Command::new( "myprog" )
    .subcommand(Command::new( "config" )
        .about( "Controls configuration features" )
        .arg( arg! (<config> "Required configuration file to use" ))) Examples found in repository ? examples/derive_ref/hand_subcommand.rs ( line 55 ) 54 55 56 57 58 59 60 61 62 63 fn augment_subcommands(cmd: Command) -> Command {
        cmd. subcommand (AddArgs::augment_args(Command::new( "add" )))
            . subcommand (RemoveArgs::augment_args(Command::new( "remove" )))
            .subcommand_required( true )
    } fn augment_subcommands_for_update(cmd: Command) -> Command {
        cmd. subcommand (AddArgs::augment_args(Command::new( "add" )))
            . subcommand (RemoveArgs::augment_args(Command::new( "remove" )))
            .subcommand_required( true )
    } More examples Hide additional examples examples/multicall-hostname.rs ( line 9 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        . subcommand (Command::new( "hostname" ).about( "show hostname part of FQDN" ))
        . subcommand (Command::new( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/repl.rs ( lines 71-75 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        . subcommand (
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        . subcommand (
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/multicall-busybox.rs ( lines 16-31 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        . subcommand (
            Command::new( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/git.rs ( lines 12-17 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        . subcommand (
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        . subcommand (
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        . subcommand (
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        . subcommand (
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        . subcommand (
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                .args(push_args())
                . subcommand (Command::new( "push" ).args(push_args()))
                . subcommand (Command::new( "pop" ).arg( arg! ([STASH])))
                . subcommand (Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} examples/pacman.rs ( lines 12-35 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        .version( "5.2.1" )
        .subcommand_required( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. . subcommand (
            Command::new( "query" )
                .short_flag( 'Q' )
                .long_flag( "query" )
                .about( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. . subcommand (
            Command::new( "sync" )
                .short_flag( 'S' )
                .long_flag( "sync" )
                .about( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn subcommands (
    self,
    subcmds: impl IntoIterator <Item = impl Into < Command >>,
) -> Command Adds multiple subcommands to the list of valid possibilities. Â§ Examples .subcommands( [
       Command::new( "config" ).about( "Controls configuration functionality" )
                                .arg(Arg::new( "config_file" )),
       Command::new( "debug" ).about( "Controls debug functionality" )]) Examples found in repository ? examples/multicall-busybox.rs ( line 30 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand(
            Command::new( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                . subcommands (applet_commands()),
        )
        . subcommands (applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} source pub fn defer (self, deferred: fn (_: Command ) -> Command ) -> Command Delay initialization for parts of the Command This is useful for large applications to delay definitions of subcommands until they are
being invoked. Â§ Examples Command::new( "myprog" )
    .subcommand(Command::new( "config" )
        .about( "Controls configuration features" )
        .defer(|cmd| {
            cmd.arg( arg! (<config> "Required configuration file to use" ))
        })
    ) source pub fn debug_assert (self) Catch problems earlier in the development cycle. Most error states are handled as asserts under the assumption they are programming mistake
and not something to handle at runtime.  Rather than relying on tests (manual or automated)
that exhaustively test your CLI to ensure the asserts are evaluated, this will run those
asserts in a way convenient for running as a test. Note: This will not help with asserts in ArgMatches , those will need exhaustive
testing of your CLI. Â§ Examples fn cmd() -> Command {
    Command::new( "foo" )
        .arg(
            Arg::new( "bar" ).short( 'b' ).action(ArgAction::SetTrue)
        )
} #[test] fn verify_app() {
    cmd().debug_assert();
} fn main() { let m = cmd().get_matches_from( vec! [ "foo" , "-b" ]); println! ( "{}" , m.get_flag( "bar" ));
} source pub fn error (&mut self, kind: ErrorKind , message: impl Display ) -> Error Custom error message for post-parsing validation Â§ Examples let mut cmd = Command::new( "myprog" ); let err = cmd.error(ErrorKind::InvalidValue, "Some failure case" ); Examples found in repository ? examples/tutorial_derive/04_04_custom.rs ( lines 46-49 ) 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 fn main() { let cli = Cli::parse(); // Let's assume the old version 1.2.3 let mut major = 1 ; let mut minor = 2 ; let mut patch = 3 ; // See if --set-ver was used to set the version manually let version = if let Some (ver) = cli.set_ver.as_deref() { if cli.major || cli.minor || cli.patch { let mut cmd = Cli::command();
            cmd. error (
                ErrorKind::ArgumentConflict, "Can't do relative and absolute version change" ,
            )
            .exit();
        }
        ver.to_string()
    } else { // Increment the one requested (in a real program, we'd reset the lower numbers) let (maj, min, pat) = (cli.major, cli.minor, cli.patch); match (maj, min, pat) {
            ( true , false , false ) => major += 1 ,
            ( false , true , false ) => minor += 1 ,
            ( false , false , true ) => patch += 1 , _ => { let mut cmd = Cli::command();
                cmd. error (
                    ErrorKind::ArgumentConflict, "Can only modify one version field" ,
                )
                .exit();
            }
        }; format! ( "{major}.{minor}.{patch}" )
    }; println! ( "Version: {version}" ); // Check for usage of -c if let Some (config) = cli.config.as_deref() { let input = cli
            .input_file
            .as_deref() // 'or' is preferred to 'or_else' here since `Option::as_deref` is 'const' .or(cli.spec_in.as_deref())
            .unwrap_or_else(|| { let mut cmd = Cli::command();
                cmd. error (
                    ErrorKind::MissingRequiredArgument, "INPUT_FILE or --spec-in is required when using --config" ,
                )
                .exit()
            }); println! ( "Doing work using input {input} and config {config}" );
    }
} source pub fn get_matches (self) -> ArgMatches Parse env::args_os , exiting on failure. Â§ Panics If contradictory arguments or settings exist (debug builds). Â§ Examples let matches = Command::new( "myprog" ) // Args and options go here... .get_matches(); Examples found in repository ? examples/derive_ref/augment_subcommands.rs ( line 16 ) 11 12 13 14 15 16 17 18 19 20 21 fn main() { let cli = Command::new( "Built CLI" ); // Augment with derived subcommands let cli = Subcommands::augment_subcommands(cli); let matches = cli. get_matches (); let derived_subcommands = Subcommands::from_arg_matches( & matches)
        .map_err(|err| err.exit())
        .unwrap(); println! ( "Derived subcommands: {derived_subcommands:#?}" );
} More examples Hide additional examples examples/tutorial_builder/02_apps.rs ( line 9 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn main() { let matches = Command::new( "MyApp" )
        .version( "1.0" )
        .about( "Does awesome things" )
        .arg( arg! (--two <VALUE>).required( true ))
        .arg( arg! (--one <VALUE>).required( true ))
        . get_matches (); println! ( "two: {:?}" ,
        matches.get_one::<String>( "two" ).expect( "required" )
    ); println! ( "one: {:?}" ,
        matches.get_one::<String>( "one" ).expect( "required" )
    );
} examples/multicall-hostname.rs ( line 12 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .subcommand(Command::new( "hostname" ).about( "show hostname part of FQDN" ))
        .subcommand(Command::new( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd. get_matches ().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/derive_ref/augment_args.rs ( line 14 ) 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 fn main() { let cli = Command::new( "CLI" ).arg( arg! (-b - -built).action(clap::ArgAction::SetTrue)); // Augment built args with derived args let cli = DerivedArgs::augment_args(cli); let matches = cli. get_matches (); println! ( "Value of built: {:?}" , matches.get_flag( "built" )); println! ( "Value of derived via ArgMatches: {:?}" ,
        matches.get_flag( "derived" )
    ); // Since DerivedArgs implements FromArgMatches, we can extract it from the unstructured ArgMatches.
    // This is the main benefit of using derived arguments. let derived_matches = DerivedArgs::from_arg_matches( & matches)
        .map_err(|err| err.exit())
        .unwrap(); println! ( "Value of derived: {derived_matches:#?}" );
} examples/multicall-busybox.rs ( line 34 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand(
            Command::new( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd. get_matches (); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/git.rs ( line 61 ) 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 fn main() { let matches = cli(). get_matches (); match matches.subcommand() { Some (( "clone" , sub_matches)) => { println! ( "Cloning {}" ,
                sub_matches.get_one::<String>( "REMOTE" ).expect( "required" )
            );
        } Some (( "diff" , sub_matches)) => { let color = sub_matches
                .get_one::<String>( "color" )
                .map(|s| s.as_str())
                .expect( "defaulted in clap" ); let mut base = sub_matches.get_one::<String>( "base" ).map(|s| s.as_str()); let mut head = sub_matches.get_one::<String>( "head" ).map(|s| s.as_str()); let mut path = sub_matches.get_one::<String>( "path" ).map(|s| s.as_str()); if path.is_none() {
                path = head;
                head = None ; if path.is_none() {
                    path = base;
                    base = None ;
                }
            } let base = base.unwrap_or( "stage" ); let head = head.unwrap_or( "worktree" ); let path = path.unwrap_or( "" ); println! ( "Diffing {base}..{head} {path} (color={color})" );
        } Some (( "push" , sub_matches)) => { println! ( "Pushing to {}" ,
                sub_matches.get_one::<String>( "REMOTE" ).expect( "required" )
            );
        } Some (( "add" , sub_matches)) => { let paths = sub_matches
                .get_many::<PathBuf>( "PATH" )
                .into_iter()
                .flatten()
                .collect::<Vec< _ >>(); println! ( "Adding {paths:?}" );
        } Some (( "stash" , sub_matches)) => { let stash_command = sub_matches.subcommand().unwrap_or(( "push" , sub_matches)); match stash_command {
                ( "apply" , sub_matches) => { let stash = sub_matches.get_one::<String>( "STASH" ); println! ( "Applying {stash:?}" );
                }
                ( "pop" , sub_matches) => { let stash = sub_matches.get_one::<String>( "STASH" ); println! ( "Popping {stash:?}" );
                }
                ( "push" , sub_matches) => { let message = sub_matches.get_one::<String>( "message" ); println! ( "Pushing {message:?}" );
                }
                (name, _ ) => { unreachable! ( "Unsupported subcommand `{name}`" )
                }
            }
        } Some ((ext, sub_matches)) => { let args = sub_matches
                .get_many::<OsString>( "" )
                .into_iter()
                .flatten()
                .collect::<Vec< _ >>(); println! ( "Calling out to {ext:?} with {args:?}" );
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable!() } // Continued program logic goes here... } Additional examples can be found in: examples/pacman.rs source pub fn get_matches_mut (&mut self) -> ArgMatches Parse env::args_os , exiting on failure. Like Command::get_matches but doesnâ€™t consume the Command . Â§ Panics If contradictory arguments or settings exist (debug builds). Â§ Examples let mut cmd = Command::new( "myprog" ) // Args and options go here... ; let matches = cmd.get_matches_mut(); source pub fn try_get_matches (self) -> Result < ArgMatches , Error > Parse env::args_os , returning a clap::Result on failure. NOTE: This method WILL NOT exit when --help or --version (or short versions) are
used. It will return a clap::Error , where the kind is a ErrorKind::DisplayHelp or ErrorKind::DisplayVersion respectively. You must call Error::exit or perform a std::process::exit . Â§ Panics If contradictory arguments or settings exist (debug builds). Â§ Examples let matches = Command::new( "myprog" ) // Args and options go here... .try_get_matches()
    .unwrap_or_else(|e| e.exit()); source pub fn get_matches_from <I, T>(self, itr: I) -> ArgMatches where
    I: IntoIterator <Item = T>,
    T: Into < OsString > + Clone , Parse the specified arguments, exiting on failure. NOTE: The first argument will be parsed as the binary name unless Command::no_binary_name is used. Â§ Panics If contradictory arguments or settings exist (debug builds). Â§ Examples let arg_vec = vec! [ "my_prog" , "some" , "args" , "to" , "parse" ]; let matches = Command::new( "myprog" ) // Args and options go here... .get_matches_from(arg_vec); source pub fn try_get_matches_from <I, T>(self, itr: I) -> Result < ArgMatches , Error > where
    I: IntoIterator <Item = T>,
    T: Into < OsString > + Clone , Parse the specified arguments, returning a clap::Result on failure. NOTE: This method WILL NOT exit when --help or --version (or short versions) are
used. It will return a clap::Error , where the kind is a ErrorKind::DisplayHelp or ErrorKind::DisplayVersion respectively. You must call Error::exit or
perform a std::process::exit yourself. NOTE: The first argument will be parsed as the binary name unless Command::no_binary_name is used. Â§ Panics If contradictory arguments or settings exist (debug builds). Â§ Examples let arg_vec = vec! [ "my_prog" , "some" , "args" , "to" , "parse" ]; let matches = Command::new( "myprog" ) // Args and options go here... .try_get_matches_from(arg_vec)
    .unwrap_or_else(|e| e.exit()); Examples found in repository ? examples/repl.rs ( line 32 ) 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 fn respond(line: & str) -> Result <bool, String> { let args = shlex::split(line).ok_or( "error: Invalid quoting" ) ? ; let matches = cli()
        . try_get_matches_from (args)
        .map_err(|e| e.to_string()) ? ; match matches.subcommand() { Some (( "ping" , _matches)) => { write! (std::io::stdout(), "Pong" ).map_err(|e| e.to_string()) ? ;
            std::io::stdout().flush().map_err(|e| e.to_string()) ? ;
        } Some (( "quit" , _matches)) => { write! (std::io::stdout(), "Exiting ..." ).map_err(|e| e.to_string()) ? ;
            std::io::stdout().flush().map_err(|e| e.to_string()) ? ; return Ok ( true );
        } Some ((name, _matches)) => unimplemented! ( "{name}" ), None => unreachable! ( "subcommand required" ),
    } Ok ( false )
} source pub fn try_get_matches_from_mut <I, T>(
    &mut self,
    itr: I,
) -> Result < ArgMatches , Error > where
    I: IntoIterator <Item = T>,
    T: Into < OsString > + Clone , Parse the specified arguments, returning a clap::Result on failure. Like Command::try_get_matches_from but doesnâ€™t consume the Command . NOTE: This method WILL NOT exit when --help or --version (or short versions) are
used. It will return a clap::Error , where the kind is a ErrorKind::DisplayHelp or ErrorKind::DisplayVersion respectively. You must call Error::exit or
perform a std::process::exit yourself. NOTE: The first argument will be parsed as the binary name unless Command::no_binary_name is used. Â§ Panics If contradictory arguments or settings exist (debug builds). Â§ Examples let arg_vec = vec! [ "my_prog" , "some" , "args" , "to" , "parse" ]; let mut cmd = Command::new( "myprog" ); // Args and options go here... let matches = cmd.try_get_matches_from_mut(arg_vec)
    .unwrap_or_else(|e| e.exit()); source pub fn print_help (&mut self) -> Result < () , Error > Prints the short help message ( -h ) to io::stdout() . See also Command::print_long_help . Â§ Examples let mut cmd = Command::new( "myprog" );
cmd.print_help(); source pub fn print_long_help (&mut self) -> Result < () , Error > Prints the long help message ( --help ) to io::stdout() . See also Command::print_help . Â§ Examples let mut cmd = Command::new( "myprog" );
cmd.print_long_help(); source pub fn render_help (&mut self) -> StyledStr Render the short help message ( -h ) to a StyledStr See also Command::render_long_help . Â§ Examples use std::io; let mut cmd = Command::new( "myprog" ); let mut out = io::stdout(); let help = cmd.render_help(); println! ( "{help}" ); source pub fn render_long_help (&mut self) -> StyledStr Render the long help message ( --help ) to a StyledStr . See also Command::render_help . Â§ Examples use std::io; let mut cmd = Command::new( "myprog" ); let mut out = io::stdout(); let help = cmd.render_long_help(); println! ( "{help}" ); source pub fn render_version (&self) -> String Version message rendered as if the user ran -V . See also Command::render_long_version . Â§ Coloring This function does not try to color the message nor it inserts any ANSI escape codes . Â§ Examples use std::io; let cmd = Command::new( "myprog" ); println! ( "{}" , cmd.render_version()); source pub fn render_long_version (&self) -> String Version message rendered as if the user ran --version . See also Command::render_version . Â§ Coloring This function does not try to color the message nor it inserts any ANSI escape codes . Â§ Examples use std::io; let cmd = Command::new( "myprog" ); println! ( "{}" , cmd.render_long_version()); source pub fn render_usage (&mut self) -> StyledStr Usage statement Â§ Examples use std::io; let mut cmd = Command::new( "myprog" ); println! ( "{}" , cmd.render_usage()); source Â§ impl Command Â§ Application-wide Settings These settings will apply to the top-level command and all subcommands, by default.  Some
settings can be overridden in subcommands. source pub fn no_binary_name (self, yes: bool ) -> Command Specifies that the parser should not assume the first argument passed is the binary name. This is normally the case when using a â€œdaemonâ€ style mode.  For shells / REPLs, see Command::multicall . Â§ Examples let m = Command::new( "myprog" )
    .no_binary_name( true )
    .arg( arg! (<cmd> ... "commands to run" ))
    .get_matches_from( vec! [ "command" , "set" ]); let cmds: Vec< _ > = m.get_many::<String>( "cmd" ).unwrap().collect(); assert_eq! (cmds, [ "command" , "set" ]); source pub fn ignore_errors (self, yes: bool ) -> Command Try not to fail on parse errors, like missing option values. NOTE: This choice is propagated to all child subcommands. Â§ Examples let cmd = Command::new( "cmd" )
  .ignore_errors( true )
  .arg( arg! (-c --config <FILE> "Sets a custom config file" ))
  .arg( arg! (-x --stuff <FILE> "Sets a custom stuff file" ))
  .arg( arg! (f: -f "Flag" )); let r = cmd.try_get_matches_from( vec! [ "cmd" , "-c" , "file" , "-f" , "-x" ]); assert! (r.is_ok(), "unexpected error: {r:?}" ); let m = r.unwrap(); assert_eq! (m.get_one::<String>( "config" ).unwrap(), "file" ); assert! (m.get_flag( "f" )); assert_eq! (m.get_one::<String>( "stuff" ), None ); source pub fn args_override_self (self, yes: bool ) -> Command Replace prior occurrences of arguments rather than error For any argument that would conflict with itself by default (e.g. ArgAction::Set , it will now override itself. This is the equivalent to saying the foo arg using Arg::overrides_with("foo") for all
defined arguments. NOTE: This choice is propagated to all child subcommands. source pub fn dont_delimit_trailing_values (self, yes: bool ) -> Command Disables the automatic delimiting of values after -- or when Arg::trailing_var_arg was used. NOTE: The same thing can be done manually by setting the final positional argument to Arg::value_delimiter(None) . Using this setting is safer, because itâ€™s easier to locate
when making changes. NOTE: This choice is propagated to all child subcommands. Â§ Examples Command::new( "myprog" )
    .dont_delimit_trailing_values( true )
    .get_matches(); source pub fn color (self, color: ColorChoice ) -> Command Available on crate feature color only. Sets when to color output. To customize how the output is styled, see Command::styles . NOTE: This choice is propagated to all child subcommands. NOTE: Default behaviour is ColorChoice::Auto . Â§ Examples Command::new( "myprog" )
    .color(ColorChoice::Never)
    .get_matches(); source pub fn styles (self, styles: Styles ) -> Command Available on crate feature color only. Sets the Styles for terminal output NOTE: This choice is propagated to all child subcommands. NOTE: Default behaviour is Styles::default . Â§ Examples const STYLES: styling::Styles = styling::Styles::styled()
    .header(styling::AnsiColor::Green.on_default().bold())
    .usage(styling::AnsiColor::Green.on_default().bold())
    .literal(styling::AnsiColor::Blue.on_default().bold())
    .placeholder(styling::AnsiColor::Cyan.on_default());
Command::new( "myprog" )
    .styles(STYLES)
    .get_matches(); source pub fn term_width (self, width: usize ) -> Command Available on non-crate feature unstable-v5 or crate feature wrap_help only. Sets the terminal width at which to wrap help messages. Using 0 will ignore terminal widths and use source formatting. Defaults to current terminal width when wrap_help feature flag is enabled.  If current
width cannot be determined, the default is 100. unstable-v5 feature : Defaults to unbound, being subject to Command::max_term_width . NOTE: This setting applies globally and not on a per-command basis. NOTE: This requires the wrap_help feature Â§ Examples Command::new( "myprog" )
    .term_width( 80 ) source pub fn max_term_width (self, width: usize ) -> Command Available on non-crate feature unstable-v5 or crate feature wrap_help only. Limit the line length for wrapping help when using the current terminalâ€™s width. This only applies when term_width is unset so that the current
terminalâ€™s width will be used.  See Command::term_width for more details. Using 0 will ignore this, always respecting Command::term_width (default). unstable-v5 feature : Defaults to 100. NOTE: This setting applies globally and not on a per-command basis. NOTE: This requires the wrap_help feature Â§ Examples Command::new( "myprog" )
    .max_term_width( 100 ) source pub fn disable_version_flag (self, yes: bool ) -> Command Disables -V and --version flag. Â§ Examples let res = Command::new( "myprog" )
    .version( "1.0.0" )
    .disable_version_flag( true )
    .try_get_matches_from( vec! [ "myprog" , "--version" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::UnknownArgument); You can create a custom version flag with ArgAction::Version let mut cmd = Command::new( "myprog" )
    .version( "1.0.0" ) // Remove the `-V` short flag .disable_version_flag( true )
    .arg(
        Arg::new( "version" )
            .long( "version" )
            .action(ArgAction::Version)
            .help( "Print version" )
    ); let res = cmd.try_get_matches_from_mut( vec! [ "myprog" , "-V" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::UnknownArgument); let res = cmd.try_get_matches_from_mut( vec! [ "myprog" , "--version" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::DisplayVersion); source pub fn propagate_version (self, yes: bool ) -> Command Specifies to use the version of the current command for all subcommands . Defaults to false ; subcommands have independent version strings from their parents. NOTE: This choice is propagated to all child subcommands. Â§ Examples Command::new( "myprog" )
    .version( "v1.1" )
    .propagate_version( true )
    .subcommand(Command::new( "test" ))
    .get_matches(); // running `$ myprog test --version` will display
// "myprog-test v1.1" source pub fn next_line_help (self, yes: bool ) -> Command Places the help string for all arguments and subcommands on the line after them. NOTE: This choice is propagated to all child subcommands. Â§ Examples Command::new( "myprog" )
    .next_line_help( true )
    .get_matches(); source pub fn disable_help_flag (self, yes: bool ) -> Command Disables -h and --help flag. NOTE: This choice is propagated to all child subcommands. Â§ Examples let res = Command::new( "myprog" )
    .disable_help_flag( true )
    .try_get_matches_from( vec! [ "myprog" , "-h" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::UnknownArgument); You can create a custom help flag with ArgAction::Help , ArgAction::HelpShort , or ArgAction::HelpLong let mut cmd = Command::new( "myprog" ) // Change help short flag to `?` .disable_help_flag( true )
    .arg(
        Arg::new( "help" )
            .short( '?' )
            .long( "help" )
            .action(ArgAction::Help)
            .help( "Print help" )
    ); let res = cmd.try_get_matches_from_mut( vec! [ "myprog" , "-h" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::UnknownArgument); let res = cmd.try_get_matches_from_mut( vec! [ "myprog" , "-?" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::DisplayHelp); source pub fn disable_help_subcommand (self, yes: bool ) -> Command Disables the help subcommand . NOTE: This choice is propagated to all child subcommands. Â§ Examples let res = Command::new( "myprog" )
    .disable_help_subcommand( true ) // Normally, creating a subcommand causes a `help` subcommand to automatically
    // be generated as well .subcommand(Command::new( "test" ))
    .try_get_matches_from( vec! [ "myprog" , "help" ]); assert! (res.is_err()); assert_eq! (res.unwrap_err().kind(), ErrorKind::InvalidSubcommand); source pub fn disable_colored_help (self, yes: bool ) -> Command Disables colorized help messages. NOTE: This choice is propagated to all child subcommands. Â§ Examples Command::new( "myprog" )
    .disable_colored_help( true )
    .get_matches(); source pub fn help_expected (self, yes: bool ) -> Command Panic if help descriptions are omitted. NOTE: When deriving Parser , you could instead check this at
compile-time with #![deny(missing_docs)] NOTE: This choice is propagated to all child subcommands. Â§ Examples Command::new( "myprog" )
    .help_expected( true )
    .arg(
        Arg::new( "foo" ).help( "It does foo stuff" ) // As required via `help_expected`, a help message was supplied ) Â§ Panics On debug builds: Command::new( "myapp" )
    .help_expected( true )
    .arg(
        Arg::new( "foo" ) // Someone forgot to put .about("...") here
        // Since the setting `help_expected` is activated, this will lead to
        // a panic (if you are in debug mode) ) source pub fn hide_possible_values (self, yes: bool ) -> Command Tells clap not to print possible values when displaying help information. This can be useful if there are many values, or they are explained elsewhere. To set this per argument, see Arg::hide_possible_values . NOTE: This choice is propagated to all child subcommands. source pub fn infer_long_args (self, yes: bool ) -> Command Allow partial matches of long arguments or their aliases . For example, to match an argument named --test , one could use --t , --te , --tes , and --test . NOTE: The match must not be ambiguous at all in order to succeed. i.e. to match --te to --test there could not also be another argument or alias --temp because both
start with --te NOTE: This choice is propagated to all child subcommands. source pub fn infer_subcommands (self, yes: bool ) -> Command Allow partial matches of subcommand names and their aliases . For example, to match a subcommand named test , one could use t , te , tes , and test . NOTE: The match must not be ambiguous at all in order to succeed. i.e. to match te to test there could not also be a subcommand or alias temp because both start with te CAUTION: This setting can interfere with positional/free arguments , take care when
designing CLIs which allow inferred subcommands and have potential positional/free
arguments whose values could start with the same characters as subcommands. If this is the
case, itâ€™s recommended to use settings such as Command::args_conflicts_with_subcommands in
conjunction with this setting. NOTE: This choice is propagated to all child subcommands. Â§ Examples let m = Command::new( "prog" )
    .infer_subcommands( true )
    .subcommand(Command::new( "test" ))
    .get_matches_from( vec! [ "prog" , "te" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source Â§ impl Command Â§ Command-specific Settings These apply only to the current command and are not inherited by subcommands. source pub fn name (self, name: impl Into < Str >) -> Command (Re)Sets the programâ€™s name. See Command::new for more details. Â§ Examples â“˜ let cmd = clap::command! ()
    .name( "foo" ); // continued logic goes here, such as `cmd.get_matches()` etc. source pub fn bin_name (self, name: impl IntoResettable < String >) -> Command Overrides the runtime-determined name of the binary for help and error messages. This should only be used when absolutely necessary, such as when the binary name for your
application is misleading, or perhaps not how the user should invoke your program. Pro-tip: When building things such as third party cargo subcommands, this setting should be used! NOTE: This does not change or set the name of the binary file on
disk. It only changes what clap thinks the name is for the purposes of
error or help messages. Â§ Examples Command::new( "My Program" )
     .bin_name( "my_binary" ) source pub fn display_name (self, name: impl IntoResettable < String >) -> Command Overrides the runtime-determined display name of the program for help and error messages. Â§ Examples Command::new( "My Program" )
     .display_name( "my_program" ) source pub fn author (self, author: impl IntoResettable < Str >) -> Command Sets the author(s) for the help message. Pro-tip: Use clap s convenience macro crate_authors! to
automatically set your applicationâ€™s author(s) to the same thing as your
crate at compile time. NOTE: A custom help_template is needed for author to show
up. Â§ Examples Command::new( "myprog" )
     .author( "Me, me@mymain.com" ) source pub fn about (self, about: impl IntoResettable < StyledStr >) -> Command Sets the programâ€™s description for the short help ( -h ). If Command::long_about is not specified, this message will be displayed for --help . NOTE: Only Command::about (short format) is used in completion
script generation in order to be concise. See also crate_description! . Â§ Examples Command::new( "myprog" )
    .about( "Does really amazing things for great people" ) Examples found in repository ? examples/multicall-busybox.rs ( line 8 ) 6 7 8 9 10 11 fn applet_commands() -> [Command; 2 ] {
    [
        Command::new( "true" ). about ( "does nothing successfully" ),
        Command::new( "false" ). about ( "does nothing unsuccessfully" ),
    ]
} More examples Hide additional examples examples/tutorial_builder/02_apps.rs ( line 6 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn main() { let matches = Command::new( "MyApp" )
        .version( "1.0" )
        . about ( "Does awesome things" )
        .arg( arg! (--two <VALUE>).required( true ))
        .arg( arg! (--one <VALUE>).required( true ))
        .get_matches(); println! ( "two: {:?}" ,
        matches.get_one::<String>( "two" ).expect( "required" )
    ); println! ( "one: {:?}" ,
        matches.get_one::<String>( "one" ).expect( "required" )
    );
} examples/multicall-hostname.rs ( line 9 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .subcommand(Command::new( "hostname" ). about ( "show hostname part of FQDN" ))
        .subcommand(Command::new( "dnsdomainname" ). about ( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/repl.rs ( line 73 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                . about ( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                . about ( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/git.rs ( line 8 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        . about ( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                . about ( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                . about ( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                . about ( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                . about ( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} examples/pacman.rs ( line 5 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        . about ( "package manager utility" )
        .version( "5.2.1" )
        .subcommand_required( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                .short_flag( 'Q' )
                .long_flag( "query" )
                . about ( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                .short_flag( 'S' )
                .long_flag( "sync" )
                . about ( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn long_about (self, long_about: impl IntoResettable < StyledStr >) -> Command Sets the programâ€™s description for the long help ( --help ). If not set, Command::about will be used for long help in addition to short help
( -h ). NOTE: Only Command::about (short format) is used in completion
script generation in order to be concise. Â§ Examples Command::new( "myprog" )
    .long_about( "Does really amazing things to great people. Now let's talk a little
 more in depth about how this subcommand really works. It may take about
 a few lines of text, but that's ok!" ) source pub fn after_help (self, help: impl IntoResettable < StyledStr >) -> Command Free-form help text for after auto-generated short help ( -h ). This is often used to describe how to use the arguments, caveats to be noted, or license
and contact information. If Command::after_long_help is not specified, this message will be displayed for --help . Â§ Examples Command::new( "myprog" )
    .after_help( "Does really amazing things for great people... but be careful with -R!" ) source pub fn after_long_help (self, help: impl IntoResettable < StyledStr >) -> Command Free-form help text for after auto-generated long help ( --help ). This is often used to describe how to use the arguments, caveats to be noted, or license
and contact information. If not set, Command::after_help will be used for long help in addition to short help
( -h ). Â§ Examples Command::new( "myprog" )
    .after_long_help( "Does really amazing things to great people... but be careful with -R, \
                     like, for real, be careful with this!" ) source pub fn before_help (self, help: impl IntoResettable < StyledStr >) -> Command Free-form help text for before auto-generated short help ( -h ). This is often used for header, copyright, or license information. If Command::before_long_help is not specified, this message will be displayed for --help . Â§ Examples Command::new( "myprog" )
    .before_help( "Some info I'd like to appear before the help info" ) source pub fn before_long_help (self, help: impl IntoResettable < StyledStr >) -> Command Free-form help text for before auto-generated long help ( --help ). This is often used for header, copyright, or license information. If not set, Command::before_help will be used for long help in addition to short help
( -h ). Â§ Examples Command::new( "myprog" )
    .before_long_help( "Some verbose and long info I'd like to appear before the help info" ) source pub fn version (self, ver: impl IntoResettable < Str >) -> Command Sets the version for the short version ( -V ) and help messages. If Command::long_version is not specified, this message will be displayed for --version . Pro-tip: Use clap s convenience macro crate_version! to
automatically set your applicationâ€™s version to the same thing as your
crate at compile time. Â§ Examples Command::new( "myprog" )
    .version( "v0.1.24" ) Examples found in repository ? examples/tutorial_builder/02_apps.rs ( line 5 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 fn main() { let matches = Command::new( "MyApp" )
        . version ( "1.0" )
        .about( "Does awesome things" )
        .arg( arg! (--two <VALUE>).required( true ))
        .arg( arg! (--one <VALUE>).required( true ))
        .get_matches(); println! ( "two: {:?}" ,
        matches.get_one::<String>( "two" ).expect( "required" )
    ); println! ( "one: {:?}" ,
        matches.get_one::<String>( "one" ).expect( "required" )
    );
} More examples Hide additional examples examples/pacman.rs ( line 6 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        . version ( "5.2.1" )
        .subcommand_required( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                .short_flag( 'Q' )
                .long_flag( "query" )
                .about( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                .short_flag( 'S' )
                .long_flag( "sync" )
                .about( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn long_version (self, ver: impl IntoResettable < Str >) -> Command Sets the version for the long version ( --version ) and help messages. If Command::version is not specified, this message will be displayed for -V . Pro-tip: Use clap s convenience macro crate_version! to
automatically set your applicationâ€™s version to the same thing as your
crate at compile time. Â§ Examples Command::new( "myprog" )
    .long_version( "v0.1.24
 commit: abcdef89726d
 revision: 123
 release: 2
 binary: myprog" ) source pub fn override_usage (self, usage: impl IntoResettable < StyledStr >) -> Command Overrides the clap generated usage string for help and error messages. NOTE: Using this setting disables clap s â€œcontext-awareâ€ usage
strings. After this setting is set, this will be the only usage string
displayed to the user! NOTE: Multiple usage lines may be present in the usage argument, but
some rules need to be followed to ensure the usage lines are formatted
correctly by the default help formatter: Do not indent the first usage line. Indent all subsequent usage lines with seven spaces. The last line must not end with a newline. Â§ Examples Command::new( "myprog" )
    .override_usage( "myapp [-clDas] <some_file>" ) Or for multiple usage lines: Command::new( "myprog" )
    .override_usage( "myapp -X [-a] [-b] <file>\n       \
         myapp -Y [-c] <file1> <file2>\n       \
         myapp -Z [-d|-e]" ) source pub fn override_help (self, help: impl IntoResettable < StyledStr >) -> Command Overrides the clap generated help message (both -h and --help ). This should only be used when the auto-generated message does not suffice. NOTE: This only replaces the help message for the current
command, meaning if you are using subcommands, those help messages will
still be auto-generated unless you specify a Command::override_help for
them as well. Â§ Examples Command::new( "myapp" )
    .override_help( "myapp v1.0\n\
           Does awesome things\n\
           (C) me@mail.com\n\n\

           Usage: myapp <opts> <command>\n\n\

           Options:\n\
           -h, --help       Display this message\n\
           -V, --version    Display version info\n\
           -s <stuff>       Do something with stuff\n\
           -v               Be verbose\n\n\

           Commands:\n\
           help             Print this message\n\
           work             Do some work" ) source pub fn help_template (self, s: impl IntoResettable < StyledStr >) -> Command Available on crate feature help only. Sets the help template to be used, overriding the default format. NOTE: The template system is by design very simple. Therefore, the
tags have to be written in the lowercase and without spacing. Tags are given inside curly brackets. Valid tags are: {name} - Display name for the (sub-)command. {bin} - Binary name.(deprecated) {version} - Version number. {author} - Author information. {author-with-newline} - Author followed by \n . {author-section} - Author preceded and followed by \n . {about} - General description (from Command::about or Command::long_about ). {about-with-newline} - About followed by \n . {about-section} - About preceded and followed by â€˜\nâ€™. {usage-heading} - Automatically generated usage heading. {usage} - Automatically generated or given usage string. {all-args} - Help for all arguments (options, flags, positional
arguments, and subcommands) including titles. {options} - Help for options. {positionals} - Help for positional arguments. {subcommands} - Help for subcommands. {tab} - Standard tab sized used within clap {after-help} - Help from Command::after_help or Command::after_long_help . {before-help} - Help from Command::before_help or Command::before_long_help . Â§ Examples For a very brief help: Command::new( "myprog" )
    .version( "1.0" )
    .help_template( "{name} ({version}) - {usage}" ) For showing more application context: Command::new( "myprog" )
    .version( "1.0" )
    .help_template( "\
{before-help}{name} {version}
{author-with-newline}{about-with-newline}
{usage-heading} {usage}

{all-args}{after-help}
" ) Examples found in repository ? examples/repl.rs ( line 70 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        . help_template (PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                . help_template (APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                . help_template (APPLET_TEMPLATE),
        )
} source pub fn flatten_help (self, yes: bool ) -> Command Flatten subcommand help into the current commandâ€™s help This shows a summary of subcommands within the usage and help for the current command, similar to git stash --help showing information on push , pop , etc.
To see more information, a user can still pass --help to the individual subcommands. Examples found in repository ? examples/git.rs ( line 48 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                . flatten_help ( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} source pub fn next_help_heading (self, heading: impl IntoResettable < Str >) -> Command Set the default section heading for future args. This will be used for any arg that hasnâ€™t had Arg::help_heading called. This is useful if the default Options or Arguments headings are
not specific enough for oneâ€™s use case. For subcommands, see Command::subcommand_help_heading source pub fn next_display_order (self, disp_ord: impl IntoResettable < usize >) -> Command Change the starting value for assigning future display orders for args. This will be used for any arg that hasnâ€™t had Arg::display_order called. source pub fn arg_required_else_help (self, yes: bool ) -> Command Exit gracefully if no arguments are present (e.g. $ myprog ). NOTE: subcommands count as arguments Â§ Examples Command::new( "myprog" )
    .arg_required_else_help( true ); Examples found in repository ? examples/multicall-hostname.rs ( line 6 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        . arg_required_else_help ( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .subcommand(Command::new( "hostname" ).about( "show hostname part of FQDN" ))
        .subcommand(Command::new( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} More examples Hide additional examples examples/repl.rs ( line 66 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        . arg_required_else_help ( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/multicall-busybox.rs ( line 18 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand(
            Command::new( "busybox" )
                . arg_required_else_help ( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} examples/git.rs ( line 10 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        . arg_required_else_help ( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                . arg_required_else_help ( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                . arg_required_else_help ( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                . arg_required_else_help ( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} examples/pacman.rs ( line 8 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        .version( "5.2.1" )
        .subcommand_required( true )
        . arg_required_else_help ( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                .short_flag( 'Q' )
                .long_flag( "query" )
                .about( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                .short_flag( 'S' )
                .long_flag( "sync" )
                .about( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn allow_missing_positional (self, yes: bool ) -> Command Allows one to implement two styles of CLIs where positionals can be used out of order. The first example is a CLI where the second to last positional argument is optional, but
the final positional argument is required. Such as $ prog [optional] <required> where one
of the two following usages is allowed: $ prog [optional] <required> $ prog <required> This would otherwise not be allowed. This is useful when [optional] has a default value. Note: when using this style of â€œmissing positionalsâ€ the final positional must be required if -- will not be used to skip to the final positional argument. Note: This style also only allows a single positional argument to be â€œskippedâ€ without
the use of -- . To skip more than one, see the second example. The second example is when one wants to skip multiple optional positional arguments, and use
of the -- operator is OK (but not required if all arguments will be specified anyways). For example, imagine a CLI which has three positional arguments [foo] [bar] [baz]... where baz accepts multiple values (similar to man ARGS... style training arguments). With this setting the following invocations are possible: $ prog foo bar baz1 baz2 baz3 $ prog foo -- baz1 baz2 baz3 $ prog -- baz1 baz2 baz3 Â§ Examples Style number one from above: // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .allow_missing_positional( true )
    .arg(Arg::new( "arg1" ))
    .arg(Arg::new( "arg2" )
        .required( true ))
    .get_matches_from( vec! [ "prog" , "other" ]); assert_eq! (m.get_one::<String>( "arg1" ), None ); assert_eq! (m.get_one::<String>( "arg2" ).unwrap(), "other" ); Now the same example, but using a default value for the first optional positional argument // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .allow_missing_positional( true )
    .arg(Arg::new( "arg1" )
        .default_value( "something" ))
    .arg(Arg::new( "arg2" )
        .required( true ))
    .get_matches_from( vec! [ "prog" , "other" ]); assert_eq! (m.get_one::<String>( "arg1" ).unwrap(), "something" ); assert_eq! (m.get_one::<String>( "arg2" ).unwrap(), "other" ); Style number two from above: // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .allow_missing_positional( true )
    .arg(Arg::new( "foo" ))
    .arg(Arg::new( "bar" ))
    .arg(Arg::new( "baz" ).action(ArgAction::Set).num_args( 1 ..))
    .get_matches_from( vec! [ "prog" , "foo" , "bar" , "baz1" , "baz2" , "baz3" ]); assert_eq! (m.get_one::<String>( "foo" ).unwrap(), "foo" ); assert_eq! (m.get_one::<String>( "bar" ).unwrap(), "bar" ); assert_eq! (m.get_many::<String>( "baz" ).unwrap().collect::<Vec< _ >>(), & [ "baz1" , "baz2" , "baz3" ]); Now nofice if we donâ€™t specify foo or baz but use the -- operator. // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .allow_missing_positional( true )
    .arg(Arg::new( "foo" ))
    .arg(Arg::new( "bar" ))
    .arg(Arg::new( "baz" ).action(ArgAction::Set).num_args( 1 ..))
    .get_matches_from( vec! [ "prog" , "--" , "baz1" , "baz2" , "baz3" ]); assert_eq! (m.get_one::<String>( "foo" ), None ); assert_eq! (m.get_one::<String>( "bar" ), None ); assert_eq! (m.get_many::<String>( "baz" ).unwrap().collect::<Vec< _ >>(), & [ "baz1" , "baz2" , "baz3" ]); source Â§ impl Command Â§ Subcommand-specific Settings source pub fn short_flag (self, short: impl IntoResettable < char >) -> Command Sets the short version of the subcommand flag without the preceding - . Allows the subcommand to be used as if it were an Arg::short . Â§ Examples let matches = Command::new( "pacman" )
    .subcommand(
        Command::new( "sync" ).short_flag( 'S' ).arg(
            Arg::new( "search" )
                .short( 's' )
                .long( "search" )
                .action(ArgAction::SetTrue)
                .help( "search remote repositories for matching strings" ),
        ),
    )
    .get_matches_from( vec! [ "pacman" , "-Ss" ]); assert_eq! (matches.subcommand_name().unwrap(), "sync" ); let sync_matches = matches.subcommand_matches( "sync" ).unwrap(); assert! (sync_matches.get_flag( "search" )); Examples found in repository ? examples/pacman.rs ( line 14 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        .version( "5.2.1" )
        .subcommand_required( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                . short_flag ( 'Q' )
                .long_flag( "query" )
                .about( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                . short_flag ( 'S' )
                .long_flag( "sync" )
                .about( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn long_flag (self, long: impl Into < Str >) -> Command Sets the long version of the subcommand flag without the preceding -- . Allows the subcommand to be used as if it were an Arg::long . NOTE: Any leading - characters will be stripped. Â§ Examples To set long_flag use a word containing valid UTF-8 codepoints. If you supply a double leading -- such as --sync they will be stripped. Hyphens in the middle of the word; however,
will not be stripped (i.e. sync-file is allowed). let matches = Command::new( "pacman" )
    .subcommand(
        Command::new( "sync" ).long_flag( "sync" ).arg(
            Arg::new( "search" )
                .short( 's' )
                .long( "search" )
                .action(ArgAction::SetTrue)
                .help( "search remote repositories for matching strings" ),
        ),
    )
    .get_matches_from( vec! [ "pacman" , "--sync" , "--search" ]); assert_eq! (matches.subcommand_name().unwrap(), "sync" ); let sync_matches = matches.subcommand_matches( "sync" ).unwrap(); assert! (sync_matches.get_flag( "search" )); Examples found in repository ? examples/pacman.rs ( line 15 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        .version( "5.2.1" )
        .subcommand_required( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                .short_flag( 'Q' )
                . long_flag ( "query" )
                .about( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                .short_flag( 'S' )
                . long_flag ( "sync" )
                .about( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn alias (self, name: impl IntoResettable < Str >) -> Command Sets a hidden alias to this subcommand. This allows the subcommand to be accessed via either the original name, or this given
alias. This is more efficient and easier than creating multiple hidden subcommands as one
only needs to check for the existence of this command, and not all aliased variants. NOTE: Aliases defined with this method are hidden from the help
message. If youâ€™re looking for aliases that will be displayed in the help
message, see Command::visible_alias . NOTE: When using aliases and checking for the existence of a
particular subcommand within an ArgMatches struct, one only needs to
search for the original name and not all aliases. Â§ Examples let m = Command::new( "myprog" )
    .subcommand(Command::new( "test" )
        .alias( "do-stuff" ))
    .get_matches_from( vec! [ "myprog" , "do-stuff" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); Examples found in repository ? examples/repl.rs ( line 78 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                . alias ( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} source pub fn short_flag_alias (self, name: impl IntoResettable < char >) -> Command Add an alias, which functions as  â€œhiddenâ€ short flag subcommand This will automatically dispatch as if this subcommand was used. This is more efficient,
and easier than creating multiple hidden subcommands as one only needs to check for the
existence of this command, and not all variants. Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).short_flag( 't' )
                .short_flag_alias( 'd' ))
            .get_matches_from( vec! [ "myprog" , "-d" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn long_flag_alias (self, name: impl IntoResettable < Str >) -> Command Add an alias, which functions as a â€œhiddenâ€ long flag subcommand. This will automatically dispatch as if this subcommand was used. This is more efficient,
and easier than creating multiple hidden subcommands as one only needs to check for the
existence of this command, and not all variants. Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).long_flag( "test" )
                .long_flag_alias( "testing" ))
            .get_matches_from( vec! [ "myprog" , "--testing" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn aliases (self, names: impl IntoIterator <Item = impl Into < Str >>) -> Command Sets multiple hidden aliases to this subcommand. This allows the subcommand to be accessed via either the original name or any of the
given aliases. This is more efficient, and easier than creating multiple hidden subcommands
as one only needs to check for the existence of this command and not all aliased variants. NOTE: Aliases defined with this method are hidden from the help
message. If looking for aliases that will be displayed in the help
message, see Command::visible_aliases . NOTE: When using aliases and checking for the existence of a
particular subcommand within an ArgMatches struct, one only needs to
search for the original name and not all aliases. Â§ Examples let m = Command::new( "myprog" )
    .subcommand(Command::new( "test" )
        .aliases([ "do-stuff" , "do-tests" , "tests" ]))
        .arg(Arg::new( "input" )
            .help( "the file to add" )
            .required( false ))
    .get_matches_from( vec! [ "myprog" , "do-tests" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn short_flag_aliases (
    self,
    names: impl IntoIterator <Item = char >,
) -> Command Add aliases, which function as â€œhiddenâ€ short flag subcommands. These will automatically dispatch as if this subcommand was used. This is more efficient,
and easier than creating multiple hidden subcommands as one only needs to check for the
existence of this command, and not all variants. Â§ Examples let m = Command::new( "myprog" )
    .subcommand(Command::new( "test" ).short_flag( 't' )
        .short_flag_aliases([ 'a' , 'b' , 'c' ]))
        .arg(Arg::new( "input" )
            .help( "the file to add" )
            .required( false ))
    .get_matches_from( vec! [ "myprog" , "-a" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn long_flag_aliases (
    self,
    names: impl IntoIterator <Item = impl Into < Str >>,
) -> Command Add aliases, which function as â€œhiddenâ€ long flag subcommands. These will automatically dispatch as if this subcommand was used. This is more efficient,
and easier than creating multiple hidden subcommands as one only needs to check for the
existence of this command, and not all variants. Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).long_flag( "test" )
                .long_flag_aliases([ "testing" , "testall" , "test_all" ]))
                .arg(Arg::new( "input" )
                            .help( "the file to add" )
                            .required( false ))
            .get_matches_from( vec! [ "myprog" , "--testing" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn visible_alias (self, name: impl IntoResettable < Str >) -> Command Sets a visible alias to this subcommand. This allows the subcommand to be accessed via either the
original name or the given alias. This is more efficient and easier
than creating hidden subcommands as one only needs to check for
the existence of this command and not all aliased variants. NOTE: The alias defined with this method is visible from the help
message and displayed as if it were just another regular subcommand. If
looking for an alias that will not be displayed in the help message, see Command::alias . NOTE: When using aliases and checking for the existence of a
particular subcommand within an ArgMatches struct, one only needs to
search for the original name and not all aliases. Â§ Examples let m = Command::new( "myprog" )
    .subcommand(Command::new( "test" )
        .visible_alias( "do-stuff" ))
    .get_matches_from( vec! [ "myprog" , "do-stuff" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn visible_short_flag_alias (
    self,
    name: impl IntoResettable < char >,
) -> Command Add an alias, which functions as  â€œvisibleâ€ short flag subcommand This will automatically dispatch as if this subcommand was used. This is more efficient,
and easier than creating multiple hidden subcommands as one only needs to check for the
existence of this command, and not all variants. See also Command::short_flag_alias . Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).short_flag( 't' )
                .visible_short_flag_alias( 'd' ))
            .get_matches_from( vec! [ "myprog" , "-d" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn visible_long_flag_alias (self, name: impl IntoResettable < Str >) -> Command Add an alias, which functions as a â€œvisibleâ€ long flag subcommand. This will automatically dispatch as if this subcommand was used. This is more efficient,
and easier than creating multiple hidden subcommands as one only needs to check for the
existence of this command, and not all variants. See also Command::long_flag_alias . Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).long_flag( "test" )
                .visible_long_flag_alias( "testing" ))
            .get_matches_from( vec! [ "myprog" , "--testing" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn visible_aliases (
    self,
    names: impl IntoIterator <Item = impl Into < Str >>,
) -> Command Sets multiple visible aliases to this subcommand. This allows the subcommand to be accessed via either the
original name or any of the given aliases. This is more efficient and easier
than creating multiple hidden subcommands as one only needs to check for
the existence of this command and not all aliased variants. NOTE: The alias defined with this method is visible from the help
message and displayed as if it were just another regular subcommand. If
looking for an alias that will not be displayed in the help message, see Command::alias . NOTE: When using aliases, and checking for the existence of a
particular subcommand within an ArgMatches struct, one only needs to
search for the original name and not all aliases. Â§ Examples let m = Command::new( "myprog" )
    .subcommand(Command::new( "test" )
        .visible_aliases([ "do-stuff" , "tests" ]))
    .get_matches_from( vec! [ "myprog" , "do-stuff" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn visible_short_flag_aliases (
    self,
    names: impl IntoIterator <Item = char >,
) -> Command Add aliases, which function as visible short flag subcommands. See Command::short_flag_aliases . Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).short_flag( 'b' )
                .visible_short_flag_aliases([ 't' ]))
            .get_matches_from( vec! [ "myprog" , "-t" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn visible_long_flag_aliases (
    self,
    names: impl IntoIterator <Item = impl Into < Str >>,
) -> Command Add aliases, which function as visible long flag subcommands. See Command::long_flag_aliases . Â§ Examples let m = Command::new( "myprog" )
            .subcommand(Command::new( "test" ).long_flag( "test" )
                .visible_long_flag_aliases([ "testing" , "testall" , "test_all" ]))
            .get_matches_from( vec! [ "myprog" , "--testing" ]); assert_eq! (m.subcommand_name(), Some ( "test" )); source pub fn display_order (self, ord: impl IntoResettable < usize >) -> Command Set the placement of this subcommand within the help. Subcommands with a lower value will be displayed first in the help message.
Those with the same display order will be sorted. Command s are automatically assigned a display order based on the order they are added to
their parent Command .
Overriding this is helpful when the order commands are added in isnâ€™t the same as the
display order, whether in one-off cases or to automatically sort commands. Â§ Examples let m = Command::new( "cust-ord" )
    .subcommand(Command::new( "beta" )
        .display_order( 0 ) // Sort .about( "Some help and text" ))
    .subcommand(Command::new( "alpha" )
        .display_order( 0 ) // Sort .about( "I should be first!" ))
    .get_matches_from( vec! [ "cust-ord" , "--help" ]); The above example displays the following help message cust-ord

Usage: cust-ord [OPTIONS]

Commands:
    alpha    I should be first!
    beta     Some help and text
    help     Print help for the subcommand(s)

Options:
    -h, --help       Print help
    -V, --version    Print version source pub fn hide (self, yes: bool ) -> Command Specifies that this subcommand should be hidden from help messages Â§ Examples Command::new( "myprog" )
    .subcommand(
        Command::new( "test" ).hide( true )
    ) source pub fn subcommand_required (self, yes: bool ) -> Command If no subcommand is present at runtime, error and exit gracefully. Â§ Examples let err = Command::new( "myprog" )
    .subcommand_required( true )
    .subcommand(Command::new( "test" ))
    .try_get_matches_from( vec! [ "myprog" ,
    ]); assert! (err.is_err()); assert_eq! (err.unwrap_err().kind(), ErrorKind::MissingSubcommand); Examples found in repository ? examples/derive_ref/hand_subcommand.rs ( line 57 ) 54 55 56 57 58 59 60 61 62 63 fn augment_subcommands(cmd: Command) -> Command {
        cmd.subcommand(AddArgs::augment_args(Command::new( "add" )))
            .subcommand(RemoveArgs::augment_args(Command::new( "remove" )))
            . subcommand_required ( true )
    } fn augment_subcommands_for_update(cmd: Command) -> Command {
        cmd.subcommand(AddArgs::augment_args(Command::new( "add" )))
            .subcommand(RemoveArgs::augment_args(Command::new( "remove" )))
            . subcommand_required ( true )
    } More examples Hide additional examples examples/repl.rs ( line 67 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        . subcommand_required ( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/git.rs ( line 9 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        . subcommand_required ( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} examples/pacman.rs ( line 7 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 fn main() { let matches = Command::new( "pacman" )
        .about( "package manager utility" )
        .version( "5.2.1" )
        . subcommand_required ( true )
        .arg_required_else_help( true ) // Query subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "query" )
                .short_flag( 'Q' )
                .long_flag( "query" )
                .about( "Query the package database." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .help( "search locally installed packages for matching strings" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .short( 'i' )
                        .conflicts_with( "search" )
                        .help( "view package information" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        ) // Sync subcommand
        //
        // Only a few of its arguments are implemented below. .subcommand(
            Command::new( "sync" )
                .short_flag( 'S' )
                .long_flag( "sync" )
                .about( "Synchronize packages." )
                .arg(
                    Arg::new( "search" )
                        .short( 's' )
                        .long( "search" )
                        .conflicts_with( "info" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..)
                        .help( "search remote repositories for matching strings" ),
                )
                .arg(
                    Arg::new( "info" )
                        .long( "info" )
                        .conflicts_with( "search" )
                        .short( 'i' )
                        .action(ArgAction::SetTrue)
                        .help( "view package information" ),
                )
                .arg(
                    Arg::new( "package" )
                        .help( "packages" )
                        .required_unless_present( "search" )
                        .action(ArgAction::Set)
                        .num_args( 1 ..),
                ),
        )
        .get_matches(); match matches.subcommand() { Some (( "sync" , sync_matches)) => { if sync_matches.contains_id( "search" ) { let packages: Vec< _ > = sync_matches
                    .get_many::<String>( "search" )
                    .expect( "contains_id" )
                    .map(|s| s.as_str())
                    .collect(); let values = packages.join( ", " ); println! ( "Searching for {values}..." ); return ;
            } let packages: Vec< _ > = sync_matches
                .get_many::<String>( "package" )
                .expect( "is present" )
                .map(|s| s.as_str())
                .collect(); let values = packages.join( ", " ); if sync_matches.get_flag( "info" ) { println! ( "Retrieving info for {values}..." );
            } else { println! ( "Installing {values}..." );
            }
        } Some (( "query" , query_matches)) => { if let Some (packages) = query_matches.get_many::<String>( "info" ) { let comma_sep = packages.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Retrieving info for {comma_sep}..." );
            } else if let Some (queries) = query_matches.get_many::<String>( "search" ) { let comma_sep = queries.map(|s| s.as_str()).collect::<Vec< _ >>().join( ", " ); println! ( "Searching Locally for {comma_sep}..." );
            } else { println! ( "Displaying all locally installed packages..." );
            }
        } _ => unreachable! (), // If all subcommands are defined above, anything else is unreachable }
} source pub fn allow_external_subcommands (self, yes: bool ) -> Command Assume unexpected positional arguments are a subcommand . Arguments will be stored in the "" argument in the ArgMatches NOTE: Use this setting with caution,
as a truly unexpected argument (i.e. one that is NOT an external subcommand)
will not cause an error and instead be treated as a potential subcommand.
One should check for such cases manually and inform the user appropriately. NOTE: A built-in subcommand will be parsed as an external subcommand when escaped with -- . Â§ Examples // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .allow_external_subcommands( true )
    .get_matches_from( vec! [ "myprog" , "subcmd" , "--option" , "value" , "-fff" , "--flag" ]); // All trailing arguments will be stored under the subcommand's sub-matches using an empty
// string argument name match m.subcommand() { Some ((external, ext_m)) => { let ext_args: Vec< _ > = ext_m.get_many::<OsString>( "" ).unwrap().collect(); assert_eq! (external, "subcmd" ); assert_eq! (ext_args, [ "--option" , "value" , "-fff" , "--flag" ]);
    }, _ => {},
} Examples found in repository ? examples/git.rs ( line 11 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        . allow_external_subcommands ( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                .args_conflicts_with_subcommands( true )
                .flatten_help( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} source pub fn external_subcommand_value_parser (
    self,
    parser: impl IntoResettable < ValueParser >,
) -> Command Specifies how to parse external subcommand arguments. The default parser is for OsString .  This can be used to switch it to String or another
type. NOTE: Setting this requires Command::allow_external_subcommands Â§ Examples // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .allow_external_subcommands( true )
    .get_matches_from( vec! [ "myprog" , "subcmd" , "--option" , "value" , "-fff" , "--flag" ]); // All trailing arguments will be stored under the subcommand's sub-matches using an empty
// string argument name match m.subcommand() { Some ((external, ext_m)) => { let ext_args: Vec< _ > = ext_m.get_many::<OsString>( "" ).unwrap().collect(); assert_eq! (external, "subcmd" ); assert_eq! (ext_args, [ "--option" , "value" , "-fff" , "--flag" ]);
    }, _ => {},
} // Assume there is an external subcommand named "subcmd" let m = Command::new( "myprog" )
    .external_subcommand_value_parser( value_parser! (String))
    .get_matches_from( vec! [ "myprog" , "subcmd" , "--option" , "value" , "-fff" , "--flag" ]); // All trailing arguments will be stored under the subcommand's sub-matches using an empty
// string argument name match m.subcommand() { Some ((external, ext_m)) => { let ext_args: Vec< _ > = ext_m.get_many::<String>( "" ).unwrap().collect(); assert_eq! (external, "subcmd" ); assert_eq! (ext_args, [ "--option" , "value" , "-fff" , "--flag" ]);
    }, _ => {},
} source pub fn args_conflicts_with_subcommands (self, yes: bool ) -> Command Specifies that use of an argument prevents the use of subcommands . By default clap allows arguments between subcommands such
as <cmd> [cmd_args] <subcmd> [subcmd_args] <subsubcmd> [subsubcmd_args] . This setting disables that functionality and says that arguments can
only follow the final subcommand. For instance using this setting
makes only the following invocations possible: <cmd> <subcmd> <subsubcmd> [subsubcmd_args] <cmd> <subcmd> [subcmd_args] <cmd> [cmd_args] Â§ Examples Command::new( "myprog" )
    .args_conflicts_with_subcommands( true ); Examples found in repository ? examples/git.rs ( line 47 ) 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 fn cli() -> Command {
    Command::new( "git" )
        .about( "A fictional versioning CLI" )
        .subcommand_required( true )
        .arg_required_else_help( true )
        .allow_external_subcommands( true )
        .subcommand(
            Command::new( "clone" )
                .about( "Clones repos" )
                .arg( arg! (<REMOTE> "The remote to clone" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "diff" )
                .about( "Compare two commits" )
                .arg( arg! (base: [COMMIT]))
                .arg( arg! (head: [COMMIT]))
                .arg( arg! (path: [PATH]).last( true ))
                .arg( arg! (--color <WHEN>)
                        .value_parser([ "always" , "auto" , "never" ])
                        .num_args( 0 ..= 1 )
                        .require_equals( true )
                        .default_value( "auto" )
                        .default_missing_value( "always" ),
                ),
        )
        .subcommand(
            Command::new( "push" )
                .about( "pushes things" )
                .arg( arg! (<REMOTE> "The remote to target" ))
                .arg_required_else_help( true ),
        )
        .subcommand(
            Command::new( "add" )
                .about( "adds things" )
                .arg_required_else_help( true )
                .arg( arg! (<PATH> ... "Stuff to add" ).value_parser( clap::value_parser! (PathBuf))),
        )
        .subcommand(
            Command::new( "stash" )
                . args_conflicts_with_subcommands ( true )
                .flatten_help( true )
                .args(push_args())
                .subcommand(Command::new( "push" ).args(push_args()))
                .subcommand(Command::new( "pop" ).arg( arg! ([STASH])))
                .subcommand(Command::new( "apply" ).arg( arg! ([STASH]))),
        )
} source pub fn subcommand_precedence_over_arg (self, yes: bool ) -> Command Prevent subcommands from being consumed as an arguments value. By default, if an option taking multiple values is followed by a subcommand, the
subcommand will be parsed as another value. cmd --foo val1 val2 subcommand
          --------- ----------
            values   another value This setting instructs the parser to stop when encountering a subcommand instead of
greedily consuming arguments. cmd --foo val1 val2 subcommand
          --------- ----------
            values   subcommand Â§ Examples let cmd = Command::new( "cmd" ).subcommand(Command::new( "sub" )).arg(
    Arg::new( "arg" )
        .long( "arg" )
        .num_args( 1 ..)
        .action(ArgAction::Set),
); let matches = cmd
    .clone()
    .try_get_matches_from( & [ "cmd" , "--arg" , "1" , "2" , "3" , "sub" ])
    .unwrap(); assert_eq! (
    matches.get_many::<String>( "arg" ).unwrap().collect::<Vec< _ >>(), & [ "1" , "2" , "3" , "sub" ]
); assert! (matches.subcommand_matches( "sub" ).is_none()); let matches = cmd
    .subcommand_precedence_over_arg( true )
    .try_get_matches_from( & [ "cmd" , "--arg" , "1" , "2" , "3" , "sub" ])
    .unwrap(); assert_eq! (
    matches.get_many::<String>( "arg" ).unwrap().collect::<Vec< _ >>(), & [ "1" , "2" , "3" ]
); assert! (matches.subcommand_matches( "sub" ).is_some()); source pub fn subcommand_negates_reqs (self, yes: bool ) -> Command Allows subcommands to override all requirements of the parent command. For example, if you had a subcommand or top level application with a required argument
that is only required as long as there is no subcommand present,
using this setting would allow you to set those arguments to Arg::required(true) and yet receive no error so long as the user uses a valid subcommand instead. NOTE: This defaults to false (using subcommand does not negate requirements) Â§ Examples This first example shows that it is an error to not use a required argument let err = Command::new( "myprog" )
    .subcommand_negates_reqs( true )
    .arg(Arg::new( "opt" ).required( true ))
    .subcommand(Command::new( "test" ))
    .try_get_matches_from( vec! [ "myprog" ]); assert! (err.is_err()); assert_eq! (err.unwrap_err().kind(), ErrorKind::MissingRequiredArgument); This next example shows that it is no longer error to not use a required argument if a
valid subcommand is used. let noerr = Command::new( "myprog" )
    .subcommand_negates_reqs( true )
    .arg(Arg::new( "opt" ).required( true ))
    .subcommand(Command::new( "test" ))
    .try_get_matches_from( vec! [ "myprog" , "test" ]); assert! (noerr.is_ok()); source pub fn multicall (self, yes: bool ) -> Command Multiple-personality program dispatched on the binary name ( argv[0] ) A â€œmulticallâ€ executable is a single executable
that contains a variety of applets,
and decides which applet to run based on the name of the file.
The executable can be called from different names by creating hard links
or symbolic links to it. This is desirable for: Easy distribution, a single binary that can install hardlinks to access the different
personalities. Minimal binary size by sharing common code (e.g. standard library, clap) Custom shells or REPLs where there isnâ€™t a single top-level command Setting multicall will cause argv[0] to be stripped to the base name and parsed as the first argument, as if Command::no_binary_name was set. Help and errors to report subcommands as if they were the top-level command When the subcommand is not present, there are several strategies you may employ, depending
on your needs: Let the error percolate up normally Print a specialized error message using the Error::context Print the help but this might be ambiguous Disable multicall and re-parse it Disable multicall and re-parse it with a specific subcommand When detecting the error condition, the ErrorKind isnâ€™t sufficient as a sub-subcommand
might report the same error.  Enable allow_external_subcommands if you want to specifically
get the unrecognized binary name. NOTE: Multicall canâ€™t be used with no_binary_name since they interpret
the command name in incompatible ways. NOTE: The multicall command cannot have arguments. NOTE: Applets are slightly semantically different from subcommands,
so itâ€™s recommended to use Command::subcommand_help_heading and Command::subcommand_value_name to change the descriptive text as above. Â§ Examples hostname is an example of a multicall executable.
Both hostname and dnsdomainname are provided by the same executable
and which behaviour to use is based on the executable file name. This is desirable when the executable has a primary purpose
but there is related functionality that would be convenient to provide
and implement it to be in the same executable. The name of the cmd is essentially unused
and may be the same as the name of a subcommand. The names of the immediate subcommands of the Command
are matched against the basename of the first argument,
which is conventionally the path of the executable. This does not allow the subcommand to be passed as the first non-path argument. let mut cmd = Command::new( "hostname" )
    .multicall( true )
    .subcommand(Command::new( "hostname" ))
    .subcommand(Command::new( "dnsdomainname" )); let m = cmd.try_get_matches_from_mut( & [ "/usr/bin/hostname" , "dnsdomainname" ]); assert! (m.is_err()); assert_eq! (m.unwrap_err().kind(), ErrorKind::UnknownArgument); let m = cmd.get_matches_from( & [ "/usr/bin/dnsdomainname" ]); assert_eq! (m.subcommand_name(), Some ( "dnsdomainname" )); Busybox is another common example of a multicall executable
with a subcommmand for each applet that can be run directly,
e.g. with the cat applet being run by running busybox cat ,
or with cat as a link to the busybox binary. This is desirable when the launcher program has additional options
or it is useful to run the applet without installing a symlink
e.g. to test the applet without installing it
or there may already be a command of that name installed. To make an applet usable as both a multicall link and a subcommand
the subcommands must be defined both in the top-level Command
and as subcommands of the â€œmainâ€ applet. fn applet_commands() -> [Command; 2 ] {
    [Command::new( "true" ), Command::new( "false" )]
} let mut cmd = Command::new( "busybox" )
    .multicall( true )
    .subcommand(
        Command::new( "busybox" )
            .subcommand_value_name( "APPLET" )
            .subcommand_help_heading( "APPLETS" )
            .subcommands(applet_commands()),
    )
    .subcommands(applet_commands()); // When called from the executable's canonical name
// its applets can be matched as subcommands. let m = cmd.try_get_matches_from_mut( & [ "/usr/bin/busybox" , "true" ]).unwrap(); assert_eq! (m.subcommand_name(), Some ( "busybox" )); assert_eq! (m.subcommand().unwrap(). 1 .subcommand_name(), Some ( "true" )); // When called from a link named after an applet that applet is matched. let m = cmd.get_matches_from( & [ "/usr/bin/true" ]); assert_eq! (m.subcommand_name(), Some ( "true" )); Examples found in repository ? examples/multicall-hostname.rs ( line 5 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        . multicall ( true )
        .arg_required_else_help( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .subcommand(Command::new( "hostname" ).about( "show hostname part of FQDN" ))
        .subcommand(Command::new( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} More examples Hide additional examples examples/repl.rs ( line 65 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        . multicall ( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/multicall-busybox.rs ( line 15 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        . multicall ( true )
        .subcommand(
            Command::new( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} source pub fn subcommand_value_name (
    self,
    value_name: impl IntoResettable < Str >,
) -> Command Sets the value name used for subcommands when printing usage and help. By default, this is â€œCOMMANDâ€. See also Command::subcommand_help_heading Â§ Examples Command::new( "myprog" )
    .subcommand(Command::new( "sub1" ))
    .print_help() will produce myprog

Usage: myprog [COMMAND]

Commands:
    help    Print this message or the help of the given subcommand(s)
    sub1

Options:
    -h, --help       Print help
    -V, --version    Print version but usage of subcommand_value_name Command::new( "myprog" )
    .subcommand(Command::new( "sub1" ))
    .subcommand_value_name( "THING" )
    .print_help() will produce myprog

Usage: myprog [THING]

Commands:
    help    Print this message or the help of the given subcommand(s)
    sub1

Options:
    -h, --help       Print help
    -V, --version    Print version Examples found in repository ? examples/multicall-hostname.rs ( line 7 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .arg_required_else_help( true )
        . subcommand_value_name ( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .subcommand(Command::new( "hostname" ).about( "show hostname part of FQDN" ))
        .subcommand(Command::new( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} More examples Hide additional examples examples/repl.rs ( line 68 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        . subcommand_value_name ( "APPLET" )
        .subcommand_help_heading( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/multicall-busybox.rs ( line 19 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand(
            Command::new( "busybox" )
                .arg_required_else_help( true )
                . subcommand_value_name ( "APPLET" )
                .subcommand_help_heading( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} source pub fn subcommand_help_heading (
    self,
    heading: impl IntoResettable < Str >,
) -> Command Sets the help heading used for subcommands when printing usage and help. By default, this is â€œCommandsâ€. See also Command::subcommand_value_name Â§ Examples Command::new( "myprog" )
    .subcommand(Command::new( "sub1" ))
    .print_help() will produce myprog

Usage: myprog [COMMAND]

Commands:
    help    Print this message or the help of the given subcommand(s)
    sub1

Options:
    -h, --help       Print help
    -V, --version    Print version but usage of subcommand_help_heading Command::new( "myprog" )
    .subcommand(Command::new( "sub1" ))
    .subcommand_help_heading( "Things" )
    .print_help() will produce myprog

Usage: myprog [COMMAND]

Things:
    help    Print this message or the help of the given subcommand(s)
    sub1

Options:
    -h, --help       Print help
    -V, --version    Print version Examples found in repository ? examples/multicall-hostname.rs ( line 8 ) 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_value_name( "APPLET" )
        . subcommand_help_heading ( "APPLETS" )
        .subcommand(Command::new( "hostname" ).about( "show hostname part of FQDN" ))
        .subcommand(Command::new( "dnsdomainname" ).about( "show domain name part of FQDN" )); match cmd.get_matches().subcommand_name() { Some ( "hostname" ) => println! ( "www" ), Some ( "dnsdomainname" ) => println! ( "example.com" ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} More examples Hide additional examples examples/repl.rs ( line 69 ) 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 fn cli() -> Command { // strip out usage const PARSER_TEMPLATE: & str = "\
        {all-args}
    " ; // strip out name/version const APPLET_TEMPLATE: & str = "\
        {about-with-newline}\n\
        {usage-heading}\n    {usage}\n\
        \n\
        {all-args}{after-help}\
    " ;

    Command::new( "repl" )
        .multicall( true )
        .arg_required_else_help( true )
        .subcommand_required( true )
        .subcommand_value_name( "APPLET" )
        . subcommand_help_heading ( "APPLETS" )
        .help_template(PARSER_TEMPLATE)
        .subcommand(
            Command::new( "ping" )
                .about( "Get a response" )
                .help_template(APPLET_TEMPLATE),
        )
        .subcommand(
            Command::new( "quit" )
                .alias( "exit" )
                .about( "Quit the REPL" )
                .help_template(APPLET_TEMPLATE),
        )
} examples/multicall-busybox.rs ( line 20 ) 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 fn main() { let cmd = Command::new( env! ( "CARGO_CRATE_NAME" ))
        .multicall( true )
        .subcommand(
            Command::new( "busybox" )
                .arg_required_else_help( true )
                .subcommand_value_name( "APPLET" )
                . subcommand_help_heading ( "APPLETS" )
                .arg(
                    Arg::new( "install" )
                        .long( "install" )
                        .help( "Install hardlinks for all subcommands in path" )
                        .exclusive( true )
                        .action(ArgAction::Set)
                        .default_missing_value( "/usr/local/bin" )
                        .value_parser( value_parser! (PathBuf)),
                )
                .subcommands(applet_commands()),
        )
        .subcommands(applet_commands()); let matches = cmd.get_matches(); let mut subcommand = matches.subcommand(); if let Some (( "busybox" , cmd)) = subcommand { if cmd.contains_id( "install" ) { unimplemented! ( "Make hardlinks to the executable here" );
        }
        subcommand = cmd.subcommand();
    } match subcommand { Some (( "false" , _ )) => exit( 1 ), Some (( "true" , _ )) => exit( 0 ), _ => unreachable! ( "parser should ensure only valid subcommand names are used" ),
    }
} source Â§ impl Command Â§ Reflection source pub fn get_display_name (&self) -> Option <& str > Get the name of the binary. source pub fn get_bin_name (&self) -> Option <& str > Get the name of the binary. source pub fn set_bin_name (&mut self, name: impl Into < String >) Set binary name. Uses &mut self instead of self . source pub fn get_name (&self) -> & str Get the name of the cmd. source pub fn get_name_and_visible_aliases (&self) -> Vec <& str > Get all known names of the cmd (i.e. primary name and visible aliases). source pub fn get_version (&self) -> Option <& str > Get the version of the cmd. source pub fn get_long_version (&self) -> Option <& str > Get the long version of the cmd. source pub fn get_display_order (&self) -> usize Get the placement within help source pub fn get_author (&self) -> Option <& str > Get the authors of the cmd. source pub fn get_short_flag (&self) -> Option < char > Get the short flag of the subcommand. source pub fn get_long_flag (&self) -> Option <& str > Get the long flag of the subcommand. source pub fn get_about (&self) -> Option <& StyledStr > Get the help message specified via Command::about . source pub fn get_long_about (&self) -> Option <& StyledStr > Get the help message specified via Command::long_about . source pub fn is_flatten_help_set (&self) -> bool Get the custom section heading specified via Command::flatten_help . source pub fn get_next_help_heading (&self) -> Option <& str > Get the custom section heading specified via Command::next_help_heading . source pub fn get_visible_aliases (&self) -> impl Iterator <Item = & str > Iterate through the visible aliases for this subcommand. source pub fn get_visible_short_flag_aliases (&self) -> impl Iterator <Item = char > Iterate through the visible short aliases for this subcommand. source pub fn get_visible_long_flag_aliases (&self) -> impl Iterator <Item = & str > Iterate through the visible long aliases for this subcommand. source pub fn get_all_aliases (&self) -> impl Iterator <Item = & str > Iterate through the set of all the aliases for this subcommand, both visible and hidden. source pub fn get_all_short_flag_aliases (&self) -> impl Iterator <Item = char > Iterate through the set of all the short aliases for this subcommand, both visible and hidden. source pub fn get_all_long_flag_aliases (&self) -> impl Iterator <Item = & str > Iterate through the set of all the long aliases for this subcommand, both visible and hidden. source pub fn get_aliases (&self) -> impl Iterator <Item = & str > Iterate through the hidden aliases for this subcommand. source pub fn get_color (&self) -> ColorChoice Should we color the output? source pub fn get_styles (&self) -> & Styles Return the current Styles for the Command source pub fn get_subcommands (&self) -> impl Iterator <Item = & Command > Iterate through the set of subcommands, getting a reference to each. source pub fn get_subcommands_mut (&mut self) -> impl Iterator <Item = &mut Command > Iterate through the set of subcommands, getting a mutable reference to each. source pub fn has_subcommands (&self) -> bool Returns true if this Command has subcommands. source pub fn get_subcommand_help_heading (&self) -> Option <& str > Returns the help heading for listing subcommands. source pub fn get_subcommand_value_name (&self) -> Option <& str > Returns the subcommand value name. source pub fn get_before_help (&self) -> Option <& StyledStr > Returns the help heading for listing subcommands. source pub fn get_before_long_help (&self) -> Option <& StyledStr > Returns the help heading for listing subcommands. source pub fn get_after_help (&self) -> Option <& StyledStr > Returns the help heading for listing subcommands. source pub fn get_after_long_help (&self) -> Option <& StyledStr > Returns the help heading for listing subcommands. source pub fn find_subcommand (&self, name: impl AsRef < OsStr >) -> Option <& Command > Find subcommand such that its name or one of aliases equals name . This does not recurse through subcommands of subcommands. source pub fn find_subcommand_mut (
    &mut self,
    name: impl AsRef < OsStr >,
) -> Option <&mut Command > Find subcommand such that its name or one of aliases equals name , returning
a mutable reference to the subcommand. This does not recurse through subcommands of subcommands. source pub fn get_groups (&self) -> impl Iterator <Item = & ArgGroup > Iterate through the set of groups. source pub fn get_arguments (&self) -> impl Iterator <Item = & Arg > Iterate through the set of arguments. source pub fn get_positionals (&self) -> impl Iterator <Item = & Arg > Iterate through the positionals arguments. source pub fn get_opts (&self) -> impl Iterator <Item = & Arg > Iterate through the options . source pub fn get_arg_conflicts_with (&self, arg: & Arg ) -> Vec <& Arg > Get a list of all arguments the given argument conflicts with. If the provided argument is declared as global, the conflicts will be determined
based on the propagation rules of global arguments. Â§ Panics If the given arg contains a conflict with an argument that is unknown to
this Command . source pub fn is_no_binary_name_set (&self) -> bool Report whether Command::no_binary_name is set source pub fn is_dont_delimit_trailing_values_set (&self) -> bool Report whether Command::dont_delimit_trailing_values is set source pub fn is_disable_version_flag_set (&self) -> bool Report whether Command::disable_version_flag is set source pub fn is_propagate_version_set (&self) -> bool Report whether Command::propagate_version is set source pub fn is_next_line_help_set (&self) -> bool Report whether Command::next_line_help is set source pub fn is_disable_help_flag_set (&self) -> bool Report whether Command::disable_help_flag is set source pub fn is_disable_help_subcommand_set (&self) -> bool Report whether Command::disable_help_subcommand is set source pub fn is_disable_colored_help_set (&self) -> bool Report whether Command::disable_colored_help is set source pub fn is_arg_required_else_help_set (&self) -> bool Report whether Command::arg_required_else_help is set source pub fn is_allow_missing_positional_set (&self) -> bool Report whether Command::allow_missing_positional is set source pub fn is_hide_set (&self) -> bool Report whether Command::hide is set source pub fn is_subcommand_required_set (&self) -> bool Report whether Command::subcommand_required is set source pub fn is_allow_external_subcommands_set (&self) -> bool Report whether Command::allow_external_subcommands is set source pub fn get_external_subcommand_value_parser (&self) -> Option <& ValueParser > Configured parser for values passed to an external subcommand Â§ Example let cmd = clap::Command::new( "raw" )
    .external_subcommand_value_parser( clap::value_parser! (String)); let value_parser = cmd.get_external_subcommand_value_parser(); println! ( "{value_parser:?}" ); source pub fn is_args_conflicts_with_subcommands_set (&self) -> bool Report whether Command::args_conflicts_with_subcommands is set source pub fn is_subcommand_precedence_over_arg_set (&self) -> bool Report whether Command::subcommand_precedence_over_arg is set source pub fn is_subcommand_negates_reqs_set (&self) -> bool Report whether Command::subcommand_negates_reqs is set source pub fn is_multicall_set (&self) -> bool Report whether Command::multicall is set source Â§ impl Command source pub fn build (&mut self) Prepare for introspecting on all included Command s Call this on the top-level Command when done building and before reading state for
cases like completions, custom help output, etc. Trait Implementations Â§ source Â§ impl Clone for Command source Â§ fn clone (&self) -> Command Returns a copy of the value. Read more 1.6.0 Â· source Â§ fn clone_from (&mut self, source: &Self) Performs copy-assignment from source . Read more source Â§ impl Debug for Command source Â§ fn fmt (&self, f: &mut Formatter <'_>) -> Result < () , Error > Formats the value using the given formatter. Read more source Â§ impl Default for Command source Â§ fn default () -> Command Returns the â€œdefault valueâ€ for a type. Read more source Â§ impl Display for Command source Â§ fn fmt (&self, f: &mut Formatter <'_>) -> Result < () , Error > Formats the value using the given formatter. Read more source Â§ impl From <& Command > for Command source Â§ fn from (cmd: & Command ) -> Command Converts to this type from the input type. source Â§ impl Index <& Id > for Command source Â§ type Output = Arg The returned type after indexing. source Â§ fn index (&self, key: & Id ) -> &< Command as Index <& Id >>:: Output Performs the indexing ( container[index] ) operation. Read more Auto Trait Implementations Â§ Â§ impl Freeze for Command Â§ impl ! RefUnwindSafe for Command Â§ impl Send for Command Â§ impl Sync for Command Â§ impl Unpin for Command Â§ impl ! UnwindSafe for Command Blanket Implementations Â§ source Â§ impl<T> Any for T where
    T: 'static + ? Sized , source Â§ fn type_id (&self) -> TypeId Gets the TypeId of self . Read more source Â§ impl<T> Borrow <T> for T where
    T: ? Sized , source Â§ fn borrow (&self) -> &T Immutably borrows from an owned value. Read more source Â§ impl<T> BorrowMut <T> for T where
    T: ? Sized , source Â§ fn borrow_mut (&mut self) -> &mut T Mutably borrows from an owned value. Read more source Â§ impl<T> CloneToUninit for T where
    T: Clone , source Â§ unsafe fn clone_to_uninit (&self, dst: *mut T ) ðŸ”¬ This is a nightly-only experimental API. ( clone_to_uninit ) Performs copy-assignment from self to dst . Read more source Â§ impl<T> From <T> for T source Â§ fn from (t: T) -> T Returns the argument unchanged. source Â§ impl<T, U> Into <U> for T where
    U: From <T>, source Â§ fn into (self) -> U Calls U::from(self) . That is, this conversion is whatever the implementation of From <T> for U chooses to do. source Â§ impl<T> ToOwned for T where
    T: Clone , source Â§ type Owned = T The resulting type after obtaining ownership. source Â§ fn to_owned (&self) -> T Creates owned data from borrowed data, usually by cloning. Read more source Â§ fn clone_into (&self, target: &mut T ) Uses borrowed data to replace owned data, usually by cloning. Read more source Â§ impl<T> ToString for T where
    T: Display + ? Sized , source Â§ default fn to_string (&self) -> String Converts the given value to a String . Read more source Â§ impl<T, U> TryFrom <U> for T where
    U: Into <T>, source Â§ type Error = Infallible The type returned in the event of a conversion error. source Â§ fn try_from (value: U) -> Result <T, <T as TryFrom <U>>:: Error > Performs the conversion. source Â§ impl<T, U> TryInto <U> for T where
    U: TryFrom <T>, source Â§ type Error = <U as TryFrom <T>>:: Error The type returned in the event of a conversion error. source Â§ fn try_into (self) -> Result <U, <U as TryFrom <T>>:: Error > Performs the conversion.
======>
https://docs.rs/clap/latest/clap/trait.ValueEnum.html
-->>-->>

======>
https://docs.rs/clap/latest/clap/_derive/_cookbook/repl_derive/index.html
-->>-->>
use std::io::Write; use clap::{Parser, Subcommand}; fn main() -> Result <(), String> { loop { let line = readline() ? ; let line = line.trim(); if line.is_empty() { continue ;
        } match respond(line) { Ok (quit) => { if quit { break ;
                }
            } Err (err) => { write! (std::io::stdout(), "{err}" ).map_err(|e| e.to_string()) ? ;
                std::io::stdout().flush().map_err(|e| e.to_string()) ? ;
            }
        }
    } Ok (())
} fn respond(line: & str) -> Result <bool, String> { let args = shlex::split(line).ok_or( "error: Invalid quoting" ) ? ; let cli = Cli::try_parse_from(args).map_err(|e| e.to_string()) ? ; match cli.command {
        Commands::Ping => { write! (std::io::stdout(), "Pong" ).map_err(|e| e.to_string()) ? ;
            std::io::stdout().flush().map_err(|e| e.to_string()) ? ;
        }
        Commands::Exit => { write! (std::io::stdout(), "Exiting ..." ).map_err(|e| e.to_string()) ? ;
            std::io::stdout().flush().map_err(|e| e.to_string()) ? ; return Ok ( true );
        }
    } Ok ( false )
} #[derive(Debug, Parser)]
#[command(multicall = true )] struct Cli { #[command(subcommand)] command: Commands,
} #[derive(Debug, Subcommand)] enum Commands {
    Ping,
    Exit,
} fn readline() -> Result <String, String> { write! (std::io::stdout(), "$ " ).map_err(|e| e.to_string()) ? ;
    std::io::stdout().flush().map_err(|e| e.to_string()) ? ; let mut buffer = String::new();
    std::io::stdin()
        .read_line( &mut buffer)
        .map_err(|e| e.to_string()) ? ; Ok (buffer)
}
======>
https://github.com/clap-rs/clap
-->>-->>

======>
https://www.youtube.com/watch?v=MMZUAtHbTYY
-->>-->>
Komorebi v0.1.29+ Quickstart WinGet Tutorial (LATEST!) | Windows 11 Tiling Window Manager Search Watch later Share Copy link Info Shopping Tap to unmute 2x If playback doesn't begin shortly, try restarting your device. â€¢ You're signed out Videos you watch may be added to the TV's watch history and influence TV recommendations. To avoid this, cancel and sign in to YouTube on your computer. Cancel Confirm Up next Live Upcoming Cancel Play Now Share Include playlist An error occurred while retrieving sharing information. Please try again later. 0:00 0:00 / 18:55 â€¢ Watch full video Live â€¢ â€¢ Scroll for details
======>
https://www.youtube.com/watch?v=eH4FSAD3dYs
-->>-->>
komorebi v0.1.29 overview - status bar, themes, scrolling workspaces, hot-loading configurations 23 Likes 130 Views 4h Ago â€¢Â KomorebiÂ TilingÂ WindowÂ ManagerÂ Tutorials â€¢Â KomorebiÂ TilingÂ WindowÂ ManagerÂ Develo... https://github.com/LGUG2Z/komorebi/re... Tip on Ko-fi: https://ko-fi.com/lgug2z Sponsor on GitHub: https://github.com/LGUG2Z/komorebi Socials: https://linktree.lgug2z.com Subscribe to my RSS feeds: https://notado.app/feeds/jado Join the Discord: /Â discord Komorebi is an free tiling window manager for Windows: https://github.com/LGUG2Z/komorebi Show less ...more â€¢Â KomorebiÂ TilingÂ WindowÂ ManagerÂ Tutorials â€¢Â KomorebiÂ TilingÂ WindowÂ ManagerÂ Develo... https://github.com/LGUG2Z/komorebi/re... Tip on Ko-fi: https://ko-fi.com/lgug2z Sponsor on GitHub: https://github.com/LGUG2Z/komorebi Socials: https://linktree.lgug2z.com Subscribe to my RSS feeds: https://notado.app/feeds/jado Join the Discord: /Â discord Komorebi is an free tiling window manager for Windows: https://github.com/LGUG2Z/komorebi â€¦ ...more ...more Show less Music 1 songs Wish You'd Never Left TrackTribe Wish You'd Never Left Music Transcript Follow along using the transcript. Show transcript Jeezy Codes 2.31K subscribers Videos About Videos About
======>
https://github.com/LGUG2Z/komorebi/releases/tag/v0.1.29
-->>-->>
Releases v0.1.29 v0.1.29 Latest Latest Compare Choose a tag to compare Could not load tags Nothing to show {{ refName }} default Loading View all tags github-actions released this 28 Sep 01:54 Â· 11 commits to master
          since this release v0.1.29 818ac34 v0.1.29 (2024-09-27) - Beirut Bug Fixes wm : add layout edge index awareness ( 21bd09e4 ) wm : cross-border focus direction awareness ( c3f13570 ) bar : use truncated labels for titles ( 3720ce42 ) wm : cross-border move direction awareness ( 1080159e ) bar : read mouse follows focus from state ( 6addfed1 ) bar : use custom windows-icons w/o panics ( 254fcc98 ) wm : hot reload cross boundary behaviour changes ( 7005a01d ) bar : fmt battery percentage without decimals ( 286bb007 ) wm : grow monitors vec to accomodate idx prefs ( c06d9afa ) animation : enable cross-monitor animations ( 3c035287 ) wm : socket cleanup on exit ( 821a1247 ) wm : exclude minimized hwnds from show event ( 13e2cbc7 ) wm : mouse resize on right and bottom edges ( ff653e78 ) cli : correct cycle-layout prev/next seq ( 6d038b8b ) borders : maximize compat w/ komorebi impl ( b5eafc6b ) wm : apply window based offsets to monocles ( c3679673 ) transparency : handle multi-monitor monocles ( 780635c8 ) animation : disable on cross-monitor drag ( 6ea71834 ) Code Refactoring deps : unify versions across workspace pkgs ( 360d0915 ) bar : change panics to error logs ( df409902 ) wm : reduce process_event log noise ( 8f7b9202 ) client : use public interface exclusively ( 81451cb1 ) Features bar : add quickstart flag, remove yaml format ( 109227b7 ) bar : expand komorebi layout subwidget ( 01ccf70a ) bar : expand focused window subwidget ( 182c1e6a ) bar : add font size config opt ( 14d2ebd7 ) cli : generate json schemas locally ( df19d063 ) cli : update enable-autostart cmd for bar ( 96d094d9 ) wm : add replace configuration socket message ( 2916256e ) bar : hotloading for viewport inner_size ( de3d4d0d ) themes : update bar on komorebi.json reload ( b69db863 ) themes : add + integrate komorebi-themes lib ( 45894be4 ) bar : add komorebi-bar ( bc67936d ) wm : add cross boundary behaviour options ( b799fd30 ) cli : add focus-stack-window cmd ( f722905b ) cli : add toggle-transparency cmd ( 0f9c23b6 ) Documentation mkdocs : generate latest cli docs ( d6ae81af ) privacy : add privacy policy ( d110e12a ) mkdocs : add komorebi-bar to getting started ( 21a21383 ) license : fork polyform strict to explicitly allow changes ( 6ba0ba79 ) Chore release : v0.1.29 ( 818ac340 ) deps : bump windows-rs from 0.57 to 0.58 ( ddb600f7 ) deps : bump windows-rs from 0.54 to 0.57 ( 167ec928 ) deps : cargo update ( 50b89cc1 ) deps : bump regex from 1.10.5 to 1.10.6 ( 45a59418 ) deps : bump clap from 4.5.9 to 4.5.13 ( f54097f0 ) deps : bump dunce from 1.0.4 to 1.0.5 ( 29b14f8d ) deps : bump which from 6.0.1 to 6.0.2 ( a1cf5ba2 ) deps : bump serde_json from 1.0.120 to 1.0.122 ( a60e5a77 ) deps : bump openssl from 0.10.64 to 0.10.66 ( d5bec7af ) deps : bump thiserror from 1.0.62 to 1.0.63 ( 974aa0d0 ) dev : begin v0.1.29-dev ( 7653495e ) Assets 5 Loading 6 mort65, Aaqil101, Mickychen00, azinsharaf, 0xjairo, and justraven reacted with thumbs up emoji 10 ClixTW, JiangpengLI86, Lucho32-byte, codyduong, obolenski, CtByte, Mickychen00, 0xjairo, justraven, and thearturca reacted with hooray emoji 1 xidsyed reacted with heart emoji All reactions 6 reactions 10 reactions 1 reaction 14 people reacted
======>
https://old.reddit.com/r/rust/comments/1eqjcc5/building_a_status_bar_with_egui/
-->>-->>

======>
https://github.com/shelbyJenkins/llm_client
-->>-->>
Repository files navigation README MIT license The Easiest Rust Interface for Local LLMs # For Mac (CPU and GPU), windows (CPU and CUDA), or linux (CPU and CUDA) llm_client = " * " This will download and build llama.cpp . See build.md for other features and backends like mistral.rs. use Llmclient :: prelude :: * ; // Loads the largest quant available based on your VRAM or system memory let llm_client = LlmClient :: llama_cpp ( ) . mistral7b_instruct_v0_3 ( ) // Uses a preset model . init ( ) // Downloads model from hugging face and starts the inference interface . await ? ; Several of the most common models are available as presets. Loading from local models is also fully supported. See models.md for more information. Features Automated build and support for CPU, CUDA, MacOS Easy model presets and quant selection Novel cascading prompt workflow for CoT and NLP workflows. DIY workflow creation supported! Breadth of configuration options (sampler params, retry logic, prompt caching, logit bias, grammars, etc) API support for OpenAI, Anthropic, Perplexity, and any OpenAI compatible API An Interface for Deterministic Signals from Probabilistic LLM Vibes In addition to basic LLM inference, llm_client is primarily designed for controlled generation using step based cascade workflows. This prompting system runs pre-defined workflows that control and constrain both the overall structure of generation and individual tokens during inference. This allows the implementation of specialized workflows for specific tasks, shaping LLM outputs towards intended, reproducible outcomes. let response : u32 = llm_client . reason ( ) . integer ( ) . instructions ( ) . set_content ( "Sally (a girl) has 3 brothers. Each brother has 2 sisters. How many sisters does Sally have?" ) . return_primitive ( ) . await ? ; // Recieve 'primitive' outputs assert_eq ! ( response, 1 ) This runs the reason one round cascading prompt workflow with an integer output. This method significantly improves the reliability of LLM use cases. For example, there are test cases this repo that can be used to benchmark an LLM. There is a large increase in accuracy when comparing basic inference with a constrained outcome and a CoT style cascading prompt workflow . The decision workflow that runs N count of CoT workflows across a tempature gradient approaches 100% accuracy for the test cases. I have a full breakdown of this in my blog post, " Step-Based Cascading Prompts: Deterministic Signals from the LLM Vibe Space ." Jump to the readme.md of the llm_client crate to find out how to use them. Examples device config - customizing your inference config basic completion - the most basic request available basic primitive - returns the request primitive reason - a cascade workflow that performs CoT reasoning before returning a primitive decision - uses the reason workflow N times across a temperature gradient extract urls - a cascade workflow that extracts all URLs from text that meet a predict Docs llm_client readme.md docs directory Guides Limiting power in Nvidia GPUs Blog Posts Step-Based Cascading Prompts: Deterministic Signals from the LLM Vibe Space Roadmap Improve the Cascading workflow API to be easier. Refactor the benchmarks module for easy model comparison. WebUI client for local consumption. Server mode for "LLM-in-a-box" deployments Full Rust inference via mistral.rs or candle . Dependencies llm_utils is a sibling crate that was split from the llm_client. If you just need prompting, tokenization, model loading, etc, I suggest using the llm_utils crate on it's own. llm_interface is a sub-crate of llm_client. It is the backend for LLM inference. llm_devices is a sub-crate of llm_client. It contains device and build managment behavior. llama.cpp is used in server mode for LLM inference as the current default. mistral.rs is available for basic use, but is a WIP. Contact Shelby Jenkins - Here or Linkedin
======>
https://crates.io/crates/llm_client
-->>-->>

======>
https://github.com/alexpasmantier/grip-grab
-->>-->>
Repository files navigation README Unlicense license grip-grab ( gg ) ðŸ§¤ A fast, more lightweight ripgrep alternative for daily use cases. â¯ gg " \b(Read|Write)Half[^<] " tokio/src grip-grab.mp4 Installation Using Cargo cargo install grip-grab NOTE: if using zsh with the git plugin, you might need to unalias gg in order for grip-grab's gg to work: echo ' unalias gg ' >> ~ /.zshrc source ~ /.zshrc Benchmarks The general idea With default settings for both tools, gg will typically be faster than rg on small to moderatly sized codebases (<= a couple milion lines) running on everyday machines because of its default thread heuristic. rg will typically be faster out of the box on larger corpora (think a checkout of the linux kernel) and machines with more logical cpus. Note that you still can tweak gg with the -T argument to achieve similar performance in those cases. The following discussion with ripgrep's author on HackerNews might also provide more insights regarding this tool's performance (including more benchmarks across different machines and corpora). NOTE : The following benchmarks were run on an M3 Macbook Pro with 16GB of RAM and 8 logical CPUs. The curl codebase (approx. half a milion lines) https://github.com/curl/curl hyperfine -m 200 " gg '[A-Z]+_NOBODY' . " " rg '[A-Z]+_NOBODY' . " " ggrep -rE '[A-Z]+_NOBODY' . " Benchmark 1: gg '[A-Z]+_NOBODY' .
  Time (mean Â± Ïƒ):      18.5 ms Â±   0.7 ms    [User: 10.5 ms, System: 47.9 ms]
  Range (min â€¦ max):    17.0 ms â€¦  19.9 ms    200 runs

Benchmark 2: rg '[A-Z]+_NOBODY' .
  Time (mean Â± Ïƒ):      37.0 ms Â±   4.6 ms    [User: 15.1 ms, System: 201.0 ms]
  Range (min â€¦ max):    23.3 ms â€¦  60.5 ms    200 runs

Benchmark 3: ggrep -rE '[A-Z]+_NOBODY' .
  Time (mean Â± Ïƒ):      68.5 ms Â±   0.6 ms    [User: 27.2 ms, System: 40.4 ms]
  Range (min â€¦ max):    64.6 ms â€¦  70.4 ms    200 runs

Summary
  gg '[A-Z]+_NOBODY' . ran
    2.00 Â± 0.26 times faster than rg '[A-Z]+_NOBODY' .
    3.71 Â± 0.14 times faster than ggrep -rE '[A-Z]+_NOBODY' . Plaintext searches hyperfine -m 100 " gg 'test' " " rg 'test' " " ggrep -rE 'test' " Benchmark 1: gg 'test'
  Time (mean Â± Ïƒ):      22.3 ms Â±   1.1 ms    [User: 16.5 ms, System: 51.0 ms]
  Range (min â€¦ max):    20.4 ms â€¦  27.7 ms    100 runs

Benchmark 2: rg 'test'
  Time (mean Â± Ïƒ):      49.7 ms Â±   2.7 ms    [User: 23.4 ms, System: 298.3 ms]
  Range (min â€¦ max):    42.0 ms â€¦  55.5 ms    100 runs

Benchmark 3: ggrep -rE 'test'
  Time (mean Â± Ïƒ):      52.3 ms Â±   0.9 ms    [User: 14.6 ms, System: 37.0 ms]
  Range (min â€¦ max):    50.1 ms â€¦  56.9 ms    100 runs

Summary
  gg 'test' ran
    2.23 Â± 0.16 times faster than rg 'test'
    2.34 Â± 0.12 times faster than ggrep -rE 'test' The tokio codebase (approx. 160k lines) https://github.com/tokio-rs/tokio hyperfine -m 200 " gg 'in<\w, W>' " " rg 'in<\w, W>' " " ggrep -r 'in<[[:alnum:]], W>' " Benchmark 1: gg 'in<\w, W>'
  Time (mean Â± Ïƒ):       7.4 ms Â±   0.7 ms    [User: 4.5 ms, System: 6.8 ms]
  Range (min â€¦ max):     6.0 ms â€¦  10.3 ms    208 runs

Benchmark 2: rg 'in<\w, W>'
  Time (mean Â± Ïƒ):       8.8 ms Â±   0.8 ms    [User: 5.9 ms, System: 16.5 ms]
  Range (min â€¦ max):     6.7 ms â€¦  10.7 ms    200 runs

Benchmark 3: ggrep -r 'in<[[:alnum:]], W>'
  Time (mean Â± Ïƒ):     118.3 ms Â±   2.1 ms    [User: 100.8 ms, System: 16.5 ms]
  Range (min â€¦ max):   114.3 ms â€¦ 127.4 ms    200 runs

Summary
  gg 'in<\w, W>' ran
    1.19 Â± 0.15 times faster than rg 'in<\w, W>'
   15.92 Â± 1.54 times faster than ggrep -r 'in<[[:alnum:]], W>' Plaintext searches These typically take <5ms on the tokio repository which is too low to benchmark with a tool like hyperfine. The neovim codebase (approx. 1.3 milion lines) https://github.com/neovim/neovim hyperfine --warmup 100 " gg '[a-z]+_buf\b' " " rg '[a-z]+_buf\b' " " ggrep -rE '[a-z]+_buf\b' " Benchmark 1: gg '[a-z]+_buf\b'
  Time (mean Â± Ïƒ):      19.0 ms Â±   1.2 ms    [User: 12.4 ms, System: 54.4 ms]
  Range (min â€¦ max):    16.8 ms â€¦  22.6 ms    113 runs

Benchmark 2: rg '[a-z]+_buf\b'
  Time (mean Â± Ïƒ):      36.0 ms Â±   4.9 ms    [User: 14.8 ms, System: 200.5 ms]
  Range (min â€¦ max):    23.9 ms â€¦  46.2 ms    75 runs

Benchmark 3: ggrep -rE '[a-z]+_buf\b'
  Time (mean Â± Ïƒ):      75.7 ms Â±   0.9 ms    [User: 36.3 ms, System: 39.4 ms]
  Range (min â€¦ max):    74.1 ms â€¦  78.1 ms    36 runs

Summary
  gg '[a-z]+_buf\b' ran
    1.89 Â± 0.29 times faster than rg '[a-z]+_buf\b'
    3.99 Â± 0.26 times faster than ggrep -rE '[a-z]+_buf\b' Plaintext searches hyperfine --warmup 100 -m 100 " gg 'test' " " rg 'test' " " ggrep -rE 'test' " Benchmark 1: gg 'test'
  Time (mean Â± Ïƒ):      21.0 ms Â±   0.8 ms    [User: 15.3 ms, System: 48.1 ms]
  Range (min â€¦ max):    18.9 ms â€¦  23.2 ms    114 runs

Benchmark 2: rg 'test'
  Time (mean Â± Ïƒ):      42.4 ms Â±   3.6 ms    [User: 19.5 ms, System: 253.3 ms]
  Range (min â€¦ max):    34.9 ms â€¦  63.4 ms    100 runs

Benchmark 3: ggrep -rE 'test'
  Time (mean Â± Ïƒ):      65.3 ms Â±   1.6 ms    [User: 27.8 ms, System: 36.7 ms]
  Range (min â€¦ max):    63.2 ms â€¦  78.4 ms    100 runs

Summary
  gg 'test' ran
    2.02 Â± 0.19 times faster than rg 'test'
    3.11 Â± 0.15 times faster than ggrep -rE 'test' Usage â¯ gg --help A faster, more lightweight ripgrep alternative for day to day usecases.

Usage: gg [OPTIONS] [PATTERN] [PATHS]... [COMMAND]

Commands:
  upgrade  Upgrade the crate to its latest version
  help     Print this message or the help of the given subcommand(s)

Arguments:
  [PATTERN]   a regex pattern to search for
  [PATHS]...  path in which to search recursively

Options:
  -e, --patterns <PATTERNS>
          you can specify multiple patterns using -e "pattern1" -e "pattern2" etc
  -I, --ignore-paths <IGNORE_PATHS>
          paths to ignore when recursively walking target directory
  -G, --disregard-gitignore
          disregard .gitignore rules when recursively walking directory (defaults to false)
  -T, --n-threads <N_THREADS>
          number of threads to use [default: 4]
  -U, --multiline
          enable multiline matching
      --json
          output in JSON format
  -f, --file-paths-only
          output file paths only
  -A, --absolute-paths
          output absolute paths (defaults to relative)
  -C, --disable-colored-output
          disable colored output (colored by default)
  -t, --filter-filetypes <FILTER_FILETYPES>
          filter on filetype (defaults to all filetypes)
  -H, --disable-hyperlinks
          disable hyperlinks in output (defaults to false)
  -D, --disable-devicons
          disable devicons in output (defaults to false)
  -h, --help
          Print help
  -V, --version
          Print version Upgrading gg You may upgrade gg to its latest version by running: gg upgrade Upgrade the crate to its latest version

Usage: gg upgrade [OPTIONS]

Options:
  -f, --force  Optional flag for force upgrade
  -h, --help   Print help gg_upgrade.mp4 Examples Basic usage â¯ gg " \b(Read|Write)Half[^<] " tokio/src JSON output â¯ gg --json unsplit tokio/src | jq Filenames only â¯ gg -f " \b(Read|Write)Half[^<] " tokio/src Notes This lightweight utility is largely based on a couple of crates from the extraordinary ripgrep tool.
Its aim is to provide a minimal and lightweight version that can be easily integrated in other programs for search-related purproses.
======>
https://preview.redd.it/jgyg7eadsqsd1.png?width=4916&format=png&auto=webp&s=1e6acd8fc913ff5d58b322e80bb6d6e3d1babbac
-->>-->>

======>
https://old.reddit.com/r/rust/comments/1fvr8u1/why_this_code_snippet_violates_miri/
-->>-->>
I am writing a    An Ok Unsafe Queue    following    Too Many List   . I learn the stacked borrows but still not quite understand why these code snippet violates miri.   

   pub fn push(&mut self, elem: T) {
    let mut new_tail = Box::new(Node { elem, next: None });

    let raw_tail: *mut _ = &mut *new_tail;

    if !self.tail.is_null() {
        // Non-empty queue
        // This line violates stacked borrow, and can't satisfy miri's check.
        // But WHY?
        unsafe {
            (*self.tail).next = Some(new_tail);
        }
    } else {
        // Empty queue
        self.head = Some(new_tail);
    }

    self.tail = raw_tail;
}
   

   I know under miri's rule, I should not modify    new_tail   's value by variable other than    raw_tail   . But is these modification on    new_tail    in unsafe code? Why the line    self.head = Some(new_tail)    doesn't violate miri?   

   Here    is the code.   
   

======>
https://flawless.dev/docs/
-->>-->>
Introduction to durable execution Flawless is a durable execution engine for Rust. But what is durable execution actually? The easiest way to think about durable execution is as code that runs until completion ,
even in the presence of external failure . The external failure part is very
important. Rust as a language already pushes developers to explicitly handle errors. Almost every
API touching the operating system can fail and returns a Result , letting the
developer decide what should happen in that case. This is great! But there are some
failure scenarios that we can't handle directly from code. For example, if the
process executing the code is shut down. Can't if-else a kill -9 . That's what I like to
call an external failure . Flawless gives us tools to deal with such failures directly
from code. Let's look at some code and see how external failures can affect your system! // extend_subscription.rs fn extend_subscription ( user : User) { // 1. Charge user's credit card. let transaction = stripe_api::charge_card(user. card ()); // 2. Send invoice to user. let invoice = generate_invoice (user, transaction); loops_api::send_invoice(user. email (), invoice); // 3. Extend subscription. subscription_service::extend(user. id (), Month::new( 1 )); } This is a fairly straight forward function. It charges the credit card of a user, sends
an invoice to the same user and extends their subscription. And in the majority of cases
it will work just fine. However, there are a few cases where it might fail, or even worse, leave the system in an inconsistent state. One such case would be if the VM is restarted by an administrator to apply a security
update. Right at the moment when this function is executing! Maybe the credit card was
charged, but the code to extend the subscription was never called. Resulting in a very
upset customer. The most obvious way to protect against such scenarios is to create some kind of state
machine and persist it to a database/queue. So next time the app is started up again, it
knows exactly how far it got and can continue. Of course, this is not enough. Failures can come at the most inconvenient of times. What
happens if we persisted that an HTTP call to the Stripe API is about to be called, but
don't know if it finished. Is it safe to continue executing and repeating the call? Is
the user going to be charged twice? Idempotence and retry safety are other
topics that we need to care about. At this point we are developing a very sophisticated
state machine, with complex resume rules. Flawless takes this burden away from us. It allows us to just
write business logic instead, and gives us tools to deal with such failures directly from
the code. Similar to how a database abstracts away all the little quirks of the file-system API and
gives the developer a robust way to store their data, durable execution does the same for
running code. It allows you to resume the execution from any arbitrary point and gives you
tools to correctly model retries. How does it work? The most naive way of implementing a durable execution system would be to snapshot the
whole thing. Stack, heap and registers. After every instruction! This would also be a very inefficient and resource intensive task. Flawless takes a much
leaner approach. It uses the fact that modern CPUs are very fast , and usually a much
cheaper resource than memory, storage or networking. In the case of failure, it will
re-execute the code from the beginning, but only the deterministic parts of it. Everything that has a side effect, like HTTP calls, is executed only once and the result
of the operation persisted to a log file. The log turns side effects into deterministic
executions, if we ever need to re-execute the function. The following animation demonstrates this visually. workflow.rs Ã— restarting ... side effect log > 63 64 let user = "Adele Goldberg" ; deterministic 65 let comic_id : u32 = flawless::rand::random() ; side effect 66 let url = format!( "https://xkcd.com/{comic_id}/" ) ; deterministic 67 let content = flawless_http::get( url ).send() ; side effect 68 let quote = parse_comic( content ) ; deterministic 69 let greeting = format!( "Hi {user}! //
            '{quote}'" ) deterministic 70 Error: Execution Interrupted! Machine unexpectedly rebooted. Execution Completed! ... recv msg {...} HTTP request send msg {...} get clock time _ _ _ > â–“â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â–ˆ Only the minimal amount of data is preserved to disk and everything else is recalculated
on demand. Flawless also uses WebAssembly as the compilation target, to guarantee
determinism across operating systems and CPU architectures. You can start a workflow on
one machine and finish it on another. But from the perspective of an outside observer, it
seems as if the code just executes from start to finish. Only the side effects, that are
guaranteed to execute once, can be observed from the outside. Flawless uses this log mechanism to hook back into the code. This allows us to
programmatically handle external failures. Let's look at the following example. let result = flawless_http::post( "https://takes-a-long-time.com" ) . body (form) . send (); If we have a service that takes a very long time to respond to our HTTP request, it could
happen that an external failure happens while we are still waiting for the response.
Flawless uses a double commit system to detect if we actually got a response when
re-running some side effect. If this is not the case, the call will return an error of
kind ErrorKind::RequestInterrupted . With this, we are bringing
external failures back into our code. If we know that it's safe to retry the request, we can just signalize this directly from
the code. let result = flawless_http::post( "https://takes-a-long-time.com" ) . body (form) . idempotent () . send (); Now, Flawless will always retry the code, even if it failed mid-request. Use cases Once you have this guarantee, that a piece of code will run until the end, even if
temporarily interrupted, the abstractions you can build on top of it are much more
interesting. Let's look at two of them, long-running workflows and transactional behavior. Long-running workflows The longer something is executing, the more likely it is that it will fail in the middle
of the execution, and the harder it becomes to manually construct a state machine to
resume from an arbitrary point. That's where durable execution shines. Functions that need to run for months, years or even forever, are a valid pattern when it
comes to durable execution. Throwing in a casual sleep(1 year) into your business logic
is not a big deal, because we can completely shut off this one "thread" for a year. We
already have the means to resume it from any point. During this period it will
use 0 CPU and 0 memory resources. Transactional behavior You have probably heard of database transactions. They ensure that all database operations
inside a transaction are successfully performed, or none get executed. Leaving the system
in a consistent state. But what do you do when your operations are spread across different
microservices, external APIs or different databases? You can't have a transaction start in
PostgreSQL and finish in MySQL. Durable execution lets you build such a system using the Saga pattern . If you can
guarantee that all steps of a transaction or the reverting logic (in case of failure)
are going to be executed, it becomes "trivial" to build very robust transactional systems. There are many other patterns that can be built on top of durable execution. In the end,
durable execution is just code, so almost anything can be expressed with it. Wondering if it would be a good solution for your use case? Join the Flawless discord and tell us more about it! Ready to try it out? Flawless is a single binary that you run as a server and send your workflows to. If you
would like to try Flawless, check out the installation instructions .
======>
https://old.reddit.com/r/rust/comments/1fwc3n0/im_having_trouble_getting_into_it/
-->>-->>
Hi so Iâ€™ve been trying to learn rust for the past 3 months or so coming from high-level languages like Typescript, Python etcâ€¦   

   Iâ€™m still pretty young so I have a lot of time, but itâ€™s kinda de-motivating me to learn because there are a lot of concepts, like memory management, pointers, and other terms I donâ€™t remember that are very abstract to me.   

   What should I do? Iâ€™m really interested in learning but thereâ€™s some obstacles in the wayâ€¦   
   

======>
https://old.reddit.com/r/rust/comments/1fw5ij0/quickbuilder_010_a_compiletime_verified_builder/
-->>-->>
Announcing    quick-builder   : a compile-time verified builder that also allows enforcing run-time invariants.    

   Try it on crates:    https://crates.io/crates/quick-builder   

   Short Overview   

   If you want to derive a builder pattern that both forces you to initialize all fields at compile time and also allows you to enforce run-time invariants, you might be interested in my    quick-builder    crate. Here's an example that's hopefully rather self explanatory:   

   ```rust   

   derive(QuickBuilder)]   

   [invariant(|my| my.width * my.height == my.data.len())]   

   struct ImageRef<'a, T> {
    #[invariant(|w|*w>0)]
    width: usize,
    #[invariant(check_height)]
    height: usize,
    data: &'a [T],
}   

   // if the conditions to check invariants are too
// unwieldy to put into a closure, you can also
// define a standalone function.
fn check_height(height :&usize) -> bool {
  *height > 0 && *height % 2 == 0
}   

   fn main() {
    let image_data = &[1, 2, 3, 4, 5, 6];
    let imgref = ImageRef::builder()
        .width(3)
        .height(2)
        .data(image_data)
        .build();
}
```   

   Limitations and Alternatives   

   I've written a    section in the docs    about alternatives. In short: my crate fills a niche between existing compile-time verified builders (which are great) and purely run-time verified builders (which are also great). It is (as of yet) not as nearly as flexible as those, but it serves people who want things that are detectable at compile time to be detected at compile time and also allow enforcing run-time invariants. It's well tested and documented, so I'm happy for people to give it a go and let me know.   

   Feedback Request   

   If you can see yourself using this crate, I'm happy to gather your feedback because I'd like to get some ideas for how to evolve how the builder communicates broken invariants. Right now it returns an    Option<T>   , but there are many other ways of skinning this cat and I'd like to hear what people think.   
   

======>
https://old.reddit.com/r/rust/comments/1fw463d/ygen_now_supports_phi/
-->>-->>
Hi,   

   In my    last post    (yesterday) i released ygen 0.1.2.   

   Today i added the    phi    ir node which is a big milestone in the development of ygen.   

   Why is the phi node so important?   

   The `phi` node is used very much.   

   Let's say for example this rust code:   

   fn example(a: i32) -> i32 {
   let b = if a == 0 {
        5 
   } else { a };

   return b;
}
   

   When optimizations are turned on it would compile to this (i think):   

   define i32 (i32 %a) {
  %1 = icmp eq i32 %a, 0
  br i1 %1, label %cond.yes, label %cond.no

cond.yes:
  %5 = add i32 5, 0
  br label %cond.resume

cond.no: 
  br label %cond.resume

cond.resume:
  %out = phi i32 [%5, %cond.yes], [%a, %cond.no]
  ret i32 %out
}
   

   NOTE: it wouldn't output above code (it would use the       select       instruction)   

   Instead of:   

   define i32 (i32 %a) {
  %b = alloca i32
  %2 = icmp eq i32 %a, 0
  br i1 %2, label %cond.yes, label %cond.no

cond.yes:
  store i32 5, ptr %b
  br label %cond.resume

cond.no: 
  store i32 %a, ptr %b
  br label %cond.resume

cond.resume:
  %out= load i32, ptr %b
  ret i32 %out
}
   

   Do you see the difference?   

   The one with the phi is shorter and doesn't use stack variables.   

   -> Less stack variables means (in most cases) more performant   

   What does it mean to ygen?   

   The addition of the    phi    node to ygen means that it is now possible to write an optimization pass (in llvm it is called:    mem2reg   ) which optimizes these    store   ,    loads    into a    phi   

   
   I hope I explained everything correctly.   
If I made any errors please correct me   
   

   GitHub-Link:    https://github.com/Cr0a3/ygen   

   Have a nice day   

   Cr0a3   
   

======>
https://old.reddit.com/r/rust/comments/1fwgihn/using_clap_for_entirely_the_wrong_purpose/
-->>-->>
Hi,   

   As the title suggests, I'm using the    clap    crate for something it's entirely not supposed to be used for. Long story short, I am trying to set up a REPL (which it    can    be used for   , though that's not super important) that parses commands that are multiple words and do not contain flags (   -f    and    --flag   ).   

   Here are are some example commands that I would like to parse:   

   
   toggle <FEATURE NAME> [ on | off ]   

   login name <USER NAME> key <digits>   

   setup [ init | position <POSITION STRING> ]   

   apply <STRING1> [STRING2 ... STRINGN]   
   

   For simple commands, like    toggle <FEATURE> [ on | off ]    I have been able to get this to work by using some features like    ValueEnum   . And, for the more complicated commands like    setup [ init | position <STRING> ]    I have been able to get a mock-up to work by nesting    sub commands   .   

   However, what I cannot figure out is how to get clap to parse a command whose argument is a single word. For example, I can parse    toggle Debug on    just fine. but I can't parse    toggle Debug Info on   .   

   I would like to know if anyone has worked with Clap enough to know of a solution to this.   
   

======>
https://blessed.rs/crates
-->>-->>
Sections Tooling Common General Error Handling Logging Language Extensions System Math / Scientific FFI / Interop Cryptography Networking Async Foundations HTTP Websockets gRPC Databases SQL Databases Other Databases Utilities CLIs Argument Parsing Utility Terminal Rendering Concurrency Data Structures Graphics GUI Game Development window.addEventListener('DOMContentLoaded', () => {

    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        const id = entry.target.getAttribute('id');
        if (entry.intersectionRatio > 0) {
          document.querySelector(`li[data-toc-link="${id}"]`).classList.add('active');
        } else {
          document.querySelector(`li[data-toc-link="${id}"]`).classList.remove('active');
        }
      });
    });

    // Track all sections that have an `id` applied
    document.querySelectorAll('section[data-toc-section]').forEach((section) => {
      observer.observe(section);
    });
    
  }); What is blessed.rs? The standard library in Rust is much smaller than in Python or Go, for example. Those
      languages come with "batteries included" support for things like HTTP(S), JSON, timezones,
      random numbers, and async IO. Rust, on the other hand, gets things like that from the crates.io ecosystem and the Cargo package manager. But with
      almost 100Â thousand crates to choose from, a common complaint from new Rust developers is
      that they don't know where to start, which crates they ought to use, and which crates they
      ought to trust. This list attempts to answer those questions. See also lib.rs which takes a more automated approach (ordering crates by number of downloads) and also has an excellent search function. Tooling Developer tools for working with Rust projects. Use Case Recommended Crates Toolchain Management rustup Install, manage, and upgrade versions of rustc, cargo, clippy, rustfmt and more. Linting clippy The official Rust linter. cargo-semver-checks Lint your crate releases for semantic versioning violations. Code Formatting rustfmt The official Rust code formatter. Cross Compilation cross Seamless cross-compiling using Docker containers. cargo-zigbuild Easily cross-compile using Zig as the linker. Managing Dependencies cargo-edit Adds 'cargo upgrade' and 'cargo set-version' commands to cargo cargo-outdated Finds dependencies that have available updates cargo-audit Check dependencies for reported security vulnerabilities cargo-license Lists licenses of all dependencies cargo-deny Enforce policies on your code and dependencies. Testing cargo-nextest Faster, better test runner insta Snapshot testing with inline snapshot support Benchmarking criterion [docs] Statistically accurate benchmarking tool for benchmarking libraries divan [docs] Simple yet powerful benchmarking library with allocation profiling hyperfine Tool for benchmarking compiled binaries (similar to unix time command but better) Performance cargo-flamegraph Execution flamegraph generation dhat [docs] Heap memory profiling cargo-show-asm [docs] Print the generated assembly for a Rust function Debugging Macros Rust Analyzer also allows you to expand macros directly in your editor cargo-expand Allows you to inspect the code that macros expand to Release Automation cargo-release Helper for publishing new crate versions. Release-plz Release Rust crates from CI with a Release PR. Continuous Integration rust-toolchain (github action) Github action to install Rust components via rustup rust-cache (github action) Github action to cache compilation artifacts and speed up subsequent runs. install-action (github action GitHub Action for installing development tools (mainly from GitHub Releases). Common Very commonly used crates that everyone should know about General General purpose Use Case Recommended Crates Random numbers rand [docs] De facto standard random number generation library split out from the standard library Time & Date Unfortunately there is no clear answer as to which is best between time and chrono. Evaluate for yourself between these two, but be resassured that both are trusted and well-maintained. time [docs] A smaller, simpler library. Preferrable if covers your needs, but it's quite limited in what it provides. chrono [docs] The most comprehensive and full-featured datetime library, but more complex because of it. Serialization (JSON, YAML, etc) See here for supported formats. serde [docs] De facto standard serialization library. Use in conjunction with sub-crates like serde_json for the specific format that you are using. Regular Expressions regex [docs] De facto standard regex library. Very fast, but does not support fancier features such as backtracking. fancy-regex [docs] Use if need features such as backtracking which regex doesn't support UUIDs uuid [docs] Implements generating and parsing UUIDs and a number of utility functions Temporary files tempfile [docs] Supports both temporary files and temporary directories Gzip (de)compression flate2 [docs] Uses a pure-Rust implementation by default. Use feature flags to opt in to system zlib. Insertion-ordered map indexmap [docs] A HashMap that seperately keeps track of insertion order and allows you to efficiently iterate over its elements in that order Stack-allocated arrays arrayvec [docs] Arrays that are ONLY stack-allocated with fixed capacity smallvec [docs] Arrays that are stack-allocated with fallback to the heap if the fixed stack capacity is exceeded tinyvec [docs] Stack allocated arrays in 100% safe Rust code but requires items to implement the Default trait. HTTP Requests See the HTTP section below for server-side libraries reqwest [docs] Full-fat HTTP client. Can be used in both synchronous and asynchronous code. Requires tokio runtime. ureq [docs] Minimal synchronous HTTP client focussed on simplicity and minimising dependencies. Error Handling Crates for more easily handling errors Use Case Recommended Crates For applications anyhow [docs] Provides a boxed error type that can hold any error, and helpers for generating an application-level stack trace. color-eyre [docs] A fork of anyhow that gives you more control over the format of the generated error messages. Recommended if you intend to present error messages to end users. Otherwise anyhow is simpler. For libraries See also: Designing error types in Rust thiserror [docs] Helps with generating boilerplate for enum-style error types. Logging Crates for logging. Note that in general you will need a seperate crate for actually printing/storing the logs Use Case Recommended Crates Text-based logging tracing [docs] Tracing is now the go-to crate for logging. log [docs] An older and simpler crate if your needs are simple and you are not using any async code. Structured logging tracing [docs] Tracing is now the go-to crate for logging. slog [docs] Structured logging Language Extensions General purpose utility crates that extend language and/or stdlib functionality. Use Case Recommended Crates Lazy static variable initialization The core functionality of once_cell is now included in the standard library with the remaining parts on track to be stabilised in future. once_cell [docs] Newer crate with more ergonomic API. Should be preferred for all new projects. lazy_static [docs] Older crate. API is less convenient, but crate is stable and maintained. Iterator helpers itertools [docs] A bunch of useful methods on iterators that aren't in the stdlib Macro helpers syn [docs] Parse rust source code quote [docs] Quasi quoting rust (useful for interpolating generated code with literal code) paste [docs] Concatenating and manipulating identifiers Safe type casts bytemuck [docs] zerocopy [docs] Bitflags bitflags [docs] Strongly typed bitflag types System For low-level interaction with the underling platform / operating system Use Case Recommended Crates Memory mapping files memmap2 [docs] The older memmap crate is unmaintained. Libc libc [docs] Bindings for directly calling libc functions. Windows (OS) windows [docs] The official Microsoft-provided crate for interacting with windows APIs winapi [docs] Older binding to the windows APIs. Unofficial, but more complete than windows-rs *nix (OSs) nix [docs] Bindings to the various *nix system functions. (Unix, Linux, MacOS, etc.) Math / Scientific The num crate is trusted and has a variety of numerical functionality that is missing from the standard library. Use Case Recommended Crates Abstracting over different number types num-traits [docs] Traits like Number, Add, etc that allow you write functions that are generic over the specific numeric type Big Integers num-bigint [docs] It's not the fastest, but it's part of the trusted num library. rug [docs] LGPL licensed. Wrapper for GMP. Much faster than num-bigint. Big Decimals rust_decimal [docs] The binary representation consists of a 96 bit integer number, a scaling factor used to specify the decimal fraction and a 1 bit sign. Sortable Floats ordered-float [docs] Float types that don't allow NaN and are therefore orderable. You can also use the total_cmp method from the standard library like .sort_by(|a, b| a.total_cmp(&b)) . Linear Algebra nalgebra [docs] General-purpose linear algebra library with transformations and statically-sized or dynamically-sized matrices. However it supports only vectors (1d) and matrices (2d) and not higher-dimensional tensors. ndarray [docs] Less featureful than nalgebra but supports arbitrarily dimensioned arrays DataFrames polars [docs] Similar to the Pandas library in Python but in pure Rust. Uses the Apache Arrow Columnar Format as the memory model. datafusion [docs] Apache DataFusion is an in-memory query engine that uses Apache Arrow as the memory model FFI / Interop Crates that allow Rust to interact with code written in other languages. Use Case Recommended Crates C bindgen [docs] Generate Rust bindings to C libraries cbindgen [docs] Generate C bindings to Rust libraries C++ cxx [docs] Safe C++ <-> Rust interop by generating code for both sides. Python pyo3 [docs] Supports both calling python code from Rust and exposing Rust code to Python Node.js napi [docs] is a framework for building pre-compiled Node.js addons in Rust. neon [docs] Slower than napi, but also widely used and well-maintained Ruby rutie [docs] Supports both embedding Rust into Ruby applications and embedding Ruby into Rust applications Objective-C objc [docs] Interop with the Objective-C runtime Java/JVM jni [docs] Implement Java methods for JVM and Android in Rust. Call Java code from Rust. Embed JVM in Rust applications. Lua mlua [docs] Bindings to Lua 5.4, 5.3, 5.2, 5.1 (including LuaJIT) Dart/Flutter flutter_rust_bridge [docs] Works with Dart with or without Flutter Erlang/Elixir rustler [docs] Safe Rust bridge for creating Erlang NIF functions Kotlin/Swift/Python/Ruby uniffi [docs] Share Rust codebase to create cross-platform apps (also 3rd party support for Kotlin Multiplatform, Go, C#, Dart) Cryptography Crates that provide implementations of cryptographic algorithms. This section attempts to list the best crates for the listed algorithms, but does not intend to make recommendations for the algorithms themselves. Use Case Recommended Crates Password Hashing For more algorithms, see Rust Crypto Password Hashes . argon2 [docs] scrypt [docs] bcrypt [docs] General Purpose Hashing For more algorithms, see Rust Crypto Hashes . sha2 [docs] sha1 [docs] md-5 [docs] AEAD Encryption For more algorithms, see Rust Crypto AEADs . aes-gcm-siv [docs] aes-gcm [docs] chacha20poly1305 [docs] RSA rsa [docs] Digital Signatures For more algorithms, see Rust Crypto Signatures . ed25519 [docs] Use in conjunction with the ed25519-dalek crate. ecdsa [docs] dsa [docs] Certificate Formats For more formats, see Rust Crypto Formats . der [docs] pem-rfc7468 [docs] pkcs8 [docs] x509-cert [docs] TLS / SSL rustls [docs] A portable pure-rust high-level implementation of TLS. Implements TLS 1.2 and higher. native-tls [docs] Delegates to the system TLS implementations on windows and macOS, and uses OpenSSL on linux. See also (click to open) webpki [docs] X.509 Certificate validation. Builds on top of ring. ring [docs] Fork of BoringSSL. Provides low-level cryptographic primitives for TLS/SSL Utilities subtle [docs] Utilities for writing constant-time algorithms zeroize [docs] Securely erase memory Networking TCP, HTTP, GRPc, etc. And the executors required to do asynchronous networking. Async Foundations To do async programming using the async-await in Rust you need a runtime to execute drive your Futures. Use Case Recommended Crates General Purpose Async Executors tokio [docs] The oldest async runtime in the Rust ecosystem and still the most widely supported. Recommended for new projects. futures-executor [docs] A minimal executor. In particular, the block_on function is useful if you want to run an async function synchronously in codebase that is mostly synchronous. See also (click to open) async-std [docs] A newer option that is very similar to tokio. Its API more closely mirrors the std library, but it doesn't have as much traction or ecosystem support as Tokio. Async Utilities futures [docs] Utility functions for working with Futures and Streams async-trait [docs] Provides a workaround for the lack of language support for async functions in traits io_uring glommio [docs] Use if you need io_uring support. Still somewhat experimental but rapidly maturing. HTTP HTTP client and server libraries, as well as lower-level building blocks. Use Case Recommended Crates Types & Interfaces http [docs] The `http` crate doesn't actually contain an HTTP implementation. Just types and interfaces to help interoperability. Low-level HTTP Implementation hyper [docs] A low-level HTTP implementation (both client and server). Implements HTTP/1, and HTTP/2. Works best with the tokio async runtime, but can support other runtimes. HTTP Client reqwest [docs] Full-fat HTTP client. Can be used in both synchronous and asynchronous code. Requires tokio runtime. ureq [docs] Minimal synchronous HTTP client focussed on simplicity and minimising dependencies. See also (click to open) surf [docs] Client that uses the async-std runtime rather than the tokio runtime. Not well maintained. HTTP Server axum [docs] A minimal and ergonomic framework. An official part of the tokio project. Recommend for most new projects. actix-web [docs] A performance focussed framework. All Rust frameworks are fast, but choose actix-web if you need the absolutely maximum performance. See also (click to open) rocket [docs] Has an excellent API and a solid implementation. However development has been intermittent. poem [docs] Automatically generates OpenAPI definitions. warp [docs] Very similar to axum but with a quirkier API. This is a solid framework, but you should probably prefer Axum unless you particularly like the API tide [docs] Similar to Axum, but based on async-std rather than tokio GraphQL Server async-graphql [docs] A high-performance graphql server library that's fully specification compliant. Integrates with actix-web, axum, poem, rocket, tide, warp. Websockets This section includes libraries for you to use just websockets. However note that many of the HTTP server frameworks in the section above also support websockets Use Case Recommended Crates Low-level tungstenite [docs] Low-level crate that others build on General Purpose tokio-tungstenite [docs] If you are using the tokio executor async-tungstenite [docs] If you are using the async-std executor gRPC Use Case Recommended Crates General Purpose tonic [docs] gRPC over HTTP/2 with full support for asynchronous code. Works with tokio Databases SQL Databases The multi-database options (SQLx and Diesel) are generally quite good, and worth considering even if you only need support for a single database. Use Case Recommended Crates Multi Database sqlx [docs] Works with Postgres, MySQL, SQLite, and MS SQL. Supports compile time checking of queries. Async: supports both tokio and async-std. ORMs diesel [docs] Has excellent performance and takes an approach of strict compile time guarantees. The main crate is Sync only, but diesel-async provides an async connection implementation. sea-orm [docs] Built on top of sqlx (see above). There is also a related sea-query crate that provides a query builder without full ORM functionality. Postgres tokio-postgres [docs] Postgres-specific library. Performs better than SQLx MySQL mysql_async [docs] Has a poorly designed API. Prefer SQLx or Diesel for MySQL SQLite rusqlite [docs] Provides a sync API to SQLite + provides access to advanced sqlite features. MS SQL tiberius [docs] MS SQL specific library. Has better support for advanced column types than SQLx. Oracle diesel-oci [docs] Diesel backend and connection implementation for oracle databases oracle [docs] Rust bindings to ODPI-C Other Databases Use Case Recommended Crates Redis redis [docs] MongoDB mongodb [docs] ElasticSearch elasticsearch [docs] LMDB The rkv crate depends on the lmdb-rkv dependency which is archived and is inactive. heed [docs] A fully typed LMDB wrapper with minimum overhead. Rocks DB rocksdb [docs] Cassandra cassandra-protocol [docs] Low-level Cassandra protocol implementation. cdrs-tokio [docs] High-level async Cassandra driver. Utilities Use Case Recommended Crates Connection pool deadpool [docs] A dead simple async pool for connections and objects of any type. CLIs Argument Parsing See argparse-benchmarks-rs for a full comparison of the crates mentioned here and more. Use Case Recommended Crates Fully-featured clap [docs] Ergonomic, battle-tested, includes the kitchen sink, and is fast at runtime. However compile times can be slow See also (click to open) bpaf [docs] Faster compile times than clap while still being featureful. But still has some rough edges, and the API can be confusing at times. Minimal lexopt [docs] Fast compile times, fast runtime, pedantic about correctness. API is less ergonomic pico-args [docs] Fast compile times, fast runtime, more lax about correctness. API is more ergonomic Utility Helpers that are often useful when implementing CLIs Use Case Recommended Crates Globbing globset High-performance globbing that allows multiple globs to be evaluated at once Directory walking walkdir Basic recursive filesystem walking. ignore Recursive filesystem walking that respects ignore files (like .gitignore) File watching notify [docs] Watch files or directories and execute a function when they change Terminal Rendering For fancy terminal rendering and TUIs. The crates recommended here work cross-platform (including windows). Use Case Recommended Crates Coloured Output termcolor [docs] Cross-platform terminal colour output Progress indicators indicatif [docs] Progress bars and spinners TUI ratatui [docs] A high-level TUI library with widgets, layout, etc. crossterm [docs] Low-level cross-platform terminal rendering and event handling Interactive prompts inquire [docs] Ask for confirmation, selection, text input and more Concurrency Data Structures Use Case Recommended Crates Mutex parking_lot [docs] std::sync::Mutex also works fine. But Parking Lot is faster. Atomic pointer swapping arc-swap [docs] Useful for sharing data that has many readers but few writers Concurrent HashMap See conc-map-bench for comparative benchmarks of concurrent HashMaps. dashmap [docs] The fastest for general purpose workloads flurry [docs] Particularly good for read-heavy workloads. Channels See communicating-between-sync-and-async-code for notes on when to use async-specific channels vs general purpose channels. crossbeam-channel [docs] The absolute fastest channel implementation available. Implements Go-like 'select' feature. flume [docs] Smaller and simpler than crossbeam-channel and almost as fast tokio [docs] Tokio's sync module provides channels for using in async code postage [docs] Channels that integrate nicely with async code, with different options than Tokio Parallel computation rayon [docs] Convert sequential computation into parallel computation with one call - `par_iter` instead of `iter` Graphics GUI Use Case Recommended Crates GTK gtk4 [docs] Rust bindings to GTK4. These are quite well supported, although you'll often need to use the C documentation. relm4 [docs] A higher-level library that sits on top of gtk4-rs Web-based GUI tauri [docs] Electron-like web-based UI. Except it uses system webviews rather than shipping chromium, and non-UI code is written in Rust rather than node.js dioxus [docs] A very nice API layer that has Tauri, Web, and TUI renderers. A native renderer is coming soon. Immediate Mode Native GUI egui [docs] Immediate-mode UI. Lots of widgets. The most useable out of the box if your needs are simple and you don't need to customise of the look and feel Retained Mode Native GUI iced [docs] Retained mode UI with a nice API. It's useable for basic apps, but has a number of missing features including multiple windows, layers, and proper text rendering. floem Inspired by Xilem, Leptos and rui, floem is currently more complete than any of them for native UI. Used by the Lapce text editor. vizia Fairly complete with sophisticated layout and text layout, but has yet to make a stable release. See also (click to open) xilem The replacement for Druid based on the more interoperable Vello and Glazier crates. However, it's currently not complete enough to be usable. freya Dioxus-based GUI framework using Skia for rendering. slint [docs] Possibly the most complete rust-native UI library. But note that it's dual GPL3/commercial licensed. druid [docs] Druid is a relatively mature alternative to Iced/Slint, however it has been discontinued in favour of Xilem so it's use for new projects is discouraged. gpui High performance framework used in the Zed text editor. Currently macOS only. makepad Makepad has a strong focus on performance and minimising bloat but is consequently less feature complete in areas such as accessibility and system integration. ribir cushy [docs] rui [docs] concoct [docs] kas [docs] Window creation winit [docs] The defacto standard option. Uses an event loop based architecture. Widely used and should probably be the default choice. tao [docs] A fork of winit by the Tauri project which adds support for things like system menus that desktop apps need. glazier A new competitor to winit based on the old druid-shell. Has a callback that may be better than the event loop architecture for some tasks. Doesn't yet have a stable release. baseview Specialized window creation library targetting windows to be embedded in other applications (e.g. DAW plugins) 2D Renderers femtovg [docs] OpenGL based. Offers a simple API. Probably the easiest to get started with. skia-safe [docs] Bindings to the Skia C++ library. The most complete option with excellent performance. However, it can be difficult to get it to compile. vello WGPU based and uses cutting edge techniques to render vector paths using the GPU. Still somewhat immature and hasn't yet put out a stable release. vger [docs] A simpler WGPU based option which is less innovative but currently more stable than vello. webrender [docs] OpenGL based. Mature with production usage in Firefox but documentation and OSS maintenance are lacking. UI layout taffy [docs] Supports Flexbox and CSS Grid algorithms. morphorm [docs] Implements it's own layout algorithm based on Subform layout Text layout cosmic-text [docs] Full text layout including rich text and support for BiDi and non-latin scripts. The best option for now. parley Another very accomplished text layout library used by Druid/Xilem. Accessibility accesskit [docs] Allows you to export a semantic tree representing your UI to make accessible to screen readers and other assistive technologies Clipboard arboard [docs] A fork of rust-clipboard that supports copy and pasting of both text and images on Linux (X11/Wayland), MacOS and Windows. File Dialogs rfd [docs] Platform-native open/save file dialogs. Can be used in conjunction with other UI libraries. Game Development Use Case Recommended Crates Game Engines bevy [docs] An ECS based game engine, good for 3D but also capable of 2D. fyrox [docs] An OOP-focused game engine with 3D and 2D support and a full GUI scene editor. ggez [docs] A simpler option for 2d games only. macroquad [docs] A simple and easy to use 2d game library, great for beginners. 3D Math glam [docs] Fast math library optimised for game development use cases
======>
https://www.youtube.com/watch?v=sf8ac2NtwPY
-->>-->>
Performing Impossible Feats with Isograph - Robert Balicki, Pinterest 10 Likes 267 Views Sep 17 2024 Performing Impossible Feats with Isograph

Today's web developers are asked to do the impossible. Fetch just the data needed for a given page, no more and no less, while avoiding network waterfalls. Splitting network requests so that users can see high priority content faster, without fetching the same field twice. Loading the minimal JavaScript. Ensuring that their apps show the latest data, without excessively re-rendering. Ensuring content is garbage collected, but not disposing of resources still in use. Yeesh! And all the while, they're asked to maintain this performance profile while other developers make changes willy nilly. Sounds impossible, and it is! With other frameworks, that is. Find out how Isograph makes all of this easy â€” and more! Isograph is a framework for building React apps powered by GraphQL data. See https://isograph.dev for more!

GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools. Get Started Here: https://graphql.org/ Show less ...more Performing Impossible Feats with Isograph

Today's web developers are asked to do the impossible. Fetch just the data needed for a given page, no more and no less, while avoiding network waterfalls. Splitting network requests so that users can see high priority content faster, without fetching the same field twice. Loading the minimal JavaScript. Ensuring that their apps show the latest data, without excessively re-rendering. Ensuring content is garbage collected, but not disposing of resources still in use. Yeesh! And all the while, they're asked to maintain this performance profile while other developers make changes willy nilly. Sounds impossible, and it is! With other frameworks, that is. Find out how Isograph makes all of this easy â€” and more! Isograph is a framework for building React apps powered by GraphQL data. See https://isograph.dev for more!

GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools. Get Started Here: https://graphql.org/ â€¦ ...more ...more Show less Transcript Follow along using the transcript. Show transcript GraphQL Foundation 1.08K subscribers Videos About Videos About
======>
https://old.reddit.com/r/rust/comments/1fwdge9/komorebi_v0129_status_bar_written_in_egui/
-->>-->>
Hi friends,   

   You may recall a post I made a little while ago about    building a status bar with egui    and documenting the process in a development video series.   

   Well, the status bar has now been released as part of    komorebi v0.1.29   !   

   If you're interested in seeing what a status bar written in egui can look like (custom fonts, hot-reloading, custom themes etc.), there is a deep dive into the bar and the configuration system here:    https://www.youtube.com/watch?v=eH4FSAD3dYs   

   If you're interested in trying it out, there is also a    quickstart video    which will get you up and running in less than 5 minutes.   
   

======>
https://github.com/Byron/gitoxide/discussions/1614
-->>-->>
Discussion options {{title}} Something went wrong. Quote reply Byron Oct 4, 2024 Maintainer Original comment in English - Translate to English This month was quite incredible in terms of features, but particularly so in terms of community. Merge Base support There are now various functions related to computing the merge-base of two or more commits, which an API that excells when multiple calls for queries on the same commit-graph are made. The idea is that the commit-graph is used as cache so future queries will be able to re-use at least some parts of it. It's notable that git2 already does that implicitly and thus also performs very well in comparison, which if you think about it is really nice. gix , however, prefers to make the usage of caches explicit so they can be dropped easily, while making clear that memory usage will grow here. The feature was sponsored by GitButler which can perform a lot of merge-base queries in a row - now it does that ever so slightly faster, but also can do so more easily in threads. Thanks to this implementation, listing branches and obtaining branch details is now fully driven by gix , and at least twice as fast as certain inter-dependent operations can now run in parallel. Tree Editing To support the upcoming tree-merge feature, high-performance tree-editing was implemented. As it supports cursors as well, I'd hope that performance will never be an issue for it. Cursors can be placed as sub-trees, allowing edit operations to start at this subtree right away to save some of the lookups required to find the in-memory structure that should receive the edit. Except for merges, tree-editing also enables users to generate their own trees, for instance to create a procedural commit. Repository::edit_tree() will get you started. In-Memory Object Writing When editing trees, or performing any other operation that writes a lot of objects, it's often useful to be able to avoid writing them to disk. That way, they can either be conditionally discarded, or they could be written into a pack all at once, avoiding lots of IO that would happen when writing many loose objects serially. Repository::with_object_memory() will enable it on the given repository instance, and it's typically used like gix::open(path)?.with_object_memory() . Blob-Merging (work-in-progress) On the way towards doing a full multi-root tree merge, it's required to handle a blob-merge as well, with conflict markers and resolution modes and everything. It took a while to finish the research and get started, but by now and 2300 lines of code later it's shaping up neatly with the 'big picture' of the algorithm already implemented and all baseline tests (i.e. comparisons to Git) passing. Still a lot of work to be done though to capture all the details and wire it up to gix . Security How configuration path resolution can be abused Eliah was busy and found an (already fixed) vulnerability where an attacker could abuse the incorrect decoding of quoted configuration file paths to have a gitoxide program access a configuration file path under the attackers control. Community The GitMerge 2024 in Berlin I have Scott Chacon and GitButler to thank for having been invited to the GitMerge conference to talk about gitoxide , and meet many fantastic people, with each and everyone being involved in Git. It was like heaven and felt a little bit like a vacation, too. During the second day, I could get 'upstairs' to the core developer session about Rust in Git and witness a possibly historic gettogether, and maybe one that will be the reason for Rust finally landing in Git to modernize it, and make it more maintainable. Also as part of the day two unconference, I was sharing everything there is to know about precious files in gitoxide , maybe to help them along getting implemented in Git, it was great fun, particularly because Elijah Newren, the author of the technical document, joined us in just the right moment to chime in. Overall, the conference was an event that is impossible to forget, with my only regret being that I didn't take enough pictures! Nobody will believe me otherwise :D. Gitoxide and the Sovereign Tech Fund Did you know that Ed Thomson, the maintainer of libgit2 , was at GitMerge to present? His talk was my personal highlight, with the added bonus him announcing that the libgit2 Drips donation will now be made available via Open Collective . To make it even better he shared his intention to donate some of that to git2 (the Rust wrapper crate) and gitoxide as well - this will be my incentive to get gitoxide onto Open Collective, and maybe that's a first step towards finally applying for funding from the Sovereign Tech Fund. Faster CI It took @NobodyXu just a few tweaks to make CI run significantly faster. And as so often, it wasn't the faster CPU that caused it, but a reduction of waste! And what's best is that one truly notices it. With that I'd think that CI can now beome slower again, but by running more tests, and even that won't be an impediment as 'auto-merge' now has arrived as well, so no more waiting for CI is needed. All in all, gitoxide CI definitely is in a very good spot now (particularly since Eliah Kagan re-enabled fuzzing as well). 'Blame' is getting there Thanks to @cruessler continuous work 'blame' is growing strong , and clocks in at nearly 2500 lines of code. I still owe a review but would hope that this first PR can be merged without much delay so it can be merged available in higher layers. Gix in Cargo Nothing changed, and it's a bit sad that none fo the GitButler -driven improvements thus far are applicable to push the Cargo integration forward. However, reset is done a lot, also in Cargo, so I'd hope this to be another avenue to finally that get last 'tree-index-status' part done which has been on my list for way too long already. Cheers Sebastian PS: The latest timesheets can be found here (2024) . Beta Was this translation helpful? Give feedback. 7 You must be logged in to vote 12 6 10 All reactions 12 6 10 Replies: 0 comments Sign up for free to join this conversation on GitHub .
    Already have an account? Sign in to comment
======>
https://old.reddit.com/r/rust/comments/1fwbdxs/llm_client005_the_easiest_way_to_integrate/
-->>-->>
Installable via    crates.io    - automatically builds for windows, linux, mac with or without CUDA.   

   It's kind of like a Rust Ollama, but the focus is on using LLMs to replace traditional control flow (if statements).   

   let response: u32 = llm_client.reason().integer()
    .instructions()
    .set_content("Sally (a girl) has 3 brothers. Each brother has 2 sisters. How many sisters does Sally have?")
    .return_primitive().await?;
   

   This performs CoT reasoning and returns a number (or boolean or custom string value) you can use in your code. With a small model like phi3.5 and a GPU, it can perform this process in around a second. So, the idea is to use it for agent behavior and NLP tasks.   

   Also, based on your available VRAM it will estimate the largest quant for the selected model, but you can also specify local models or device configs, or even run multiple models at once.   

   The goal is to make it as easy to use as possible - so building from a crates install was a big goal. It turns out it wasn't so bad, but I did have to buy a macbook to test it on!   

   https://github.com/shelbyJenkins/llm_client   
   

======>
https://old.reddit.com/r/rust/comments/1fvzfnb/gg_a_fast_more_lightweight_ripgrep_alternative/
-->>-->>
Searching the tokio codebase   

   Hi there,   
Here's a small project akin to ripgrep.   
Feel free to play around with it :-)   
Cheers   

   https://github.com/alexpasmantier/grip-grab        
   

======>
https://vosen.github.io/ZLUDA/blog/zludas-third-life/
-->>-->>
The year of rebuild The ultimate goal is to bring "new" ZLUDA to a similar state as before the rollback in one year (Q3 2025). "Similar state" is very subjective here. I don't have precise criteria, but an application of similar complexity should work just as well. Not every pre-rollback application will be supported again due to new priorities (more below). The year of rebuild